<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-24
-->

# React Placement and Layering â€” Agent Rules

## Table of contents
- [Summary](#summary)
- [Rule: Skill Scope Definition](#rule-skill-scope-definition)
- [Summary](#summary)
- [Rule: Layer Mapping](#rule-layer-mapping)
- [Summary](#summary)
- [Rule: Structured Placement Output](#rule-structured-placement-output)
- [Summary](#summary)
- [Rule: Strategy and One-Home Discipline](#rule-strategy-and-one-home-discipline)
- [Summary](#summary)
- [Rule: Default Bias and Clean Pause Protocol](#rule-default-bias-and-clean-pause-protocol)
- [Summary](#summary)
- [Rule: Discovery Coverage and Convention Alignment](#rule-discovery-coverage-and-convention-alignment)
- [Summary](#summary)
- [Rule: Constraint-Aware Placement Scope](#rule-constraint-aware-placement-scope)
- [Summary](#summary)
- [Rule: Repository Evidence Access](#rule-repository-evidence-access)
- [Summary](#summary)
- [Rule: Fixed Execution-Skill Scope](#rule-fixed-execution-skill-scope)
- [Summary](#summary)
- [Rule: Implementation Output Format Defaults](#rule-implementation-output-format-defaults)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react_placement_and_layering` skill.

Key constraints:
- Follow `agent-policy-v1` unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- rpl-overview-scope
- rpl-process
- rpl-output
- rpl-migration-safety
- rpl-default-bias
- rpl-discovery-conventions
- rpl-scope-governor
- rpl-access-control
- rpl-skill-model-alignment
- rpl-implementation-handoff

---

# Overview

## Summary

This document defines the authoritative rules for the `react_placement_and_layering` skill.

This skill operates under:
- `agent-policy-v1` (mandatory baseline policy)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rpl-overview-scope  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Ensures placement decisions stay within boundaries.

### Requirement

- The skill must map work to the correct layer and folder.
- The skill must use architecture detection outputs as inputs.
- The skill must justify placement with boundary rules.
- The skill must inherit and enforce shared baseline constraints from
  `agent-policy-v1`.
- The skill must validate required inputs before planning.
- The skill must return strict machine-consumable JSON output only.
- The skill must keep output structural and exclude raw source snippets and
  secret-like values.

### Forbidden

- Creating new layers without explicit approval.
- Ignoring existing architectural conventions.
- Defining local mandatory rules that conflict with `agent-policy-v1`.
- Producing best-effort plans from missing or invalid required inputs.
- Returning unstructured prose output outside the output contract.

### Notes

- If placement is ambiguous, list options and preferred choice in contract
  fields only.

---

# Placement Process

## Summary
Defines the placement workflow for new or updated files.

---

## Rule: Layer Mapping
**Rule ID:** rpl-process  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Keeps placement decisions consistent and testable.

### Requirement

- Validate required inputs before planning:
  - implementation request
  - target architecture rules
  - architecture-detection result
- Translate the request into explicit planning requirements before choosing
  files.
- Classify the request using one or more task categories before placement:
  - new page/route
  - new feature capability
  - new UI element
  - new API endpoint/backend integration
  - refactor/reuse improvement
  - bug fix
- Select one primary feature owner for the run.
- Select one strategy for the run (`follow-existing`,
  `introduce-boundaries`, or `migrate-as-you-touch`).
- Enforce import guardrails before finalizing:
  - `ui/**` must not import from `features/**`, `api/**`, `store/**`, or
    `pages/**`
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`
  - `lib/**` must not import React
  - `features/**` must not import from `pages/**`
  - `pages/**` must not import from the canonical endpoint layer directly; use
    feature hooks
  - `hooks/**` must not import from `features/**`, `pages/**`, or `store/**`;
    imports from `api/**` are allowed only when documented in exactly one
    canonical policy location
  - fetching/transport must remain in the canonical endpoint layer for the task
  - when a path alias exists (for example `@/`), apply guardrails to alias and
    raw `src/**` paths equally
- Enforce cross-layer error ownership in placement decisions:
  - `api/endpoints/**` owns normalized typed transport errors (`ApiError`) with
    `message` and optional `status`, `code`, `details`, and `cause`
  - `features/*/hooks/**` expose consistent error result shape and do not emit
    toasts/snackbars for query/page-load failures
  - `pages/**` and `features/*/sections/**` own user-facing error behavior;
    default query/page-load failures to inline retry UI
  - mutation toast/snackbar feedback is allowed only when that app pattern
    already exists; otherwise keep mutation feedback inline near the action
- Enforce state persistence policy when store/global-state artifacts are planned:
  - persist only user preferences and lightweight durable UI state
  - prefer URL query parameters for shareable/bookmarkable state
  - do not persist ephemeral UI state (for example modal open flags)
  - do not persist server-state snapshots in global store unless explicitly
    justified by performance-critical caching, offline-first requirements, or a
    documented architectural decision
- Map requested changes to a single owning layer per artifact.
- Perform required repository lookup before proposing new artifacts:
  - existing route files
  - existing feature sections
  - existing UI composites/primitives
  - existing endpoint/DTO files
  - existing store slices
  - naming/export conventions
- Prefer reuse of existing folders over creating new ones.
- Apply action decision ladder per artifact:
  - `reuse` when a suitable artifact already exists as-is
  - `update` when small extension of an existing artifact is enough
  - `create` only when reuse/update is not suitable
- Produce explicit artifact records with purpose, action, layer, and path.
- For architecture/repository concern conflicts:
  - use architecture detection as default source and do not recompute gravity
  - if architecture confidence is below `0.7` and impact is structural, trigger
    clean pause protocol and, after explicit resolution, select repository
    evidence with `resolution_mode=pause_resolved`
  - for all other conflict cases, keep architecture detection as the effective
    source
  - after explicit resolution, record each concern in
    `source_of_truth_resolutions`
- Preserve unresolved high-impact structural ambiguity from architecture
  detection or placement analysis and block plan finalization until
  clarification is resolved.
- Keep a concise authoritative-home map for the run and use it consistently for
  placement decisions (`authoritative_home_map`).
- If no path alias is already configured, keep relative imports and do not
  introduce alias configuration unless explicitly requested.
- Include decision explanation metadata with detected architecture signals and
  chosen direction.
- Document why adjacent layers were not chosen.
- If move/rename operations are explicitly enabled, include `old_path ->
  new_path` and import-update targets before finalizing.
- In move-enabled runs, keep moves small (default: three files or fewer) and
  keep moves scoped to one concern in the run.

### Forbidden

- Splitting a single responsibility across multiple layers.
- Introducing inconsistent naming conventions.
- Emitting placement artifacts without a selected strategy and owner.
- Finalizing a plan when guardrail violations remain unresolved.
- Creating new artifacts when a clearly suitable reusable artifact already
  exists.
- Recomputing gravity independently from architecture-detection output.
- Applying repository-evidence override without explicit pause resolution when
  structural impact is present.
- Finalizing `result_type=plan` while unresolved high-impact structural
  ambiguity remains.
- Emitting move/rename plans without explicit import-update targets.

### Notes

- Use deterministic defaults when choices are otherwise equivalent.
- If non-structural ambiguity remains after lookup, choose the safest minimal
  artifact and record the ambiguity in notes.
- If structural ambiguity remains unresolved, pause and request confirmation.

---

# Output Contract

## Summary
Defines the expected output structure for placement decisions.

---

## Rule: Structured Placement Output
**Rule ID:** rpl-output  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Ensures decisions are traceable and actionable.

### Requirement

- Output must be one JSON object that follows a strict versioned contract.
- Successful placement results must use `result_type=plan`.
- Invalid or missing required inputs must use `result_type=validation_error`.
- `result_type=plan` output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `strategy_used`
  - `feature_owner`
  - `canonical_endpoint_layer`
  - `authoritative_home_map`
  - `artifacts`
  - `layer_justifications`
  - `decision_explanation`
  - `import_guardrails`
  - `source_of_truth_resolutions`
  - `validation_status`
  - `notes`
- `result_type=plan` may include `scope_expansion_needed` when out-of-cap
  follow-up work would materially improve completeness.
- Each artifact must include:
  - `purpose`
  - `action` (`reuse | update | create`)
  - `action_rationale`
  - `layer`
  - `path`
  - `depends_on` (when relevant)
- `source_of_truth_resolutions` entries must include:
  - `concern`
  - `default_source`
  - `architecture_confidence`
  - `override_threshold`
  - `effective_source`
  - `resolution_mode` (`inherited | pause_resolved`)
  - `resolution_reason`
- `layer_justifications` must provide at least one concise rationale per touched
  layer.
- `decision_explanation` must summarize detected architecture signals and the
  chosen direction.
- `authoritative_home_map` must provide a concise map of current authoritative
  homes for relevant concerns (for example `ui`, `api`, `domain`, `routing`).
- If move/rename operations are present, output must include
  `move_operations[]` with `old_path`, `new_path`, and `import_update_targets`,
  plus `move_concern`.
- `move_operations[]` must contain three items or fewer.
- `notes` must remain concise with maximum 5 items.
- `notes` and artifact rationales must be structural (planning metadata only).
- If `scope_expansion_needed` is present, each item must include:
  - `why`
  - `would_touch` (integer count of additional files)
- `result_type=validation_error` output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `result_type`
  - `validation_status` (`is_valid=false`, `stage=input-validation`, and at
    least one error)
  - `notes`
- `result_type=validation_error` must not include plan fields (`strategy_used`,
  `feature_owner`, `canonical_endpoint_layer`, `authoritative_home_map`,
  `artifacts`,
  `layer_justifications`, `decision_explanation`, `import_guardrails`,
  `source_of_truth_resolutions`, `move_operations`, `move_concern`,
  `scope_expansion_needed`).

### Forbidden

- Vague placement guidance without concrete paths.
- Omitting justification for layer selection.
- Returning free-form prose outside JSON output.
- Returning plan output that omits mandatory contract fields.
- Returning validation-error output without explicit input-validation errors.
- Returning output fields with raw source snippets or secret-like values.
- Using `effective_source=repository_evidence` for structural conflicts without
  `resolution_mode=pause_resolved`.

### Notes

- Keep notes concise and tied to the request.

---

# Migration Strategy and Placement Safety

## Summary
Defines migration-aware placement behavior and duplicate-home prevention.

---

## Rule: Strategy and One-Home Discipline
**Rule ID:** rpl-migration-safety  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Prevents parallel architectures and unsafe structural churn.

### Requirement

- Choose exactly one strategy per run:
  - `follow-existing`
  - `introduce-boundaries`
  - `migrate-as-you-touch`
- Follow gravity for each concern by extending the active home unless an
  explicit migration boundary is selected.
- Avoid duplicate homes by keeping one authoritative home per concern in the
  run (`authoritative_home_map`).
- Introduce new target structure only when the new scope is isolated,
  self-consistent, and does not create competing homes.
- Classify placement work as either:
  - feature task (default: updates/creates only, no moves), or
  - migration task (moves allowed only in explicit migration scope).
- Default move posture is no moves/renames; move operations require explicit
  enablement and complete import-update targets.
- In move-enabled runs, keep move scope bounded to one concern and three files
  or fewer.
- In bootstrap-triggered repositories (flat/ad-hoc with no clear homes), folder
  creation is limited to canonical homes and only the minimal folders needed for
  the task.
- In bootstrap mode, create `store/` only when truly global client state is
  required.

### Forbidden

- Treating two locations as simultaneously correct for the same concern.
- Introducing broad relocation/migration during routine feature-scope planning.
- Creating bootstrap folders outside canonical homes.
- Mixing feature-behavior changes with structural migration by default.

### Notes

- Prefer stable import boundaries and incremental convergence over early broad
  file moves.

---

# Deterministic Defaults and Pause Discipline

## Summary
Defines deterministic default actions and strict pause criteria for placement
decisions.

---

## Rule: Default Bias and Clean Pause Protocol
**Rule ID:** rpl-default-bias  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Keeps planning flow predictable while pausing only for
high-impact ambiguity.

### Requirement

- Apply deterministic defaults unless structural risk requires a pause:
  - ambiguous feature owner -> choose the most specific domain
  - UI pattern unclear -> keep logic in the feature section
  - reuse vs generalize unclear -> prefer section-level duplication
  - multiple state options -> prefer local state first
  - unsure store usage -> avoid introducing global store state
  - unsure abstraction -> keep implementation concrete
  - API placement unclear -> use the existing API home
  - folder placement unclear -> follow gravity and nearest established home
  - naming unclear -> match nearest-neighbor naming
- Pause only when both are true:
  - `confidence < 0.7`
  - impact is structural
- For low-confidence non-structural decisions, proceed with deterministic
  defaults.
- When pausing, use a clean protocol:
  1. state the structural ambiguity
  2. provide two or three bounded options
  3. provide one recommended default
  4. wait for confirmation
- Default pause mode is `balanced`; respect explicit policy overrides for
  `strict` or `autonomous` modes.

### Forbidden

- Pausing for minor naming choices, harmless small prop additions, or other
  low-impact local decisions with safe defaults.
- Asking vague or philosophical architecture questions during execution.
- Continuing with conflicting structural assumptions after deciding a pause is
  required.

### Notes

- Question quality must remain high-leverage, structural, and blocking.

---

# Discovery and Convention Fit

## Summary
Defines mandatory repository discovery and naming/export convention checks before
final placement output.

---

## Rule: Discovery Coverage and Convention Alignment
**Rule ID:** rpl-discovery-conventions  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Prevents duplicate artifacts and naming drift in placement plans.

### Requirement

- Discovery must check existing homes before proposing new artifacts:
  - route files/entry points
  - feature sections, hooks, and domain modules
  - UI composites and primitives
  - endpoint and DTO modules
  - store slices and state ownership patterns
  - naming/export conventions in the active area
- Naming and export checks must enforce local consistency:
  - pages: `*Page` unless framework or local conventions require otherwise
  - feature sections: `*Section`
  - hooks: `use*`
  - DTOs: `*Dto` and DTO placement in `api/dto` or the gravity-equivalent home
  - component files/exports in `PascalCase`
  - hook files/exports in `useXxx` camelCase
  - named exports by default; allow default exports only for framework-required
    modules or established local-area conventions
  - avoid introducing new barrels unless the local area already uses them
- Keep names searchable by aligning file names and primary exports.
- Use one role term per area (for example `Page` vs `Route` vs `Screen`) and do
  not mix synonyms unpredictably in one area.
- If tests exist in the target area, follow colocated naming compatibility
  (`*.test.tsx` or `*.test.ts`) for touched artifacts.
- Record concrete discovery evidence (paths) or explicit `not_found` outcomes
  before selecting `create`.

### Forbidden

- Proposing new artifact homes before discovery checks complete.
- Inventing a new naming/export style in an established area.
- Treating naming ambiguity as justification for structural churn.

### Notes

- Convention fit is part of placement correctness, not optional polish.

---

# Constraint and Scope Governor Alignment

## Summary
Defines required scope and constraint handling for placement planning.

---

## Rule: Constraint-Aware Placement Scope
**Rule ID:** rpl-scope-governor  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Keeps plans reviewable and prevents implicit scope expansion.

### Requirement

- Respect explicit task constraints when provided, including:
  - `avoid_new_folders`
  - `max_files_touched`
  - move/rename enablement and limits
- If explicit constraints are absent, apply shared-policy hard defaults:
  - max files touched: `8`
  - max new files: `4`
  - max moved/renamed files: `0` unless migration mode is explicit
  - max new dependencies: `0` unless explicitly requested
  - max new top-level folders: `0` unless explicitly requested
- If scope pressure exceeds caps, produce the smallest in-cap plan and record
  concise follow-up scope in `notes`.
- If extra out-of-cap scope would materially improve completeness, include a
  structured `scope_expansion_needed` array with items:
  - `why` (short reason)
  - `would_touch` (number of additional files)
- When `scope_expansion_needed` is included, still return the in-cap placement
  plan in the same output.
- If `avoid_new_folders=true`, do not propose new folder homes unless explicit
  override is provided.
- If constraints block all safe placement outcomes, return
  `result_type=validation_error` with blocking errors.

### Forbidden

- Silently exceeding explicit or default scope caps.
- Proposing new dependencies as part of normal placement planning.
- Enabling moves/renames in feature-task mode without explicit migration scope.

### Notes

- Keep scope expansion explicit and bounded; do not hide it in placement output.

---

# Access Control and Fallback Context

## Summary
Defines read/search access expectations and fallback context requirements for
placement planning.

---

## Rule: Repository Evidence Access
**Rule ID:** rpl-access-control  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Placement decisions require repository evidence to avoid
speculative structure changes.

### Requirement

- Placement planning should run with repository read/search access.
- Minimum capabilities expected:
  - list tree shape under `src/`
  - search architecture and data-access patterns
  - read files on demand
  - read key config/tooling files relevant to routing, API homes, and naming
- If direct repository access is unavailable, require a fallback context bundle
  before finalizing a plan:
  - file tree (top-level and `src/` depth about 3-4)
  - `package.json`
  - router entry/setup files
  - API client/home location currently in use
  - representative primitive/composite/section/hook/endpoint examples
- Without repository evidence or fallback bundle, return
  `result_type=validation_error` and do not emit a plan.
- This skill remains planning-only and does not perform implementation edits.
- Default write posture is controlled/review-oriented output; avoid silent churn
  and unreviewed direct edits as routine behavior.
- Do not auto-edit architecture/specification documents during routine tasks
  (`ARCHITECTURE.md`, `specs/**/master_spec.md`, `spec/**`).
- Treat architecture/specification document edits as dedicated documentation
  scope and perform them only when explicitly requested.

### Forbidden

- Finalizing structural placement without repository evidence.
- Assuming gravity/convention outcomes when both direct access and fallback
  context are missing.
- Treating direct source edits as normal output for this skill.

### Notes

- When evidence is constrained, surface uncertainty in concise structural notes.

---

# Skill Model Alignment

## Summary
Defines alignment with the fixed execution-skill model and shared policy layer.

---

## Rule: Fixed Execution-Skill Scope
**Rule ID:** rpl-skill-model-alignment  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Prevents skill-scope drift and preserves cross-skill ownership
boundaries.

### Requirement

- Treat `react_placement_and_layering` as one of the fixed production execution
  skills.
- Keep primary output focused on placement plans and layer assignments.
- Coordinate with upstream architecture detection outputs and downstream reuse
  and implementation skills without absorbing their responsibilities.
- Keep shared policy/config as a separate baseline layer; do not re-model
  policy concerns as new execution-skill behavior.
- Preserve four-skill production scope:
  - `react_architecture_detection`
  - `react_placement_and_layering`
  - `react_reuse_update_new`
  - `react_implementation_discipline`

### Forbidden

- Expanding this skill to perform full implementation, broad refactors, or
  architecture detection recomputation.
- Reframing shared policy-layer behavior as a new execution-skill concern.
- Expanding production scope beyond the fixed four execution skills.

### Notes

- Cross-skill handoffs must remain explicit and machine-consumable.

---

# Implementation Handoff Formatting

## Summary
Defines downstream implementation-output formatting defaults referenced by this
planning skill.

---

## Rule: Implementation Output Format Defaults
**Rule ID:** rpl-implementation-handoff  
**Priority:** MUST  
**Applies to:** react_placement_and_layering  
**Rationale:** Keeps handoff output reviewable and consistent across placement
and implementation stages.

### Requirement

- This skill remains planning-first and JSON-contract driven.
- When a downstream implementation handoff is requested, use these formatting
  defaults:
  - updated files: provide changed snippets by default
  - switch to unified diff when:
    - edits span non-adjacent regions in one file
    - changes touch imports, exports, and logic together
    - snippet-only output is likely to be misapplied
  - new files: provide full file content
  - existing files: avoid full-file dumps unless explicitly requested, or the
    file is small (about under 60 lines) and entirely changed
  - if a newly proposed file would exceed about 250 lines, split
    responsibilities instead of producing one oversized file
- Keep implementation-handoff guidance scoped to the approved placement plan and
  scope-governor limits.

### Forbidden

- Returning implementation output in free-form or low-context formats that
  increase patch-application risk.
- Combining structural migration and feature behavior changes in one handoff
  unless migration scope is explicitly requested.
- Expanding handoff scope beyond the selected placement plan without explicit
  structured scope expansion.

### Notes

- These defaults govern implementation handoff shape; they do not replace the
  mandatory placement JSON contract.
