<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-27
-->

# React Architecture Detection â€” Agent Rules

## Table of contents
- [Rule: Skill Scope Definition [sr-overview-scope]](#rule-skill-scope-definition)
- [Rule: Baseline Non-goals [sr-overview-nongoals]](#rule-baseline-non-goals)
- [Rule: Minimal Scope Enforcement [sr-constraints]](#rule-minimal-scope-enforcement)
- [Rule: Scope Governor Hard Defaults [sr-scope-governor]](#rule-scope-governor-hard-defaults)
- [Rule: Governance Compliance [sr-governance]](#rule-governance-compliance)
- [Rule: Architecture and Dependency Boundaries [sr-architecture-boundaries]](#rule-architecture-and-dependency-boundaries)
- [Rule: Ownership and Naming Contract [sr-ownership-naming]](#rule-ownership-and-naming-contract)
- [Rule: Deterministic Defaults and Pause Protocol [sr-decision-defaults]](#rule-deterministic-defaults-and-pause-protocol)
- [Rule: Output and Planning Discipline [sr-output-discipline]](#rule-output-and-planning-discipline)
- [Rule: Migration and Placement Strategy [sr-migration-placement]](#rule-migration-and-placement-strategy)
- [Rule: Fallback Technology Defaults [sr-fallback-defaults]](#rule-fallback-technology-defaults)
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: Access and Write Control [sr-access-write-control]](#rule-access-and-write-control)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Architecture Detection Output and Bootstrap Contract [sr-architecture-detection-contract]](#rule-architecture-detection-output-and-bootstrap-contract)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: `*Like` and `Maybe<T>` Discipline Index [sr-type-like-maybe]](#rule-like-and-maybet-discipline-index)
- [Rule: `*Like` Boundary Discipline [sr-type-like-boundary]](#rule-like-boundary-discipline)
- [Rule: `Maybe<T>` Semantics Discipline [sr-type-maybe-semantics]](#rule-maybet-semantics-discipline)
- [Rule: Domain Type Integrity [sr-domain-type-integrity]](#rule-domain-type-integrity)
- [Rule: No Cross-Feature Dependencies [sr-features-no-cross-deps]](#rule-no-cross-feature-dependencies)
- [Rule: Type Assertion Discipline (`as T`) [sr-types-assertion-discipline]](#rule-type-assertion-discipline-as-t)
- [Rule: Double Type Assertion Discipline (`as unknown as T`) [sr-types-double-assertion]](#rule-double-type-assertion-discipline-as-unknown-as-t)
- [Rule: Deep Relative Imports Should Trigger `@/` Alias Suggestion [sr-import-alias-suggestion]](#rule-deep-relative-imports-should-trigger-alias-suggestion)
- [Rule: File Name Length Discipline [sr-filename-length]](#rule-file-name-length-discipline)
- [Rule: Output Mode Resolution and Display Safety [sr-output-mode-resolution]](#rule-output-mode-resolution-and-display-safety)
- [Rule: Skill Scope Definition [rad-overview-scope]](#rule-skill-scope-definition-1)
- [Rule: Deterministic Signal Scan [rad-process]](#rule-deterministic-signal-scan)
- [Rule: Structured Output [rad-output]](#rule-structured-output)
- [Rule: Strategy and One-Home Discipline [rad-migration-safety]](#rule-strategy-and-one-home-discipline)
- [Rule: Default Bias and Clean Pause Protocol [rad-default-bias]](#rule-default-bias-and-clean-pause-protocol)
- [Rule: Repository Evidence Access [rad-access-control]](#rule-repository-evidence-access)
- [Rule: Fixed Execution-Skill Scope [rad-skill-model-alignment]](#rule-fixed-execution-skill-scope)
- [Rule: Fast-path Detection Reuse [rad-fast-path-cache]](#rule-fast-path-detection-reuse)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-architecture-detection` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-overview-scope
- sr-overview-nongoals
- sr-constraints
- sr-scope-governor
- sr-governance
- sr-architecture-boundaries
- sr-ownership-naming
- sr-decision-defaults
- sr-output-discipline
- sr-migration-placement
- sr-fallback-defaults
- sr-layer-contracts
- sr-access-write-control
- sr-file-size-guidance
- sr-architecture-detection-contract
- sr-enforcement-heuristics
- sr-type-like-maybe
- sr-type-like-boundary
- sr-type-maybe-semantics
- sr-domain-type-integrity
- sr-features-no-cross-deps
- sr-types-assertion-discipline
- sr-types-double-assertion
- sr-import-alias-suggestion
- sr-filename-length
- sr-output-mode-resolution
- rad-overview-scope
- rad-process
- rad-output
- rad-migration-safety
- rad-default-bias
- rad-access-control
- rad-skill-model-alignment
- rad-fast-path-cache

---

# Overview

## Summary

This document defines the authoritative rules for the `react-architecture-detection` skill.

This skill operates under:
- `react-architecture-detection` (with mandatory shared baseline policy baked in at build time)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** sr-overview-scope  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared baseline governance and scope constraints explicit.

### Requirement

- The skill must operate only within its defined responsibility.
- The skill must not perform responsibilities assigned to other skills.
- The skill must not reinterpret or override policy without explicit approval.
- The shared baseline must apply uniformly to:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`
- The production execution skill set for this initiative is fixed to those four
  skills; the shared baseline policy is not a production execution skill.
- Shared policy/config updates must not be modeled as new execution skills.
- Document precedence must remain deterministic:
  - `specs/001-agent-policy-v1/master_spec.md` is authoritative.
  - Supporting policy docs may fill non-conflicting open details only.
- The shared baseline must explicitly govern:
  - Architecture/dependency boundaries.
  - Deterministic defaults and pause behavior.
  - Scope-governor limits and expansion protocol.
  - Output consistency for planning and implementation.
  - Ownership/naming conventions and completion checks.

### Forbidden

- Expanding scope beyond the Scope Governor without explicit override.
- Introducing implicit changes to repository structure.
- Creating competing policy sources that conflict with shared baseline precedence.
- Adding new production execution skills without explicit scope/constitution
  update.

---

## Rule: Baseline Non-goals
**Rule ID:** sr-overview-nongoals  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents policy drift into implementation-specific prescriptions.

### Requirement

- Shared policy must define constraints and governance, not implementation
  recipes.
- Shared policy must not implicitly change through examples, migration behavior,
  or downstream reinterpretation.
- Downstream skills may add local guidance only when it does not conflict with
  shared mandatory rules.

### Forbidden

- Treating examples as policy overrides.
- Introducing stack/framework mandates as shared-policy requirements without
  explicit spec approval.

### Notes

- If uncertainty affects governance decisions, pause and request clarification.

---

# Policy Constraints

## Summary
Defines non-negotiable scope and cap controls for downstream skill work.

---

## Rule: Minimal Scope Enforcement
**Rule ID:** sr-constraints  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents uncontrolled scope expansion and dependency creep.

### Requirement

- Changes must stay within the requested feature scope.
- New top-level folders must not be added without explicit approval.
- New dependencies must not be added without explicit approval.
- `pre_approved_collisions` must exist only in shared baseline header and be
  empty unless explicitly approved in a future version.
- When work appears to exceed scope caps, deliver the smallest viable in-cap
  result and provide a structured follow-up scope list.

### Forbidden

- Silent expansion of scope.
- Introducing unapproved dependencies or repositories.
- Defining downstream-local collision registries.
- Mixing structural migration moves with feature behavior work unless explicitly
  requested.

### Notes

- If a requirement cannot be met without expanding scope, pause and request
  approval.

---

## Rule: Scope Governor Hard Defaults
**Rule ID:** sr-scope-governor  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Controls churn and keeps delivery bounded.

### Requirement

- Hard defaults (unless explicitly overridden):
  - Max files touched: `8`
  - Max new files: `4`
  - Max moved/renamed files: `0` (unless migration mode explicitly enabled)
  - Max new dependencies: `0`
  - Max new top-level folders: `0`
- When caps are exceeded, provide a structured scope expansion request with
  concrete `why` and `would_touch` fields, while still delivering an in-cap
  result.

### Forbidden

- Exceeding hard defaults silently.
- Expanding dependency or top-level folder scope without explicit approval.

---

# Governance

## Summary
Sets expectations for compliance, documentation, and review.

---

## Rule: Governance Compliance
**Rule ID:** sr-governance  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures policies are enforced consistently across changes.

### Requirement

- All changes must be validated against the constitution and project specs.
- Documentation updates must keep guidance accurate and current.
- Generated artifacts must be produced by the official build process.
- Shared-policy rule changes must include an explicit policy version increment
  with documented rationale.
- Shared-policy exception approvals must be performed by repo maintainers only.
- Exception records must include rationale and conflicting rule reference.
- Exception records must not include expiry metadata; approved exceptions remain
  active until explicitly revoked or superseded by newer policy version.
- `pre_approved_collisions` must be managed only in the shared baseline header.
- Policy behavior must not be changed implicitly via examples, migration
  behavior, or downstream reinterpretation.

### Forbidden

- Bypassing validation requirements.
- Manual edits to generated artifacts.
- Approving shared-policy exceptions from non-maintainer roles.
- Adding expiry fields to shared-policy exception records.
- Defining downstream-local `pre_approved_collisions` sources.
- Changing shared-policy semantics without a version and rationale update.

### Notes

- If governance rules conflict, the constitution takes precedence.

---

# Architecture Boundaries

## Summary
Defines shared architecture and dependency-boundary rules all downstream skills
must enforce.

---

## Rule: Architecture and Dependency Boundaries
**Rule ID:** sr-architecture-boundaries  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills enforce one consistent
architecture and import-boundary model.

### Requirement

- The following non-negotiables must be enforced:
  - Do not create new folders unless explicitly allowed by policy or user
    instruction.
  - Never place domain business logic in `ui/**` or `api/**`.
  - Never fetch outside the canonical endpoint layer
    (`api/endpoints/**` or gravity-equivalent API home).
  - Prefer small, composable changes over large refactors.
  - Avoid `shared/` or `common/` dumping-ground patterns.
- Dependency direction must remain consistent with the baseline:
  - `ui/**` must not import `features/**`, `api/**`, `store/**`, or `pages/**`.
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`.
  - `features/**` must not import `pages/**`.
  - `pages/**` must not import canonical endpoint modules directly.
  - `hooks/**` must not import `features/**`, `pages/**`, or `store/**`; imports
    from `api/**` are allowed only when documented in exactly one canonical
    policy location.
- The canonical endpoint layer must be determined once per task by Architecture
  Detection and reused consistently in boundary checks for that task.
- If a path alias exists (for example `@/`), all boundary rules apply equally to
  alias imports and raw `src/**` imports.
- Generic fetch-hook exceptions are valid only when documented in exactly one
  canonical policy location; multiple policy locations invalidate the exception.
- No second home may be introduced for the same concern (UI/API/store/routing)
  unless explicit migration scope is approved.

### Forbidden

- Competing homes for the same concern in the same scope.
- Domain terms in reusable `ui/**` component file names.
- DTO-to-domain mapping in `api/**`.

### Notes

- Architecture Detection owns gravity decisions; downstream skills inherit those
  decisions unless a valid pause is triggered.

---

# Ownership and Naming

## Summary
Defines shared ownership boundaries and naming conventions for downstream skill
specifications.

---

## Rule: Ownership and Naming Contract
**Rule ID:** sr-ownership-naming  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps responsibility boundaries and naming deterministic across
all downstream specs.

### Requirement

- `pages/**` remain thin route orchestrators.
- `features/**` own domain behavior, feature hooks, and domain mapping.
- `ui/primitives/**` and `ui/composites/**` stay domain-agnostic.
- `api/**` stays transport-only and returns DTOs or normalized errors.
- `store/**` is global client-state only; do not mirror server-state without
  explicit justification.
- Naming conventions must remain deterministic:
  - `*Page.tsx` for pages.
  - `*Section.tsx` for feature sections.
  - `use*.ts` for hooks.
  - `*.dto.ts` and `*Dto` for DTOs.
- Naming and exports must remain searchable and consistent:
  - Prefer matching file/export names.
  - Prefer named exports unless framework conventions require default exports.
  - Avoid introducing barrel files unless the local area already uses them
    consistently.

### Forbidden

- Domain mode flags in shared composites.
- Introducing new naming schemes when local patterns are clear.
- API transport concerns in UI or generic hook layers.
- Mixed synonym vocabularies for the same role in the same scope (for example
  mixing `Page` and `Route` naming without existing convention).

---

# Decision Defaults and Pause Rules

## Summary
Defines deterministic default behavior and high-impact clarification triggers.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** sr-decision-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Reduces unnecessary clarification loops while protecting
high-impact structural decisions.

### Requirement

- Use deterministic defaults for non-structural ambiguity.
- Pause only when both are true:
  - `confidence < 0.7`
  - `impact = structural`
- Structural impact includes top-level structure changes, competing concern
  homes, dependency-direction changes, cross-layer moves, global state strategy
  changes, or scope-cap violations.
- When pausing, use clean pause protocol:
  - State ambiguity clearly.
  - Present 2-3 options.
  - Recommend a default.
  - Wait for confirmation.
- Use `balanced` pause mode by default unless explicitly configured otherwise.
- Do not pause for minor decisions when a safe default exists.

### Forbidden

- Proceeding on structural ambiguity without pause.
- Repeated low-value questions when a safe deterministic default exists.
- Vague, non-blocking, or style-only clarification questions that do not change
  structural outcomes.

---

# Output and Planning Discipline

## Summary
Defines required output structure for planning and implementation guidance.

---

## Rule: Output and Planning Discipline
**Rule ID:** sr-output-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps downstream planning and implementation outputs consistent,
compact, and reviewable.

### Requirement

- Planning outputs must include:
  - File touch plan (`Create`/`Update`/`Reuse` with paths).
  - Layer justification.
  - Reuse decision notes (`reuse as-is`, `updated`, `new`).
  - A short decision explanation that states detected architecture signals and
    chosen direction.
- Planning outputs must use a machine-readable JSON object with:
  - `output_mode` (`human|agent`)
  - `presentation.user_markdown` (prettified summary of the payload)
  - `notes[]` limited to 5 items
- Resolve `output_mode` precedence and display behavior via
  `sr-output-mode-resolution`.
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.
- Implementation output must:
  - Use changed snippets for updated files by default.
  - Use unified diff when edits are scattered across non-adjacent regions.
  - Use full content for new files.

### Forbidden

- Full existing-file dumps unless explicitly requested or file is small and
  fully changed.
- Unstructured narrative-only planning outputs.
- Omitting `presentation.user_markdown` from output payloads.
- Selecting `output_mode=agent` by habit/default when a human-invoked run does
  not explicitly request machine-readable output.

---

# Migration and Placement Strategy

## Summary
Defines migration-aware placement rules and strategy selection constraints.

---

## Rule: Migration and Placement Strategy
**Rule ID:** sr-migration-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents mixed-architecture drift and keeps placement decisions
deterministic in legacy or evolving repositories.

### Requirement

- Do not introduce parallel architectures for the same concern.
- Choose a strategy per change:
  - Follow existing.
  - Introduce target structure at boundaries.
  - Migrate as you touch (explicit migration scope only).
- Default balanced behavior:
  - No moves/renames unless explicitly enabled.
  - Introduce new homes only when isolated and non-competing.
  - Keep feature behavior and structural migration separate unless explicitly
    requested.
- Gravity decisions from Architecture Detection are inherited by downstream
  skills and must not be recomputed unless pause/escalation resolves a conflict.
- If move mode is explicitly enabled, keep moves small and complete import
  updates in the same change.

### Forbidden

- Two active homes for the same concern in one scope.
- Mixing broad structural migration with unrelated behavior changes.
- Recomputing gravity independently in downstream skills without escalation.

---

# Fallback Technology Defaults

## Summary
Defines shared fallback defaults used only when repository conventions are
missing or ambiguous.

---

## Rule: Fallback Technology Defaults
**Rule ID:** sr-fallback-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic cross-skill defaults while honoring
existing repository gravity first.

### Requirement

- Existing repository stack/conventions take precedence over fallback defaults.
- If no clear convention exists, defaults are:
  - Server-state: TanStack Query; keep transport in `api/endpoints/**`.
  - Client-state: local-first; global store only when truly global.
  - Routing: React Router for plain React; framework-native routing when
    framework is detected.
  - Styling: follow existing; Tailwind default only for greenfield.
  - Forms: react-hook-form.
  - Validation: Zod at boundaries (DTO/form), with domain schema ownership in
    feature domain layers.
  - HTTP client: native `fetch` via shared wrapper; normalized `ApiError`;
    conservative retry posture.
  - Build tool: Vite for greenfield plain React unless existing conventions say
    otherwise.
  - Date/localization: native `Date` and `Intl` unless domain needs justify
    more.
  - Identifier strategy: string IDs by default.

### Forbidden

- Introducing competing stack choices mid-repository without explicit request.
- Mirroring server-state into global store without explicit justification.

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# Access and Write Control

## Summary
Defines shared access assumptions and write-control behavior for downstream
skills.

---

## Rule: Access and Write Control
**Rule ID:** sr-access-write-control  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps structural decisions grounded in repository signals and
maintains controlled, reviewable changes.

### Requirement

- Detection/reuse/planning stages require repository read/search access.
- Minimum capabilities include:
  - Listing relevant file trees.
  - Searching code patterns.
  - Reading source/config files on demand.
- If direct access is unavailable, require a fallback context bundle with file
  tree, package/tooling config, router entry, API home, and representative
  module examples.
- Default write posture must be controlled and reviewable.
- If direct writes are enabled, scope-governor and minimal-churn rules still
  apply.
- Architecture/specification document edits require explicit request and must be
  treated as dedicated documentation scope.

### Forbidden

- Structural placement decisions without repository signal checks.
- Silent broad writes that bypass scope and review controls.
- Auto-editing architecture/spec documents during regular implementation work.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Architecture Detection Contract

## Summary
Defines the shared contract that downstream skills must inherit from
architecture-detection outputs, including bootstrap behavior.

---

## Rule: Architecture Detection Output and Bootstrap Contract
**Rule ID:** sr-architecture-detection-contract  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills consume one consistent
architecture-detection result and bootstrap behavior.

### Requirement

- Architecture detection output must include the shared structural signals:
  - `routing.type`
  - `ui.home`
  - `api.home` (canonical endpoint layer for boundary checks)
  - `domain.organization`
  - `gravity_map`
  - `alignment_score`
  - `strategy`
  - `notes[]`
- Gravity decisions are owned by architecture detection and reused by all
  downstream skills within the same task.
- Downstream skills must not recompute/override gravity unless a structural
  pause is triggered and explicitly resolved.
- Bootstrap behavior applies only when no clear concern homes exist:
  - Allow folder creation only from the canonical set:
    `pages/`, `features/`, `ui/primitives/`, `ui/composites/`, `api/client/`,
    `api/dto/`, `api/endpoints/`, `core/`, `lib/`, `hooks/`, `config/`
  - `store/` may be created only when truly global client-state is required.
  - Prefer minimal bootstrap: create only folders needed for the current task.

### Forbidden

- Consuming inconsistent architecture-detection outputs across downstream skills
  for the same task.
- Creating speculative bootstrap folders not needed by the current task.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# `*Like` and `Maybe<T>` Type Discipline

## Summary
Splits boundary flexibility and optionality semantics into separate rules while
keeping strict domain integrity requirements explicit.

---

## Rule: `*Like` and `Maybe<T>` Discipline Index
**Rule ID:** sr-type-like-maybe  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves backward-compatible entrypoint while delegating to
single-focus type rules.

### Requirement

- When this rule is in scope, follow all of:
  - `sr-type-like-boundary`,
  - `sr-type-maybe-semantics`,
  - `sr-domain-type-integrity`.

### Forbidden

- Applying this index rule without enforcing the referenced type-discipline
  rules.

---

## Rule: `*Like` Boundary Discipline
**Rule ID:** sr-type-like-boundary  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Restricts structural compatibility types to boundary layers.

### Requirement

- `*Like` types are allowed only when all are true:
  - they exist in boundary-oriented homes (`api/dto/**`,
    `features/<domain>/adapters/**`, input parsing/normalization layers),
  - they model external or pre-normalized input shape,
  - they are mapped immediately to canonical domain models,
  - they are not exported as canonical domain contracts.
- If a `*Like` type is introduced, all are required:
  - canonical mapped model exists,
  - mapper exists in same feature boundary,
  - mapping occurs before UI rendering or store persistence.

### Forbidden

- Using `*Like` inside `features/<domain>/domain/**`, `store/**`, or shared
  `ui/**`.
- Using `*Like` to avoid defining canonical domain models.
- Passing `*Like` deep into pages/sections without normalization.
- Naming canonical models as `SomethingLike`.

---

## Rule: `Maybe<T>` Semantics Discipline
**Rule ID:** sr-type-maybe-semantics  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces one explicit repository-wide optionality semantic.

### Requirement

- `Maybe<T>` is allowed only when all are true:
  - defined once in a canonical shared location (for example `src/lib/types.ts`),
  - semantics are exactly one of:
    - `type Maybe<T> = T | null`, or
    - `type Maybe<T> = T | undefined`,
  - repository uses one meaning consistently.
- Allowed contexts:
  - API response normalization,
  - feature-boundary pre-validation states,
  - explicit domain states where absence is meaningful.

### Forbidden

- Mixing `null` and `undefined` semantics arbitrarily.
- Using `Maybe<T>` to bypass validation.
- Defining multiple `Maybe` aliases in different modules.

---

## Rule: Domain Type Integrity
**Rule ID:** sr-domain-type-integrity  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps domain-layer contracts strict and canonical.

### Requirement

- In `features/<domain>/domain/**`:
  - types represent validated canonical models,
  - fields are required unless domain semantics explicitly model absence.
- `Maybe<T>` in domain models is allowed only when domain semantics require true
  optional state.
- Treat as architectural smell when:
  - `*Like` appears outside boundaries,
  - `Maybe<T>` appears broadly in `ui/**` or `store/**`,
  - canonical models overuse optional fields without domain justification.
- Deterministic defaults:
  - prefer canonical types with explicit mapping,
  - prefer required domain fields over optional wrappers by default.

### Forbidden

- Replacing canonical domain models with `*Like` types.
- Using `Maybe<T>` to keep post-validation required fields weak.
- Letting domain logic depend on structural compatibility types.

---

# No Cross-Feature Dependencies

## Summary
Prevents direct feature-to-feature imports to preserve ownership boundaries and
avoid feature-graph coupling.

---

## Rule: No Cross-Feature Dependencies
**Rule ID:** sr-features-no-cross-deps  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserve clear ownership and prevent feature-graph coupling that
causes architectural drift and refactor explosions.

### Requirement

- Core rule:
  - `features/**` must not import from other `features/**` modules.
  - This includes:
    - UI components/sections from another feature,
    - hooks from another feature,
    - domain models/types from another feature,
    - feature-local utilities/adapters/state from another feature.
- Allowed alternatives when multiple features need shared capability:
  1. `ui/**` for shared UI primitives/composites only (no domain logic/types),
  2. `lib/**` for pure cross-domain utilities (no React imports, no domain
     knowledge),
  3. `api/**` as shared transport contract in canonical endpoint layer
     (`api/endpoints/**` or gravity-equivalent), with each feature mapping DTO
     to its own domain model,
  4. `core/**` for cross-cutting infrastructure/composition (auth/session,
     telemetry, providers, routing setup; not domain behavior).
- Exception mechanism (rare):
  - cross-feature import is allowed only when all are true:
    - an explicitly designated shared-domain module exists (for example
      `features/_shared/**` or `domains/**`),
    - that module is documented in exactly one canonical policy location (for
      example `ARCHITECTURE.md` or `src/config/agentOverrides.ts`),
    - exported contracts are intentionally domain-agnostic or multi-feature
      primitives,
    - usage is consistent with no parallel ad hoc cross-feature imports.
  - absent such designation, cross-feature imports remain forbidden.
- Enforcement heuristics:
  - import path pattern `features/<A>/**` importing `features/<B>/**` where
    `A != B`,
  - a feature section rendering another feature section/component directly,
  - a feature hook calling another feature hook directly,
  - a feature consuming another feature's domain types instead of mapping
    transport data locally.
- Deterministic default:
  - prefer `lib/**` if pure,
  - prefer `ui/**` if UI-only,
  - otherwise keep feature-specific implementations separate; duplication at
    section level is acceptable while reusing shared primitives/composites.
- Hard stop conditions:
  - stop and revise when a change would:
    - introduce new cross-feature import,
    - move domain ownership from one feature into another without explicit
      migration scope,
    - create a second shared dumping-ground inside `features/**`.

### Forbidden

- Direct imports from one feature into another feature without explicit shared
  domain designation.
- Cross-feature coupling through UI, hooks, domain types, adapters, or
  feature-local state modules.
- Creating parallel ad hoc shared areas under `features/**` to bypass ownership
  boundaries.

---

# Type Assertion Discipline (`as T`)

## Summary
Allows narrow, locally provable assertions while forbidding assertion-driven
type lies across boundaries and domain models.

---

## Rule: Type Assertion Discipline (`as T`)
**Rule ID:** sr-types-assertion-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Allow necessary inference help without enabling type lies that
bypass boundaries, validation, and domain integrity.

### Requirement

- Definitions:
  - type assertion: `expr as T` (excluding `as const` literal narrowing),
  - external data: DTO/JSON payloads, untyped third-party values, `unknown`
    inputs, storage reads, and runtime data not guaranteed by TypeScript.
- Default stance:
  - non-`const` assertions (`as T`) are allowed when they reflect runtime
    reality and respect layer boundaries,
  - assertions are allowed only when narrowing or expressing known runtime truth
    that TypeScript cannot infer,
  - assertions must not coerce incompatible shapes or bypass validation.
- Green / OK cases:
  - narrowing where TypeScript cannot track local truth but runtime checks and
    context establish it (for example event/ref narrowing),
  - framework/library interop where upstream types are broader than effective
    runtime shape,
  - `as const`-adjacent narrowing assistance that does not alter semantic
    runtime shape ownership.
- Yellow cases (allowed with discipline, require scrutiny):
  - asserting API payload shape without validation (prefer `unknown` plus
    parse/guard),
  - asserting union member without checking discriminator/guard first.
- Allowed usage (narrowing-safe and locally provable):
  - DOM/event/ref narrowing after guards/invariant checks,
  - library/framework interop where upstream types are broader and safer
    alternatives are impractical,
  - narrowing an already-validated value (schema parse, type guard result).
- Scope rule:
  - apply assertion to the smallest possible expression.
- Boundary rule for external data:
  - do not assert external data directly to semantic/domain types,
  - treat external input as `unknown` (or DTO type),
  - validate/narrow via runtime schema checks or explicit guards/assert helpers,
  - map validated values to canonical domain models in feature boundary,
  - canonical domain types must come from validation plus mapping, not raw
    assertion,
  - do not propagate asserted external shapes across feature/domain boundaries.
- Prefer these alternatives before assertion:
  1. proper narrowing (`in`, discriminants, type guards),
  2. helper functions with narrowing-aware return types,
  3. runtime validation at DTO/form/storage boundaries,
  4. DTO-to-domain mapping.
- Escalation/refactor smell triggers:
  - repeated assertions for same shape problem in a feature,
  - assertions on API payloads or `JSON.parse` outputs,
  - assertions skipping mapping and flowing into domain/sections/pages,
  - assertions used where discriminated unions should exist.
  - when triggered, fix path is guard/validation plus mapping or stronger type
    modeling.
- Relationship to double assertion:
  - `as unknown as T` remains governed by `sr-types-double-assertion` (if
    present in repository policy) as last-resort escape hatch,
  - before double assertion, apply this rule's alternatives and boundary
    constraints first.
- Deterministic default:
  - when uncertain, do not assert; use `unknown` plus narrowing or boundary
    validation plus mapping.

### Forbidden

- Forcing correctness through assertion in:
  - `features/<domain>/domain/**` (domain invariants belong in
    constructors/guards/mappers),
  - `ui/**` shared primitives/composites for data-model coercion,
  - `store/**` state initialization from asserted external shapes.
- Asserting to make a type error disappear without proving runtime truth.
- Asserting union members without prior discriminator/guard evidence.
- Direct `as T` coercion of external data into canonical domain or semantic
  types.
- Assertion-driven bypass of validation and mapping boundaries.
- Assertion sprawl that substitutes for proper union modeling, guards, or
  schema validation.

### Notes

- Narrowing-safe DOM/ref assertions in UI are valid when they follow local
  runtime checks and do not coerce data models.

---

# Double Type Assertion Discipline (`as unknown as T`)

## Summary
Constrains double assertions to rare, boundary-scoped escape hatches with
adjacent safety steps and no unsafe propagation.

---

## Rule: Double Type Assertion Discipline (`as unknown as T`)
**Rule ID:** sr-types-double-assertion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents silencing type errors and leaking unsafe shapes across
boundaries while allowing rare, justified boundary interop.

### Requirement

- Definition:
  - double assertion is any `X as unknown as T` pattern (including equivalent
    two-step `any` cast patterns).
- Default stance:
  - double assertions are forbidden by default,
  - allowed only as last-resort boundary escape hatch.
- Escape hatch is allowed only when all are true:
  1. boundary-only location:
     - `api/dto/**` validation/parsing seams,
     - `features/<domain>/adapters/**`,
     - third-party interop wrappers,
     - legacy typed holes with no immediate safe alternative.
  2. narrow scope:
     - cast is applied to smallest possible expression.
  3. adjacent safety step:
     - same function/file scope includes runtime validation, explicit
       guard/assert helper (`isT`/`assertIsT`), or documented trusted-source
       rationale when validation is infeasible.
  4. no propagation:
     - result is normalized/mapped into canonical type before crossing deeper
       layers (especially before UI rendering or store persistence).
- Preferred alternatives must be attempted first:
  1. type narrowing/guards,
  2. stronger type modeling (generics/overloads/discriminated unions),
  3. runtime validation at boundaries,
  4. DTO-to-domain mapping to canonical types.
  - double assertion is permitted only when alternatives are impractical for
    current scoped change.
- Escalation/refactor smell triggers:
  - multiple double assertions in same feature area,
  - cast coercing DTO directly to domain model without mapping,
  - cast result exported/propagated beyond boundary seam,
  - repeated same cast pattern across call sites.
  - when triggered, add follow-up to replace with guard/assert helper, schema
    validation, or explicit mapping.
- Enforcement heuristics:
  - cast enables field access without validation,
  - cast bypasses known DTO/domain mismatch,
  - cast exists only to satisfy TypeScript with no safety explanation.
- Deterministic default:
  - when uncertain, do not use double assertion; prefer `unknown` plus narrowing
    or explicit mapping.

### Forbidden

- Double assertions in:
  - `ui/**`,
  - `features/<domain>/domain/**`,
  - `pages/**`,
  - `store/**`.
- Using double assertion to suppress type errors without adjacent safety
  evidence.
- Using double assertion as replacement for validation/mapping at boundaries.
- Allowing double-asserted external shapes to propagate across layers.

---

# Deep Relative Import Alias Suggestion

## Summary
Requires an explicit human-facing recommendation to introduce `@/` alias when
deep relative imports are detected and no canonical alias exists.

---

## Rule: Deep Relative Imports Should Trigger `@/` Alias Suggestion
**Rule ID:** sr-import-alias-suggestion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Reduces brittle path traversal noise while keeping alias adoption
as an explicit, human-approved tooling decision.

### Requirement

- Trigger this rule when touched or reviewed code contains deep relative import
  paths (for example `../../../` or deeper).
- If a canonical root alias already exists (for example `@/` or
  gravity-equivalent), use existing repository convention and do not propose a
  second alias system.
- If no canonical alias exists, the agent must include an explicit suggestion to
  the human to introduce `@/` aliasing for maintainability/readability.
- If no canonical alias exists and the active skill supports clarification
  requests (for example `react-refactoring-progression`), the agent must ask the
  human before planning alias adoption scope:
  - provide options `A`/`B`/`C` (optional `D`),
  - include one recommended option with brief rationale,
  - pause alias-related planning until answer is received.
- Suggestion content must be practical and scoped:
  - note why deep traversal is a maintenance smell,
  - propose introducing one canonical alias (prefer `@/` unless repository
    convention indicates otherwise),
  - state that migration can be incremental (touched files first).
- Alias introduction itself remains opt-in:
  - do not apply alias config/import rewrites unless explicitly requested or
    approved by user scope.

### Forbidden

- Silently introducing alias config and import rewrites when user scope does not
  request tooling/path changes.
- Planning alias-adoption changes in clarification-capable flows without asking
  the human first.
- Introducing a second competing root alias pattern when one already exists.
- Continuing to add new deep relative traversals in touched code after alias is
  already established by repository convention.

### Notes

- Boundary rules still apply equally to aliased imports and raw relative imports
  (aliasing is path ergonomics, not boundary bypass).

---

# File Name Length Policy

## Summary
Defines deterministic file-name length limits to preserve readability,
discoverability, and tooling ergonomics.

---

## Rule: File Name Length Discipline
**Rule ID:** sr-filename-length  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Long file names reduce grepability, readability, and review
velocity, and often signal mixed responsibilities.

### Requirement

- File naming must stay concise and searchable:
  - keep semantic base name length at `<= 64` characters (excluding extension),
  - prefer concise descriptive names and established local terminology,
  - keep file name and primary export aligned when applicable.
- Suffix handling:
  - known suffixes such as `.test`, `.spec`, `.stories`, `.dto`, and
    framework-required route names do not justify oversized semantic base names.
- When a candidate name exceeds limit:
  - split responsibility rather than encoding multiple concerns in one name,
  - shorten vocabulary using established local terms (no ad hoc abbreviations),
  - keep role suffixes clear (`Page`, `Section`, `Row`, `Badge`, `use*`, etc.).
- Deterministic default:
  - if uncertain, choose the shortest name that remains unambiguous in the
    local feature/layer context.

### Forbidden

- Introducing new files with semantic base names longer than 64 characters.
- Using file names that concatenate multiple responsibilities to avoid
  extraction/splitting.
- Renaming purely for style if the current name is within limit and clear.

---

# Output Mode Resolution

## Summary
Defines strict precedence for `output_mode` selection so human-invoked skill
runs do not accidentally emit raw JSON.

---

## Rule: Output Mode Resolution and Display Safety
**Rule ID:** sr-output-mode-resolution  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents accidental machine-mode output to humans and enforces
deterministic mode selection.

### Requirement

- Resolve `output_mode` using strict precedence:
  1. if request explicitly sets `output_mode`, honor it,
  2. else if requester explicitly asks for machine-readable/raw JSON output
     (automation/integration intent), set `output_mode=agent`,
  3. else if a human explicitly asks to run/use the skill, set
     `output_mode=human`,
  4. else default to `output_mode=agent`.
- Ambiguity fallback:
  - when uncertain between human and agent, choose `output_mode=human`.
- Display contract remains strict:
  - if `output_mode=human`, display only `presentation.user_markdown`,
  - if `output_mode=agent`, display full JSON payload.
- A human-invoked skill run must not infer automation intent unless the human
  explicitly requests machine-readable output.

### Forbidden

- Selecting `output_mode=agent` by habit/default when a human explicitly
  requested skill usage and did not request machine-readable output.
- Inferring automation intent without explicit signal from the request context.
- Displaying raw JSON to a human when `output_mode=human`.

---

# Overview

## Summary

This document defines the authoritative rules for the `react-architecture-detection` skill.

This skill operates under:
- `shared-rules` (mandatory baseline policy)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rad-overview-scope  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Ensures architecture detection stays within its defined responsibility.

### Requirement

- The skill must focus on detecting repository structure and gravity.
- The skill must not make placement decisions beyond reporting signals.
- The skill must not modify repository structure.
- The skill must be detection-only and must not perform feature implementation,
  file moves, or refactors.
- The skill must inherit and enforce shared baseline constraints from
  `shared-rules`.

### Forbidden

- Recommending direct file moves/refactors as mandatory actions during
  detection.
- Editing files as part of detection.
- Implementing runtime/business logic changes in repository source files.
- Defining local mandatory rules that conflict with `shared-rules`.

### Notes

- If signals are ambiguous, report uncertainty and provide bounded follow-up
  options in structured output fields.

---

# Detection Process

## Summary
Defines deterministic repository scanning and classification workflow for
architecture detection.

---

## Rule: Deterministic Signal Scan
**Rule ID:** rad-process  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Ensures architecture classification is evidence-based and
repeatable across runs.

### Requirement

- Validate required inputs before scanning:
  - `repo_root` (or current repository root)
  - `target_architecture` reference context
  - `task_scope` (`small_change | feature_change | new_route | refactor`)
- Accept optional hints when provided and treat them as weak priors only:
  - `framework_hint`
  - `router_hint`
  - `state_hint`
- Resolve effective output mode before scanning:
  - accept optional `output_mode` (`human|agent`)
  - default to `human` when a human explicitly instructs this skill to run
  - default to `agent` otherwise
- Run concern scans in deterministic order:
  1. routing and entry points
  2. UI homes/conventions
  3. domain organization
  4. API/data-access homes
  5. state ownership/home
- Routing scan must check framework and router signals, including:
  - Next (`app/**/page.*`, `next.config.*`, `next/navigation`)
  - Remix (`app/routes/*`, `remix.config.*`)
  - React Router/TanStack Router (`RouterProvider`, `createBrowserRouter`,
    `Routes`, `Route`, `@tanstack/router`)
- UI scan must detect active homes and conventions (`ui/`, `components/`,
  `common/`, `shared/`, `atoms/molecules` patterns).
- Data-access scan must identify the canonical backend-access home
  (`api/`, `services/`, `client/`) and current state stack signals.
- Domain scan must classify organization (`features`, `modules`, `domains`,
  `flat`, or `mixed`).
- Classify repository shape as one of:
  - close to target architecture
  - different but internally structured
  - flat/ad-hoc
- Determine clear concern homes using gravity heuristics (at least one):
  - about 70%+ of related files live there
  - most concern imports resolve there
  - recent active edits for that concern consistently use that location
- For concerns with confidence `< 0.7`, set:
  - `home = unknown`
  - `status = ambiguous`
  and include concise uncertainty notes.
- Produce exactly one `gravity_map`.
- Emit `api.home` as canonical endpoint layer for downstream boundary checks.
- Compute `alignment_score` (`0-100`) plus:
  - `alignment.blockers[]`
  - `alignment.next_migration_step`
- Use deterministic defaults when signals conflict and no high-impact structural
  ambiguity requires pause.

### Detection sequence

1. Gather repository entry/context signals.
2. Execute routing/UI/domain/API/state scans.
3. Score confidence and assign concern homes/status.
4. Build one gravity map and alignment summary.
5. Hand off migration strategy selection to `rad-migration-safety`.
6. Hand off pause evaluation to `rad-default-bias`.
7. Hand off output shaping to `rad-output`.

### Forbidden

- Skipping required concern scans or returning partial concern output.
- Returning multiple gravity maps in one run.
- Marking a concern `resolved` when confidence is `< 0.7`.
- Recomputing/overriding shared policy defaults locally.
- Emitting detection output without canonical endpoint-layer assignment.

### Notes

- If no clear signal exists, classify the area as ambiguous and surface
  uncertainty explicitly.
- Concern evidence should reference concrete files/folders, not generic claims.

---

# Output Contract

## Summary
Defines strict result envelopes and field requirements for architecture
detection outputs.

---

## Rule: Structured Output
**Rule ID:** rad-output  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Ensures downstream skills can consume architecture output without
reinterpretation.

### Requirement

- Output must be one machine-readable JSON object only.
- Root fields are mandatory for every result:
  - `schema_version`
  - `skill`
  - `version`
  - `output_mode`
  - `presentation`
  - `result_type`
  - `validation_status`
- `output_mode` must be exactly one of:
  - `human`
  - `agent`
- `presentation` must include:
  - `user_markdown` (prettified markdown summary of the payload)
- `result_type` must be exactly one of:
  - `detection_result`
  - `validation_error`
  - `dependency_error`
- `detection_result` must include at minimum:
  - `routing`
  - `ui`
  - `api`
  - `domain`
  - `state`
  - `gravity_map`
  - `alignment_score`
  - `alignment`
  - `strategy`
  - `strategy_rationale`
  - `pause_decision`
  - `notes`
- `detection_result` must include one canonical `api.home` and one
  authoritative `gravity_map`.
- `detection_result` must include alignment blockers and one
  next-migration step.
- `detection_result` may include `strategy_basis` and `bootstrap` metadata when
  applicable.
- `validation_error` must include `notes` and must not include detection fields.
- `dependency_error` must include:
  - `dependency_issue`
  - `fallback_context_bundle_requirements`
  - `notes`
  and must not include detection fields.
- `notes[]` must remain concise (maximum 5 items).
- Output fields must contain structural metadata only (no raw source snippets).
- Resolve payload/display behavior for `output_mode` via
  `sr-output-discipline` and `sr-output-mode-resolution`.

### Required fields

- `pause_decision` must be emitted for every `detection_result`.
- `pause_decision` must include:
  - `pause_required`
  - `pause_mode`
  - `decision_safety_confidence`
  - `impact`
- When `pause_required=true`, output must also include:
  - `trigger`
  - `options` (2-3 bounded options)
  - `recommended_option`

### Forbidden

- Returning free-form prose outside JSON output when `output_mode=agent`.
- Displaying raw JSON to humans when `output_mode=human`.
- Returning more than one strategy for one task.
- Omitting required fields for selected `result_type`.
- Returning error result types with detection payload fields.
- Omitting canonical endpoint-layer metadata (`api.home`) in
  `detection_result`.

### Notes

- `schema_version` is required on every payload revision.
- Keep output deterministic so downstream skills can reuse it without
  recomputation.

---

# Migration Strategy and Bootstrap Safety

## Summary
Defines strategy selection, one-home discipline, and bootstrap constraints for
architecture detection output.

---

## Rule: Strategy and One-Home Discipline
**Rule ID:** rad-migration-safety  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Prevents parallel-architecture guidance and unsafe migration
recommendations.

### Requirement

- Select exactly one strategy per run:
  - `follow-existing`
  - `introduce-boundaries`
  - `migrate-as-you-touch`
- Strategy selection criteria:
  - `follow-existing`: local gravity is clear or migration churn would be high.
  - `introduce-boundaries`: repo is flat/partially structured and isolated
    boundary introduction is feasible.
  - `migrate-as-you-touch`: migration scope is explicit and touched-area moves
    create immediate clarity.
- Always provide concise `strategy_rationale`.
- Preserve one-home-per-concern discipline in guidance.
- Do not recommend competing homes for the same concern.
- For bootstrap-triggered repositories (flat/ad-hoc with no clear
  routing/UI/API/domain homes), constrain recommendations to canonical set:
  - `pages/`
  - `features/`
  - `ui/primitives/`
  - `ui/composites/`
  - `api/client/`
  - `api/dto/`
  - `api/endpoints/`
  - `core/`
  - `lib/`
  - `hooks/`
  - `config/`
  - `store/` only when truly global client-state is required
- Bootstrap recommendations must be minimal and task-scoped (no speculative
  folder recommendations).
- Once a canonical home exists for a concern, do not recommend an alternate
  home unless explicit migration mode is enabled.

### Forbidden

- Emitting multiple strategies for one task.
- Recommending mixed parallel homes for the same concern.
- Recommending bootstrap homes outside canonical set.
- Recommending direct migration file moves/refactors as part of detection stage.

### Notes

- Detection may recommend a migration direction; implementation ownership remains
  downstream.

---

# Deterministic Defaults and Pause Discipline

## Summary
Defines pause thresholds, deterministic defaults, and clarification quality for
architecture detection.

---

## Rule: Default Bias and Clean Pause Protocol
**Rule ID:** rad-default-bias  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Keeps detection decisive while pausing only for high-impact
structural ambiguity.

### Requirement

- Evaluate pause need using decision-safety confidence and impact:
  - `strict`: structural ambiguity requires pause.
  - `balanced` (default): pause only when `impact=structural` and
    `decision_safety_confidence < 0.7`.
  - `autonomous`: pause only when `impact=structural` and
    `decision_safety_confidence < 0.5`.
- Concern-gravity confidence and decision-safety confidence are distinct:
  - low concern confidence must set concern `home=unknown` and
    `status=ambiguous`
  - low concern confidence alone must not force pause
- Emit `pause_decision` for every run.
- For non-structural ambiguity, proceed with deterministic defaults and record
  concise notes.
- Do not over-ask:
  - avoid pausing for minor naming/style questions
  - avoid pausing when a safe default exists
- When pausing, use clean protocol:
  1. state ambiguity clearly
  2. provide two or three bounded options
  3. provide recommended option
  4. stop and wait

### Forbidden

- Pausing on local/non-structural ambiguity when safe defaults exist.
- Proceeding on unresolved structural ambiguity that meets pause threshold.
- Asking vague or non-blocking architecture questions.

### Notes

- Question quality must remain high-leverage, structural, and blocking.

---

# Access Control and Fallback Context

## Summary
Defines repository evidence requirements and dependency-error behavior when
direct read/search access is unavailable.

---

## Rule: Repository Evidence Access
**Rule ID:** rad-access-control  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Reliable detection requires direct repository signals or explicit
fallback context.

### Requirement

- Detection should run with repository read/search access.
- Minimum capabilities expected:
  - list repository/src tree
  - search routing/UI/API/domain/state patterns
  - read source and config files on demand
- If direct access is unavailable, require fallback context bundle containing:
  - top-level and `src/` tree (depth about 3-4)
  - `package.json`
  - router entry/setup files
  - current API home/client location
  - representative primitive/composite/section/hook/endpoint examples
- If repository evidence is missing/incomplete, return `dependency_error` with
  actionable `fallback_context_bundle_requirements`.
- Keep default write posture controlled; this skill does not apply code edits.

### Forbidden

- Finalizing structural detection without repository evidence or fallback
  context.
- Guessing gravity homes when evidence is absent.
- Treating direct source edits as part of detection output behavior.

### Notes

- When access is constrained, keep uncertainty explicit in output notes.

---

# Skill Model Alignment

## Summary
Defines alignment with fixed execution-skill boundaries and shared policy layer.

---

## Rule: Fixed Execution-Skill Scope
**Rule ID:** rad-skill-model-alignment  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Prevents ownership drift between detection and downstream skills.

### Requirement

- Treat `react-architecture-detection` as one of four fixed production
  execution skills.
- Keep primary output focused on:
  - repository classification
  - concern homes / gravity map
  - migration strategy metadata
- Preserve ownership boundaries:
  - do not perform placement planning (Skill 2)
  - do not perform reuse/update/new decisioning (Skill 3)
  - do not perform implementation edits (Skill 4)
- Keep shared policy/config updates in shared layer; do not model them as new
  execution skills.
- Preserve fixed production scope:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`

### Forbidden

- Expanding this skill to absorb downstream planning or implementation work.
- Reframing shared policy behavior as a new execution skill.
- Expanding production scope beyond fixed four execution skills.

### Notes

- Downstream skills must reuse detection outputs rather than recomputing
  gravity by default.

---

# Fast-path Cache Reuse

## Summary
Defines safe reuse of cached detection context for refactor-session fast-path
detection.

---

## Rule: Fast-path Detection Reuse
**Rule ID:** rad-fast-path-cache  
**Priority:** MUST  
**Applies to:** react-architecture-detection  
**Rationale:** Speeds repeat detection runs without weakening confidence,
consistency, or schema correctness.

### Requirement

- Fast-path detection is allowed only when all are true:
  - task is part of the same repository context
  - existing code is being touched in a refactor/continuation flow
  - a trusted prior `detection_result` exists in memory cache
- Fast-path must refresh at minimum from current evidence:
  - `ui.home`
  - `api.home`
  - `domain.home`
  - `state.home`
  - `gravity_map`
- Carry forward unchanged fields only when refreshed evidence does not conflict.
- Recompute strategy/pause evaluation when refreshed evidence changes structural
  confidence or concern homes.
- Fall back to full scan when:
  - cache is missing
  - cache is stale or repository context changed
  - refreshed evidence lowers confidence on structural concerns
- Output must remain full schema-valid `detection_result` payload (not partial
  delta output).

### Forbidden

- Using cached output across different repositories or unrelated tasks.
- Returning partial payloads in fast-path mode.
- Reusing stale cache without current evidence refresh.

### Notes

- Fast path is a performance optimization, not a relaxation of detection rigor.
