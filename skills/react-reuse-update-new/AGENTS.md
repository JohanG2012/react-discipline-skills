<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-25
-->

# React Reuse vs Update vs New â€” Agent Rules

## Table of contents
- [Rule: Skill Scope Definition [sr-overview-scope]](#rule-skill-scope-definition)
- [Rule: Baseline Non-goals [sr-overview-nongoals]](#rule-baseline-non-goals)
- [Rule: Minimal Scope Enforcement [sr-constraints]](#rule-minimal-scope-enforcement)
- [Rule: Scope Governor Hard Defaults [sr-scope-governor]](#rule-scope-governor-hard-defaults)
- [Rule: Governance Compliance [sr-governance]](#rule-governance-compliance)
- [Rule: Architecture and Dependency Boundaries [sr-architecture-boundaries]](#rule-architecture-and-dependency-boundaries)
- [Rule: Ownership and Naming Contract [sr-ownership-naming]](#rule-ownership-and-naming-contract)
- [Rule: Deterministic Defaults and Pause Protocol [sr-decision-defaults]](#rule-deterministic-defaults-and-pause-protocol)
- [Rule: Output and Planning Discipline [sr-output-discipline]](#rule-output-and-planning-discipline)
- [Rule: Completion and Quality Baseline [sr-dod-baseline]](#rule-completion-and-quality-baseline)
- [Rule: Planning and Reuse Workflow [sr-planning-reuse]](#rule-planning-and-reuse-workflow)
- [Rule: Migration and Placement Strategy [sr-migration-placement]](#rule-migration-and-placement-strategy)
- [Rule: Fallback Technology Defaults [sr-fallback-defaults]](#rule-fallback-technology-defaults)
- [Rule: Implementation Defaults [sr-implementation-defaults]](#rule-implementation-defaults)
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: Access and Write Control [sr-access-write-control]](#rule-access-and-write-control)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Architecture Detection Output and Bootstrap Contract [sr-architecture-detection-contract]](#rule-architecture-detection-output-and-bootstrap-contract)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: Micro-change Bypass and Skill 4 Micro Mode [sr-micro-change-bypass]](#rule-micro-change-bypass-and-skill-4-micro-mode)
- [Rule: Component Folderization Threshold [sr-component-folderization]](#rule-component-folderization-threshold)
- [Rule: Folder Structure for a Folderized Component [sr-component-folder-structure]](#rule-folder-structure-for-a-folderized-component)
- [Rule: Naming and Exports Inside Folderized Components [sr-component-folder-exports]](#rule-naming-and-exports-inside-folderized-components)
- [Rule: Promotion and Demotion for Component Helpers [sr-component-helper-promotion]](#rule-promotion-and-demotion-for-component-helpers)
- [Rule: Folderization Must Not Create a New Home [sr-folderization-no-new-home]](#rule-folderization-must-not-create-a-new-home)
- [Rule: Layout and Shell Ownership Decision [sr-layout-shell-placement]](#rule-layout-and-shell-ownership-decision)
- [Rule: Layout and Shell Subfolder Policy [sr-layout-shell-subfolder-policy]](#rule-layout-and-shell-subfolder-policy)
- [Rule: Skill Scope Definition [rru-overview-scope]](#rule-skill-scope-definition-1)
- [Rule: Decision Ladder [rru-process]](#rule-decision-ladder)
- [Rule: Structured Decision Output [rru-output]](#rule-structured-decision-output)
- [Rule: Discovery Coverage and Convention Fit [rru-discovery-conventions]](#rule-discovery-coverage-and-convention-fit)
- [Rule: Deterministic Defaults and Pause Discipline [rru-default-bias]](#rule-deterministic-defaults-and-pause-discipline)
- [Rule: Upstream Decision Alignment [rru-upstream-alignment]](#rule-upstream-decision-alignment)
- [Rule: Outcome Threshold Interpretation [rru-decision-thresholds]](#rule-outcome-threshold-interpretation)
- [Rule: Scope Cap Enforcement [rru-scope-governor]](#rule-scope-cap-enforcement)
- [Rule: Read/Search Access and Fallback Bundle [rru-access-control]](#rule-readsearch-access-and-fallback-bundle)
- [Rule: Fixed Skill Model Compliance [rru-skill-model-alignment]](#rule-fixed-skill-model-compliance)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-reuse-update-new` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-overview-scope
- sr-overview-nongoals
- sr-constraints
- sr-scope-governor
- sr-governance
- sr-architecture-boundaries
- sr-ownership-naming
- sr-decision-defaults
- sr-output-discipline
- sr-dod-baseline
- sr-planning-reuse
- sr-migration-placement
- sr-fallback-defaults
- sr-implementation-defaults
- sr-layer-contracts
- sr-access-write-control
- sr-file-size-guidance
- sr-architecture-detection-contract
- sr-enforcement-heuristics
- sr-micro-change-bypass
- sr-component-folderization
- sr-component-folder-structure
- sr-component-folder-exports
- sr-component-helper-promotion
- sr-folderization-no-new-home
- sr-layout-shell-placement
- sr-layout-shell-subfolder-policy
- rru-overview-scope
- rru-process
- rru-output
- rru-discovery-conventions
- rru-default-bias
- rru-upstream-alignment
- rru-decision-thresholds
- rru-scope-governor
- rru-access-control
- rru-skill-model-alignment

---

# Overview

## Summary

This document defines the authoritative rules for the `react-reuse-update-new` skill.

This skill operates under:
- `react-reuse-update-new` (with mandatory shared baseline policy baked in at build time)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** sr-overview-scope  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared baseline governance and scope constraints explicit.

### Requirement

- The skill must operate only within its defined responsibility.
- The skill must not perform responsibilities assigned to other skills.
- The skill must not reinterpret or override policy without explicit approval.
- The shared baseline must apply uniformly to:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`
- The production execution skill set for this initiative is fixed to those four
  skills; the shared baseline policy is not a production execution skill.
- Shared policy/config updates must not be modeled as new execution skills.
- Document precedence must remain deterministic:
  - `specs/001-agent-policy-v1/master_spec.md` is authoritative.
  - Supporting policy docs may fill non-conflicting open details only.
- The shared baseline must explicitly govern:
  - Architecture/dependency boundaries.
  - Deterministic defaults and pause behavior.
  - Scope-governor limits and expansion protocol.
  - Output consistency for planning and implementation.
  - Ownership/naming conventions and completion checks.

### Forbidden

- Expanding scope beyond the Scope Governor without explicit override.
- Introducing implicit changes to repository structure.
- Creating competing policy sources that conflict with shared baseline precedence.
- Adding new production execution skills without explicit scope/constitution
  update.

---

## Rule: Baseline Non-goals
**Rule ID:** sr-overview-nongoals  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents policy drift into implementation-specific prescriptions.

### Requirement

- Shared policy must define constraints and governance, not implementation
  recipes.
- Shared policy must not implicitly change through examples, migration behavior,
  or downstream reinterpretation.
- Downstream skills may add local guidance only when it does not conflict with
  shared mandatory rules.

### Forbidden

- Treating examples as policy overrides.
- Introducing stack/framework mandates as shared-policy requirements without
  explicit spec approval.

### Notes

- If uncertainty affects governance decisions, pause and request clarification.

---

# Policy Constraints

## Summary
Defines non-negotiable scope and cap controls for downstream skill work.

---

## Rule: Minimal Scope Enforcement
**Rule ID:** sr-constraints  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents uncontrolled scope expansion and dependency creep.

### Requirement

- Changes must stay within the requested feature scope.
- New top-level folders must not be added without explicit approval.
- New dependencies must not be added without explicit approval.
- `pre_approved_collisions` must exist only in shared baseline header and be
  empty unless explicitly approved in a future version.
- When work appears to exceed scope caps, deliver the smallest viable in-cap
  result and provide a structured follow-up scope list.

### Forbidden

- Silent expansion of scope.
- Introducing unapproved dependencies or repositories.
- Defining downstream-local collision registries.
- Mixing structural migration moves with feature behavior work unless explicitly
  requested.

### Notes

- If a requirement cannot be met without expanding scope, pause and request
  approval.

---

## Rule: Scope Governor Hard Defaults
**Rule ID:** sr-scope-governor  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Controls churn and keeps delivery bounded.

### Requirement

- Hard defaults (unless explicitly overridden):
  - Max files touched: `8`
  - Max new files: `4`
  - Max moved/renamed files: `0` (unless migration mode explicitly enabled)
  - Max new dependencies: `0`
  - Max new top-level folders: `0`
- When caps are exceeded, provide a structured scope expansion request with
  concrete `why` and `would_touch` fields, while still delivering an in-cap
  result.

### Forbidden

- Exceeding hard defaults silently.
- Expanding dependency or top-level folder scope without explicit approval.

---

# Governance

## Summary
Sets expectations for compliance, documentation, and review.

---

## Rule: Governance Compliance
**Rule ID:** sr-governance  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures policies are enforced consistently across changes.

### Requirement

- All changes must be validated against the constitution and project specs.
- Documentation updates must keep guidance accurate and current.
- Generated artifacts must be produced by the official build process.
- Shared-policy rule changes must include an explicit policy version increment
  with documented rationale.
- Shared-policy exception approvals must be performed by repo maintainers only.
- Exception records must include rationale and conflicting rule reference.
- Exception records must not include expiry metadata; approved exceptions remain
  active until explicitly revoked or superseded by newer policy version.
- `pre_approved_collisions` must be managed only in the shared baseline header.
- Policy behavior must not be changed implicitly via examples, migration
  behavior, or downstream reinterpretation.

### Forbidden

- Bypassing validation requirements.
- Manual edits to generated artifacts.
- Approving shared-policy exceptions from non-maintainer roles.
- Adding expiry fields to shared-policy exception records.
- Defining downstream-local `pre_approved_collisions` sources.
- Changing shared-policy semantics without a version and rationale update.

### Notes

- If governance rules conflict, the constitution takes precedence.

---

# Architecture Boundaries

## Summary
Defines shared architecture and dependency-boundary rules all downstream skills
must enforce.

---

## Rule: Architecture and Dependency Boundaries
**Rule ID:** sr-architecture-boundaries  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills enforce one consistent
architecture and import-boundary model.

### Requirement

- The following non-negotiables must be enforced:
  - Do not create new folders unless explicitly allowed by policy or user
    instruction.
  - Never place domain business logic in `ui/**` or `api/**`.
  - Never fetch outside the canonical endpoint layer
    (`api/endpoints/**` or gravity-equivalent API home).
  - Prefer small, composable changes over large refactors.
  - Avoid `shared/` or `common/` dumping-ground patterns.
- Dependency direction must remain consistent with the baseline:
  - `ui/**` must not import `features/**`, `api/**`, `store/**`, or `pages/**`.
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`.
  - `features/**` must not import `pages/**`.
  - `pages/**` must not import canonical endpoint modules directly.
  - `hooks/**` must not import `features/**`, `pages/**`, or `store/**`; imports
    from `api/**` are allowed only when documented in exactly one canonical
    policy location.
- The canonical endpoint layer must be determined once per task by Architecture
  Detection and reused consistently in boundary checks for that task.
- If a path alias exists (for example `@/`), all boundary rules apply equally to
  alias imports and raw `src/**` imports.
- Generic fetch-hook exceptions are valid only when documented in exactly one
  canonical policy location; multiple policy locations invalidate the exception.
- No second home may be introduced for the same concern (UI/API/store/routing)
  unless explicit migration scope is approved.

### Forbidden

- Competing homes for the same concern in the same scope.
- Domain terms in reusable `ui/**` component file names.
- DTO-to-domain mapping in `api/**`.

### Notes

- Architecture Detection owns gravity decisions; downstream skills inherit those
  decisions unless a valid pause is triggered.

---

# Ownership and Naming

## Summary
Defines shared ownership boundaries and naming conventions for downstream skill
specifications.

---

## Rule: Ownership and Naming Contract
**Rule ID:** sr-ownership-naming  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps responsibility boundaries and naming deterministic across
all downstream specs.

### Requirement

- `pages/**` remain thin route orchestrators.
- `features/**` own domain behavior, feature hooks, and domain mapping.
- `ui/primitives/**` and `ui/composites/**` stay domain-agnostic.
- `api/**` stays transport-only and returns DTOs or normalized errors.
- `store/**` is global client-state only; do not mirror server-state without
  explicit justification.
- Naming conventions must remain deterministic:
  - `*Page.tsx` for pages.
  - `*Section.tsx` for feature sections.
  - `use*.ts` for hooks.
  - `*.dto.ts` and `*Dto` for DTOs.
- Naming and exports must remain searchable and consistent:
  - Prefer matching file/export names.
  - Prefer named exports unless framework conventions require default exports.
  - Avoid introducing barrel files unless the local area already uses them
    consistently.

### Forbidden

- Domain mode flags in shared composites.
- Introducing new naming schemes when local patterns are clear.
- API transport concerns in UI or generic hook layers.
- Mixed synonym vocabularies for the same role in the same scope (for example
  mixing `Page` and `Route` naming without existing convention).

---

# Decision Defaults and Pause Rules

## Summary
Defines deterministic default behavior and high-impact clarification triggers.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** sr-decision-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Reduces unnecessary clarification loops while protecting
high-impact structural decisions.

### Requirement

- Use deterministic defaults for non-structural ambiguity.
- Pause only when both are true:
  - `confidence < 0.7`
  - `impact = structural`
- Structural impact includes top-level structure changes, competing concern
  homes, dependency-direction changes, cross-layer moves, global state strategy
  changes, or scope-cap violations.
- When pausing, use clean pause protocol:
  - State ambiguity clearly.
  - Present 2-3 options.
  - Recommend a default.
  - Wait for confirmation.
- Use `balanced` pause mode by default unless explicitly configured otherwise.
- Do not pause for minor decisions when a safe default exists.

### Forbidden

- Proceeding on structural ambiguity without pause.
- Repeated low-value questions when a safe deterministic default exists.
- Vague, non-blocking, or style-only clarification questions that do not change
  structural outcomes.

---

# Output and Planning Discipline

## Summary
Defines required output structure for planning and implementation guidance.

---

## Rule: Output and Planning Discipline
**Rule ID:** sr-output-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps downstream planning and implementation outputs consistent,
compact, and reviewable.

### Requirement

- Planning outputs must include:
  - File touch plan (`Create`/`Update`/`Reuse` with paths).
  - Layer justification.
  - Reuse decision notes (`reuse as-is`, `updated`, `new`).
  - A short decision explanation that states detected architecture signals and
    chosen direction.
- Planning outputs must use a machine-readable JSON object with `notes[]`
  limited to 5 items.
- Implementation output must:
  - Use changed snippets for updated files by default.
  - Use unified diff when edits are scattered across non-adjacent regions.
  - Use full content for new files.

### Forbidden

- Full existing-file dumps unless explicitly requested or file is small and
  fully changed.
- Unstructured narrative-only planning outputs.

---

# Completion and Quality Baseline

## Summary
Defines mandatory completion checks and runtime-safety expectations inherited by
all downstream skills.

---

## Rule: Completion and Quality Baseline
**Rule ID:** sr-dod-baseline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures every downstream skill validates critical correctness and
safety gates before completion.

### Requirement

- Boundary audit must pass:
  - No forbidden imports by layer.
  - No fetching outside canonical endpoint layer.
  - `api/**` remains transport-only.
- Runtime safety baseline:
  - Loading state handling when server data is involved.
  - Error state handling.
  - Empty state handling for list/collection views.
  - No unhandled promise rejections.
- Minimal churn baseline:
  - Touch only planned files unless deviations are explained.
  - Avoid unrelated refactors.
- If tooling exists, applicable checks must pass (`tsc`, lint, and existing test
  suites relevant to changed behavior).
- If TanStack Query (or equivalent) is used, query correctness checks must
  ensure stable keys, intended invalidation, and justified server-state/store
  boundaries.
- Tests are required only when a suite already exists and changed behavior falls
  within that suite's scope.

### Forbidden

- Marking work done without boundary/safety checks.
- Treating optional quality checks as mandatory when repository tooling does not
  exist.
- Claiming compliance while skipping available type/lint checks in repositories
  that provide those checks.

---

# Planning and Reuse Workflow

## Summary
Defines required pre-implementation workflow and reuse decision discipline for
selected downstream skills.

---

## Rule: Planning and Reuse Workflow
**Rule ID:** sr-planning-reuse  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents ad hoc implementation choices and improves consistency
across downstream planning outputs.

### Requirement

- Before implementation, downstream skills must:
  - Classify request type (feature, route/page, API integration, refactor, bug
    fix).
  - Choose a domain owner.
  - Map affected layers.
  - Identify expected data sources.
  - Decide server/local/global state ownership.
  - Decide UI reuse shape (reuse/update/new).
  - List planned file touches.
- For `micro_change` runs that satisfy `sr-micro-change-bypass`, the full
  pre-implementation planning sequence may be abbreviated and handled directly
  by Skill 4 micro mode.
- Existing implementations must be searched before creating new modules in:
  - Feature/domain modules.
  - UI primitives/composites.
  - API endpoints/DTOs.
  - State patterns.
- Reuse decisions must follow the ladder:
  - Reuse as-is.
  - Update existing (small, clean extension).
  - Create new (when reuse would leak domain concerns or force excessive
    complexity).
- For shared composites, if reuse requires too many domain-specific options,
  prefer feature-level duplication instead of adding domain mode flags.
- Reuse evaluation should weigh complexity cost, coupling risk, divergence
  probability, and locality benefit.

### Forbidden

- Creating new modules without checking existing alternatives.
- Skipping explicit reuse/update/new decision capture.
- Forcing domain behavior into reusable shared composites.

---

# Migration and Placement Strategy

## Summary
Defines migration-aware placement rules and strategy selection constraints.

---

## Rule: Migration and Placement Strategy
**Rule ID:** sr-migration-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents mixed-architecture drift and keeps placement decisions
deterministic in legacy or evolving repositories.

### Requirement

- Do not introduce parallel architectures for the same concern.
- Choose a strategy per change:
  - Follow existing.
  - Introduce target structure at boundaries.
  - Migrate as you touch (explicit migration scope only).
- Default balanced behavior:
  - No moves/renames unless explicitly enabled.
  - Introduce new homes only when isolated and non-competing.
  - Keep feature behavior and structural migration separate unless explicitly
    requested.
- Gravity decisions from Architecture Detection are inherited by downstream
  skills and must not be recomputed unless pause/escalation resolves a conflict.
- If move mode is explicitly enabled, keep moves small and complete import
  updates in the same change.

### Forbidden

- Two active homes for the same concern in one scope.
- Mixing broad structural migration with unrelated behavior changes.
- Recomputing gravity independently in downstream skills without escalation.

---

# Fallback Technology Defaults

## Summary
Defines shared fallback defaults used only when repository conventions are
missing or ambiguous.

---

## Rule: Fallback Technology Defaults
**Rule ID:** sr-fallback-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic cross-skill defaults while honoring
existing repository gravity first.

### Requirement

- Existing repository stack/conventions take precedence over fallback defaults.
- If no clear convention exists, defaults are:
  - Server-state: TanStack Query; keep transport in `api/endpoints/**`.
  - Client-state: local-first; global store only when truly global.
  - Routing: React Router for plain React; framework-native routing when
    framework is detected.
  - Styling: follow existing; Tailwind default only for greenfield.
  - Forms: react-hook-form.
  - Validation: Zod at boundaries (DTO/form), with domain schema ownership in
    feature domain layers.
  - HTTP client: native `fetch` via shared wrapper; normalized `ApiError`;
    conservative retry posture.
  - Build tool: Vite for greenfield plain React unless existing conventions say
    otherwise.
  - Date/localization: native `Date` and `Intl` unless domain needs justify
    more.
  - Identifier strategy: string IDs by default.

### Forbidden

- Introducing competing stack choices mid-repository without explicit request.
- Mirroring server-state into global store without explicit justification.

---

# Implementation Defaults

## Summary
Defines shared implementation posture defaults inherited by downstream skills.

---

## Rule: Implementation Defaults
**Rule ID:** sr-implementation-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Aligns downstream implementation behavior on quality, environment
access, logging, and tooling posture.

### Requirement

- Feature flags must be centralized in `config/featureFlags.ts` and evaluated at
  composition boundaries.
- Reusable UI components should support class extension patterns consistently
  (for example `className` with shared merge helper where applicable).
- Accessibility baseline is required for reusable UI.
- Performance posture is readability-first; memoization optimizations require
  concrete justification.
- Repository topology must be detected (single-app vs monorepo) and rules
  applied per app root when monorepo signals exist.
- Module-boundary tooling posture is spec-first:
  - Start with import-boundary review checks.
  - Add lint/tool enforcement only when explicitly requested as dedicated
    hardening scope.
  - Mirror alias paths in boundary lint rules when aliases are present.
- Environment access must be centralized through `config/env.ts`.
- Logging should use shared logger abstractions; avoid committed debug logging.
- Codegen is opt-in only; default to handwritten endpoint/DTO ownership.
- Storybook/docs are optional and should follow existing setup when present.

### Forbidden

- Direct environment reads outside `config/env.ts`.
- Committing `console.log`/`console.debug` in production code paths.
- Introducing codegen or docs platforms as implicit scope expansion.
- Adding boundary/tooling stacks implicitly in routine feature scope.

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# Access and Write Control

## Summary
Defines shared access assumptions and write-control behavior for downstream
skills.

---

## Rule: Access and Write Control
**Rule ID:** sr-access-write-control  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps structural decisions grounded in repository signals and
maintains controlled, reviewable changes.

### Requirement

- Detection/reuse/planning stages require repository read/search access.
- Minimum capabilities include:
  - Listing relevant file trees.
  - Searching code patterns.
  - Reading source/config files on demand.
- If direct access is unavailable, require a fallback context bundle with file
  tree, package/tooling config, router entry, API home, and representative
  module examples.
- Default write posture must be controlled and reviewable.
- If direct writes are enabled, scope-governor and minimal-churn rules still
  apply.
- Architecture/specification document edits require explicit request and must be
  treated as dedicated documentation scope.

### Forbidden

- Structural placement decisions without repository signal checks.
- Silent broad writes that bypass scope and review controls.
- Auto-editing architecture/spec documents during regular implementation work.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Architecture Detection Contract

## Summary
Defines the shared contract that downstream skills must inherit from
architecture-detection outputs, including bootstrap behavior.

---

## Rule: Architecture Detection Output and Bootstrap Contract
**Rule ID:** sr-architecture-detection-contract  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills consume one consistent
architecture-detection result and bootstrap behavior.

### Requirement

- Architecture detection output must include the shared structural signals:
  - `routing.type`
  - `ui.home`
  - `api.home` (canonical endpoint layer for boundary checks)
  - `domain.organization`
  - `gravity_map`
  - `alignment_score`
  - `strategy`
  - `notes[]`
- Gravity decisions are owned by architecture detection and reused by all
  downstream skills within the same task.
- Downstream skills must not recompute/override gravity unless a structural
  pause is triggered and explicitly resolved.
- Bootstrap behavior applies only when no clear concern homes exist:
  - Allow folder creation only from the canonical set:
    `pages/`, `features/`, `ui/primitives/`, `ui/composites/`, `api/client/`,
    `api/dto/`, `api/endpoints/`, `core/`, `lib/`, `hooks/`, `config/`
  - `store/` may be created only when truly global client-state is required.
  - Prefer minimal bootstrap: create only folders needed for the current task.

### Forbidden

- Consuming inconsistent architecture-detection outputs across downstream skills
  for the same task.
- Creating speculative bootstrap folders not needed by the current task.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# Micro-change Bypass

## Summary
Defines deterministic conditions for bypassing Skills 1-3 and invoking
implementation discipline directly in micro mode.

---

## Rule: Micro-change Bypass and Skill 4 Micro Mode
**Rule ID:** sr-micro-change-bypass  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Allows low-risk behavior-preserving refactors to stay fast while
still enforcing implementation discipline and boundary checks.

### Requirement

- A request may be classified as `micro_change` only when all are true:
  - behavior-preserving refactor intent is explicit.
  - expected touched files are `<= 2`.
  - no new files are required.
  - no move/rename operations are required.
  - no new endpoint/hook/composite homes are introduced.
  - no routing changes are required.
- If `micro_change` is confirmed:
  - Skills 1-3 may be bypassed.
  - Skill 4 may be used directly in `micro mode`.
  - As an alternative, an external checklist-only path may be used when Skill 4
    is not selected.
- Skill 4 `micro mode` must still enforce:
  - boundary audits
  - minimal churn
  - validation/quality checks and explicit check results
  - structured output discipline
- If any `micro_change` condition cannot be confirmed, use the normal staged
  pipeline instead of bypass.

### Forbidden

- Using micro-change bypass for feature additions or structural migrations.
- Skipping boundary/quality validation because the change is small.
- Treating uncertain scope as micro-change without explicit evidence.

---

# Component Folderization

## Summary
Defines when components should remain single-file versus folderized, and how
folderized component modules must be structured and named.

---

## Rule: Component Folderization Threshold
**Rule ID:** sr-component-folderization  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps components maintainable without creating mini-apps inside
`ui/**` or `features/**`.

### Requirement

- Keep a component as a single file when all are true:
  - file is about `<= 200` lines and has one clear responsibility
  - helpers are small and render-support only
  - there are at most two closely related internal subcomponents
- Folderize (move to a component module folder) when any is true:
  1. file is about `> 250-300` lines and splitting reduces responsibilities
  2. component contains three or more meaningful internal subcomponents
  3. non-trivial local logic should be isolated (mapping/formatting, keyboard
     handling, complex derived state)
  4. it has component-scoped assets (styles/icons/constants)
  5. it is reused broadly and needs a stable module boundary
- Hard rule:
  - if a single component file exceeds `400` lines, folderization is required
    unless explicitly justified in output notes and/or review metadata.
- This rule applies across skills and is enforced most strongly in
  `react-implementation-discipline` during execution output validation.

### Forbidden

- Keeping oversized multi-responsibility component files as single files without
  explicit justification.
- Treating folderization as optional when the hard threshold is crossed.

### Notes

- Quick folderization heuristic: folderize when any is true:
  - file has two or more responsibilities
  - splitting subcomponents would improve clarity
  - helper pile is component-local only
  - file is above about `300` lines and still growing

---

## Rule: Folder Structure for a Folderized Component
**Rule ID:** sr-component-folder-structure  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents random folder soup and keeps discovery/search
predictable.

### Requirement

- Default required structure for folderized component `ProjectSelector`:

```text
ProjectSelector/
  ProjectSelector.tsx
  index.ts            (optional; only when local area already uses barrels)
```

- Allowed colocated files must be component-scoped only:
  - `ProjectSelector.utils.ts` (component-local pure helpers)
  - `ProjectSelector.types.ts` (component-local types)
  - `ProjectSelector.constants.ts` (component-local constants)
  - `ProjectSelector.styles.module.css` (or local styling per repo convention)
  - `ProjectSelector.test.tsx` (component tests)
- `components/` subfolder is allowed only when module size/complexity justifies
  it and subcomponents remain component-local.

### Forbidden

- Adding transport/backend access layers (`api/`) inside a component folder.
- Adding cross-domain generic utility buckets (for example `utils/` junk drawer
  subfolders).
- Placing shared primitives inside component-owned folders (shared primitives
  belong in `ui/primitives/**`).

---

## Rule: Naming and Exports Inside Folderized Components
**Rule ID:** sr-component-folder-exports  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps imports stable and grep-friendly.

### Requirement

- Main component file must match folder name and primary export:
  - `ProjectSelector/ProjectSelector.tsx` exports `ProjectSelector`.
- Import style:
  - prefer explicit import path to main file, or
  - folder import only when `index.ts` exists and local area already uses
    barrels.
- Subcomponents should carry module prefix (for example
  `ProjectSelectorItem`, `ProjectSelectorDropdown`) for searchability.

### Forbidden

- Random unprefixed subcomponent names like `Item.tsx` and `Dropdown.tsx`.
- Introducing new barrel patterns in areas that do not already use them.

---

## Rule: Promotion and Demotion for Component Helpers
**Rule ID:** sr-component-helper-promotion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents leaking component-specific helpers into global utility
layers.

### Requirement

- Move helper from component folder to `lib/**` only when both are true:
  - helper is reused by two or more domains/features
  - helper is pure (no React imports and no feature/domain knowledge)
- Move helper to `features/<domain>/domain/**` when helper encodes domain
  behavior, even if used across multiple files within that feature.
- Keep component-local helpers colocated when reuse and purity thresholds for
  promotion are not met.

### Forbidden

- Promoting helpers to `lib/**` solely because the source component file is
  large.
- Promoting domain-aware helpers to `lib/**`.

---

## Rule: Folderization Must Not Create a New Home
**Rule ID:** sr-folderization-no-new-home  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents second-architecture drift.

### Requirement

- Folderization must stay inside existing gravity home:
  - if component is under `src/components/**`, folderized module stays there
  - if component is feature-owned, folderized module stays in that feature path
- Folderization must preserve current concern ownership and import-boundary
  rules.
- Relocation across homes during folderization is allowed only in explicit
  migration mode with clear boundary scope.

### Forbidden

- Using folderization as justification to create a new top-level `ui/`,
  `shared/`, or other competing concern home.
- Silent home relocation under the guise of formatting/refactor-only work.

---

# Layout and Shell Placement

## Summary
Defines deterministic placement for layout/shell components and prevents
parallel layout homes.

---

## Rule: Layout and Shell Ownership Decision
**Rule ID:** sr-layout-shell-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Removes ambiguity between `ui/primitives`, `ui/composites`, and
`features/<domain>/sections` for layout-like components.

### Requirement

- Place in `ui/primitives/**` only when the component is a low-level building
  block with minimal structure/behavior.
  - Typical primitives: `Stack`, `Box`, `Spacer`, `Grid`, thin `Container`.
- Place in `ui/composites/**` when the component composes multiple primitives
  into a reusable UI pattern.
  - Typical composites: `PageShell`, `ModalShell`, `PanelShell`,
    `MasterDetailLayout`, `AppShell`, `SidebarLayout`, `CardLayout`,
    `TableShell`, `EmptyStatePanel`.
- Place in `features/<domain>/sections/**` when the layout is domain-owned
  composition, even if it looks like a generic layout.
  - Example: project-specific layout section with domain navigation, filters,
    or domain-state behavior.
- Fast decision rule:
  - minimal low-level building block -> primitive
  - reusable composed pattern -> composite
  - domain-owned composition/behavior -> feature section
- This rule applies to all skills and must be enforced most strongly during
  execution in `react-implementation-discipline`.

### Forbidden

- Treating reusable shells/layout patterns as primitives.
- Treating domain-owned layout composition as shared composite by default.
- Using unclear "looks like layout" labeling to bypass domain ownership checks.

### Notes

- If ownership is ambiguous and impact is structural, use shared pause protocol
  thresholds.

---

## Rule: Layout and Shell Subfolder Policy
**Rule ID:** sr-layout-shell-subfolder-policy  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents creation of competing layout homes while allowing
bounded categorization inside composites when needed.

### Requirement

- Default policy: do not create dedicated top-level layout homes for
  `layouts/` or `shells/`.
- If categorization is needed, keep it inside existing composite home:
  - `src/ui/composites/layouts/*`
  - `src/ui/composites/shells/*`
- Allow this subfolder split only when all are true:
  - composite catalog is large/noisy (for example around ten or more layout/shell
    components)
  - repository already uses category subfolders inside `ui/**`
  - split does not create a competing second home
- Folderization/categorization must preserve existing gravity home and
  one-home-per-concern discipline.

### Forbidden

- Creating a parallel top-level home like `src/ui/layouts/*` or
  `src/ui/shells/*` by default.
- Using category split to bypass migration-scope rules.
- Introducing both `ui/composites/*` and new top-level `ui/layouts/*` as active
  homes for the same concern.

---

# Overview

## Summary

This document defines the authoritative rules for the `react-reuse-update-new`
skill.

This skill operates under:
- `shared-rules` (mandatory baseline policy)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rru-overview-scope  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Ensures reuse decisions stay within defined responsibilities.

### Requirement

- The skill must evaluate reuse vs update vs new for each needed artifact in
  scope.
- The skill applies to decision-only refactor planning, including tiny shared
  helper extraction, and remains planning-only (no implementation output).
- The skill must preserve deterministic behavior for thresholding, tie-breaks,
  and output states.
- The skill must avoid over-generalization of components and prefer minimal
  churn with clear ownership.
- The skill must emit planning guidance only and must not directly implement,
  move, or refactor project code.
- The skill must inherit and enforce shared baseline constraints from
  `shared-rules`.

### Forbidden

- Introducing large refactors unrelated to the request.
- Forcing reuse through leaky domain flags in shared abstractions.
- Returning partial decision payloads when required inputs are invalid or
  discovery evidence is unavailable.
- Defining local mandatory rules that conflict with `shared-rules`.

### Notes

- Use the decision ladder and deterministic defaults to guide outcomes.

---

# Reuse Decision Process

## Summary
Defines deterministic evaluation for reuse, update, or new creation.

---

## Rule: Decision Ladder
**Rule ID:** rru-process  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Keeps decisions consistent and bounded.

### Requirement

- Search for existing implementations before proposing new artifacts, using this
  lookup order for each needed artifact:
  1. Exact or near-name match
  2. Pattern/behavior match
  3. Primitive building-block match
  4. Endpoint/DTO/hook match
- For each lookup tier, record repository evidence as concrete paths or explicit
  `not_found`.
- For DRY logic extraction/refactor work across two or more call sites, a
  low-overhead discovery mode is allowed before full scoring:
  - run a quick repo search for existing helpers/patterns (for example
    `isRecord`, `getStringField`, and equivalent typed field-parsing helpers)
  - if a suitable helper exists, prefer `reuse` or small `update`
  - if no suitable helper is found, `new` is allowed with minimal scope
    and feature-appropriate ownership
- Discovery coverage must include:
  - Existing domain modules (`sections/`, `hooks/`, `domain/`) in the owning
    feature area before proposing new modules.
  - Existing UI primitives and composites before proposing new UI artifacts.
  - Existing API client/endpoints/DTO patterns before proposing new data-access
    modules.
  - Existing state conventions for server-state, local state, and global store.
  - Existing naming/export conventions so new decisions do not introduce a new
    style in an established area.
- Evaluate each candidate with scored signals:
  - Required scores: `fit`, `complexity_cost`, `coupling_risk`,
    `divergence_risk`, and `locality_benefit` (0-10 scale)
  - Use score normalization anchors:
    - `coupling_risk=0`: no new imports and no new cross-domain references
    - `coupling_risk=5`: new imports within the same feature boundary
    - `coupling_risk=10`: cross-domain import or new global dependency
    - `divergence_risk=0`: behavior is effectively identical
    - `divergence_risk=5`: behavior is similar but likely to evolve separately
    - `divergence_risk=10`: behavior is expected to diverge significantly over time
    - `locality_benefit=0`: change pulls ownership away from the feature/domain home
    - `locality_benefit=5`: neutral ownership/locality impact
    - `locality_benefit=10`: change keeps ownership close to the feature/domain home
- Apply the reuse ladder in strict order:
  1. Reuse as-is
  2. Update existing
  3. Create new
- Reuse as-is is preferred only when behavior fits with minimal glue, no mode
  flags, and no domain leakage.
- Apply safe-update defaults unless explicit overrides are provided:
  - `max_new_props_for_update=2`
  - `max_flags_allowed_composites=0` for domain mode flags
  - `max_generic_flags_allowed_primitives=1`
  - `max_abstraction_risk_score=6`
- Allow `update` only when changes remain small, abstraction quality improves,
  and existing callers remain compatible (or are straightforward to update).
- When candidate scores tie, resolve in deterministic order:
  1. Candidate in authoritative upstream home
  2. Lower coupling risk
  3. Lower divergence risk
  4. Lower complexity cost
  5. Lexical path order
- Document why reuse/update/new was selected for each needed artifact.
- Apply layer-specific reuse guidance:
  - UI primitives: reuse by default; if missing, create a primitive; if close,
    prefer small generic updates over domain-specific copies.
  - UI composites: reuse only for true UI patterns; generalize via
    slots/children/render props; do not add domain mode flags; if UI shape is
    shared but meaning differs by domain, inject content instead of encoding
    business meaning in the shared composite.
  - Feature sections: cross-domain section reuse defaults to duplication;
    same-domain section reuse is allowed.
  - Feature domain: prefer reuse within the feature domain; move logic to
    cross-domain `lib/` only when it is stable and truly shared.
  - API endpoints/DTOs: endpoint ownership and DTO contracts are reusable, but
    DTO-to-domain mapping remains feature-local unless it is stable cross-domain;
    endpoint modules should remain DTO-returning boundaries.
  - Store: use global store only for global client state and avoid duplicating
    server-state there.
- Creating new modules is preferred when existing code is too opinionated,
  update would require leaky flags/branches, or divergence is likely; duplicate
  feature sections when needed, but treat primitive/composite duplication as a
  design smell versus extending shared building blocks.
- Apply deterministic shortcut bias:
  - Low complexity + low coupling -> prefer reuse or small update.
  - High flag cost + high divergence -> prefer a new feature section while
    reusing shared primitives/composites where safe.
- Enforce anti-leakage guardrails:
  - Shared composites must not receive domain-specific mode flags.
  - Shared abstractions must not encode domain-specific naming.
  - Do not expand shared API client surface area casually; allow expansion only
    when endpoint behavior is stable and truly cross-domain.
  - If divergence risk is high, prefer domain-owned sections over forced
    cross-domain generalization.
- If explicit constraints block all safe options for an artifact, emit
  `decision_blocked` and require explicit override before accepting
  non-compliant paths.
- Pause only when reuse intent is unclear and structural cost is meaningful
  (for example: large composite expansion, unclear intentional divergence, or
  likely long-lived UX split). Otherwise proceed with deterministic defaults.
- If abstraction cost is clearly high, default to a feature-local
  section/module instead of forcing shared generalization.
- Do not pause for minor decisions when a safe default exists
  (for example: small harmless prop additions).
- Pause mode defaults are inherited from shared policy:
  - default `pause_mode` is `balanced`
  - use `strict` or `autonomous` only when explicitly configured by policy
    override
- Require upstream minimum decision context before finalizing outcomes:
  - feature owner/domain
  - route/page involvement
  - current data sources
  - intended state type
  - UI needs (primitive/composite/section shape)
- Validate required inputs before discovery and decisioning.
- If required inputs are missing or invalid, emit `validation_error` and stop.
- If repository discovery/search evidence is unavailable or incomplete, emit
  `dependency_error` and stop.
- Preserve `needed_artifact_id` identity from input through final output.
- Treat refactor sessions as valid decision-plan runs; this skill remains
  decision-only even when the outcome is a tiny shared helper addition.

### Forbidden

- Skipping discovery of existing code.
- Returning `new` without repository evidence or explicit `not_found` outcome.
- Returning ambiguous outcomes with no single final decision per artifact.
- Allowing domain leakage to justify reuse/update in shared abstractions.
- Continuing decisioning after required validation or discovery failures.

### Notes

- Favor reuse when behavior matches without threshold violations.

---

# Output Contract

## Summary
Defines the expected deterministic output structure for reuse decisions.

---

## Rule: Structured Decision Output
**Rule ID:** rru-output  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Ensures decisions are actionable and traceable.

### Requirement

- Output must be one JSON object with `schema_version`, `skill`, `version`,
  `result_type`, and `validation_status`.
- `result_type=decision_plan` outputs must include:
  - `thresholds_applied`
  - `revised_plan.source_plan_ref`
  - `revised_plan.context_decisions`
  - `revised_plan.file_actions[]`
  - `revised_plan.layer_justifications[]`
  - per-artifact `decisions[]` entries
- Each decision entry must include:
  - `needed_artifact_id`
  - `decision` (`reuse|update|new|decision_blocked`)
  - `decision_mark` (`reuse as-is|updated|new|decision_blocked`)
  - `discovery_status` (`found|not_found`)
  - concise `reasons[]`
  - `override_required`
- If `discovery_status=found`, output must include concrete `discovery_paths[]`.
- If `decision` is `reuse`, `update`, or `new`, `target_path` must be present.
- If `decision` is `reuse` or `update`, `discovery_status` must be `found`.
- If score details are included, they must use `fit`, `complexity_cost`,
  `coupling_risk`, `divergence_risk`, and `locality_benefit`.
- `reuse`, `update`, and `new` decisions must include `score_profile`.
- If tie-break logic is applied, output must include `tie_break` metadata with
  ordered criteria and selected candidate information.
- Output must include explicit guardrails describing anti-leakage constraints.
- `revised_plan.guardrails[]` must also include concise constraints against:
  - new shared/common dumping-ground abstractions
  - endpoint bypass patterns in hooks/UI layers
  - casual shared API client surface expansion when endpoint behavior is not
    stable and cross-domain
  - inline utility placement in pages/sections when the utility belongs in
    domain/lib boundaries
  - mega component expansion through excessive mode/flag props
  - forcing multi-mode shared composites when section-level duplication is safer
  - "refactor for future" scope creep without immediate value
  - mixed migration + feature-behavior churn in one decision package unless explicitly requested
- `revised_plan.file_actions[]` must map each planned touch to `create`,
  `update`, or `reuse` and include `needed_artifact_id`, `layer`, and concrete
  `path`.
- `revised_plan.file_actions[]` and `revised_plan.decisions[]` must match
  one-to-one by `needed_artifact_id` (no missing or extra ids in either list).
- `revised_plan.file_actions[]` must preserve `placement_plan` layer/path
  decisions by default.
- If a file action intentionally deviates from upstream `placement_plan`
  layer/path, output must include `revised_plan.placement_overrides[]` with:
  - `needed_artifact_id`
  - `upstream_path`
  - `upstream_layer`
  - `revised_path`
  - `revised_layer`
  - `resolution_mode` (`pause_resolved`)
  - `resolution_reason`
- If any move/rename is planned, output must include `revised_plan.move_actions[]`
  entries with `from_path`, `to_path`, and `import_update_targets[]`.
- `revised_plan.move_actions[]` must contain at most 3 entries unless
  `revised_plan.migration_scope_enabled=true`.
- `revised_plan.layer_justifications[]` must provide concise layer rationale and
  why adjacent layers were not chosen (1-2 sentences per touched layer).
- `decision_blocked` entries must include:
  - `constraint_blockers[]`
  - `override_required=true`
  - concise rationale describing why all safe paths were blocked
- `result_type=validation_error` outputs must include:
  - `validation_status.is_valid=false`
  - `notes[]` (max 5)
  - no decision payload
- `result_type=dependency_error` outputs must include:
  - `validation_status.is_valid=false`
  - `dependency_issue`
  - `fallback_context_bundle_requirements[]`
  - `notes[]` (max 5)
  - no decision payload
- `decision_plan` outputs must include concise `revised_plan.notes[]` (max 5)
  containing only high-leverage tradeoffs, uncertainties, constraints, or risks.
- `thresholds_applied` must always include:
  - `max_new_props_for_update`
  - `max_flags_allowed_composites`
  - `max_generic_flags_allowed_primitives`
  - `max_abstraction_risk_score`
- If scope caps would be exceeded for materially improved completeness, output
  may include `scope_expansion_needed[]` with bounded `why` and `would_touch`
  entries while still providing an in-cap minimal decision package.
- When `scope_expansion_needed[]` is present, include
  `revised_plan.follow_up_scope[]` as a short, concrete post-approval scope
  list.
- `needed_artifact_id` values must remain stable from request artifacts to
  final decision records.
- `needed_artifact_id` values must be unique within one `decision_plan` output.

### Forbidden

- Output that hides decision rationale.
- Ambiguous decisions without a single final action per artifact.
- Extra prose outside JSON output.
- `decision_blocked` outputs without actionable blocker context.

### Notes

- Keep reasoning concise and focused on material tradeoffs.

---

# Discovery and Convention Audit

## Summary
Defines the mandatory repository discovery and convention checks that must be
completed before final reuse/update/new decisions.

---

## Rule: Discovery Coverage and Convention Fit
**Rule ID:** rru-discovery-conventions  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Prevents duplicate artifacts and style drift by forcing
evidence-based discovery in the active repository.

### Requirement

- Discovery must examine existing homes before proposing new artifacts:
  - check whether `features/<domain>/` already exists before proposing a new
    domain module home
  - domain modules (`features/<domain>/sections`, `hooks`, `domain`)
  - UI primitives and composites
  - API client, endpoints, and DTO modules, following existing `api/client`
    usage patterns
  - state conventions (server-state, local-state, global store), including
    server-state cache wiring patterns (for example QueryClient usage in core
    wiring) when present
- Discovery must verify established naming/export conventions in the active area
  before proposing new paths, including:
  - one concept per role (avoid mixed `Page`/`Route`/`Screen` synonyms in one
    area)
  - deterministic role naming (`*Page`, `*Section`, `use*`, `*Dto`)
  - deterministic API placement naming (`api/endpoints/*` for endpoint modules)
  - file-name and primary-export alignment for searchable names
  - established error-handling style and DTO/domain typing style consistency
  - component naming (`PascalCase` file + export) and hook naming (`useXxx`
    camelCase file + export)
  - avoiding dotted suffix patterns (for example `.page.tsx` / `.route.tsx`)
    unless existing local conventions require them
  - stable export style consistency (prefer named exports; allow default exports
    only where framework conventions or established local area conventions
    require them)
  - avoidance of introducing barrels where area conventions do not use them
  - explicit-import consistency where local area conventions already use it, and
    no mixed barrel/deep-path imports in the same area
  - colocated test naming compatibility (`*.test.tsx` / `*.test.ts`) and
    colocated placement when tests already exist in the target area
- If naming is unclear, file names must still encode module role clearly (for
  example: page/section/hook/dto identity).
- If conventions are ambiguous, choose nearest-neighbor conventions and keep
  names searchable (file name and primary export aligned).
- Each decision must remain traceable to concrete discovery evidence or explicit
  `not_found`.

### Forbidden

- Proposing new modules before checking existing domain and shared homes.
- Inventing a new naming/export style in an established area.
- Treating naming uncertainty as justification for structural churn.

### Notes

- Convention checks are a discovery responsibility, not an implementation
  formatting concern.

---

# Deterministic Default Bias

## Summary
Defines mandatory default actions and pause behavior to keep reuse decisions
deterministic and low-friction.

---

## Rule: Deterministic Defaults and Pause Discipline
**Rule ID:** rru-default-bias  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Reduces over-asking and ensures predictable outcomes when
ambiguity exists but safe defaults are available.

### Requirement

- Apply these deterministic defaults unless structural risk requires a pause:
  - ambiguous feature owner -> choose the most specific domain
  - UI pattern unclear -> keep logic in the feature section
  - reuse vs generalize unclear -> duplicate section-level implementation
  - multiple state options -> prefer local state first
  - unsure store usage -> avoid introducing global store state
  - unsure abstraction -> keep implementation concrete
  - API placement unclear -> use the existing API home
  - folder placement unclear -> follow upstream gravity and nearest established
    home from placement outputs
  - naming unclear -> match nearest-neighbor naming
- Pause only when at least one condition is true:
  - safe progress is impossible without clarification
  - multiple structural paths are equally valid
  - wrong default choice likely creates long-term structural debt
- When pausing, use clean protocol:
  1. state the ambiguity
  2. offer 2-3 concrete options
  3. provide recommended default
  4. wait for confirmation

### Forbidden

- Pausing for minor naming or harmless small-prop decisions.
- Overriding deterministic defaults without explicit structural risk.
- Proceeding with conflicting structural assumptions after deciding to pause.

### Notes

- Default behavior should maximize forward progress and minimize architectural
  churn.

---

# Upstream Alignment and Migration Safety

## Summary
Defines how reuse decisions must honor upstream architecture/placement outputs
and avoid introducing parallel architecture paths.

---

## Rule: Upstream Decision Alignment
**Rule ID:** rru-upstream-alignment  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Keeps reuse decisions coherent with prior skills and prevents
conflicting structural guidance.

### Requirement

- Treat upstream `detection_result` and `placement_plan` as authoritative for:
  - feature/domain ownership
  - layer placement intent
  - endpoint home conventions and data-boundary expectations
- Reuse decisions must refine upstream plans, not recompute or override
  architecture/gravity outcomes within the same task.
- `revised_plan.file_actions[]` must preserve upstream `placement_plan`
  layer/path decisions unless an explicit pause-resolved override is recorded in
  `revised_plan.placement_overrides[]`.
- Preserve migration safety:
  - do not create parallel mixed architecture in one decision package
  - avoid half-old/half-new placement without explicit migration boundary
  - keep feature behavior decisions and broad structural migration separated
    unless explicitly requested
- Default move/rename behavior is no moves in feature-scope plans; only include
  move actions when migration scope is explicit and import updates are complete.

### Forbidden

- Overriding upstream feature ownership or layer placement decisions without an
  explicit pause/override path.
- Changing file-action layer/path relative to upstream placement without a
  matching pause-resolved override record.
- Returning decision guidance that conflicts with established endpoint/layer
  homes in the same task.
- Bundling migration-scale restructuring into routine feature reuse decisions.

### Notes

- This rule constrains refinement scope, not implementation details.

---

# Decision Outcome Thresholds

## Summary
Defines deterministic decision outcome thresholds and scoring interpretation for
reuse/update/new selection.

---

## Rule: Outcome Threshold Interpretation
**Rule ID:** rru-decision-thresholds  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Converts scoring into predictable decisions and prevents
reviewer-dependent outcomes.

### Requirement

- Use score interpretation guidance for fit:
  - `10`: identical behavior
  - `7-9`: minor wiring/extension
  - `4-6`: significant differences
  - `0-3`: wrong abstraction
- Use score normalization anchors for coupling/divergence/locality:
  - `coupling_risk=0`: no new imports and no cross-domain references
  - `coupling_risk=5`: new imports within the same feature boundary
  - `coupling_risk=10`: cross-domain import or new global dependency
  - `divergence_risk=0`: behavior is effectively identical
  - `divergence_risk=5`: behavior is similar but likely to evolve separately
  - `divergence_risk=10`: behavior is expected to diverge significantly over time
  - `locality_benefit=0`: ownership is pulled away from the feature/domain home
  - `locality_benefit=5`: neutral ownership/locality impact
  - `locality_benefit=10`: ownership remains close to the feature/domain home
- Apply these default threshold values unless explicit overrides are supplied:
  - `max_new_props_for_update=2`
  - `max_flags_allowed_composites=0` (domain modes)
  - `max_generic_flags_allowed_primitives=1`
  - `max_abstraction_risk_score=6`
- Reuse is preferred when:
  - `fit >= 8`
  - `complexity_cost <= 3`
  - `coupling_risk <= 3`
  - `divergence_risk <= 4`
- Update is preferred when:
  - `fit >= 6`
  - change remains a small extension under update thresholds
  - coupling remains low
  - no domain mode flags are introduced in shared composites
- New is preferred when one or more are true:
  - fit is too low for safe reuse/update
  - update would require multiple flags/options that violate thresholds
  - divergence risk is high
  - coupling/domain leakage risk is high

### Forbidden

- Selecting `reuse` or `update` outcomes that violate threshold limits without
  explicit override handling.
- Treating high-divergence/high-coupling outcomes as reusable shared abstractions.
- Omitting applied threshold values from decision output.

### Notes

- Thresholds reduce ambiguity; they do not replace architectural judgment.

---

# Scope Governor Alignment

## Summary
Defines how reuse planning must honor hard scope caps and request explicit
approval when expanded scope is materially beneficial.

---

## Rule: Scope Cap Enforcement
**Rule ID:** rru-scope-governor  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Prevents refactor creep and keeps decision packages reviewable.

### Requirement

- Reuse planning must honor baseline hard defaults inherited from shared policy:
  - max files touched: `8`
  - max new files: `4`
  - max moved/renamed files: `0` unless migration mode is explicit
  - max new dependencies: `0` unless explicitly requested
  - max new top-level folders: `0` unless explicitly requested
- If a materially better plan exceeds caps, emit `scope_expansion_needed[]`
  entries with:
  - `why` (concrete reason)
  - `would_touch` (estimated additional files)
- Even when expansion is requested, output must still provide the in-cap
  minimal decision package.
- When caps are exceeded, include a short follow-up scope list describing what
  additional scope would be done after approval.

### Forbidden

- Expanding decision scope beyond hard defaults without explicit expansion
  signaling.
- Treating speculative refactors as valid cap-expansion justification.
- Emitting expansion requests without a bounded file-touch estimate.

### Notes

- Scope expansion is an explicit approval path, not an implicit default.

---

# Access Control and Fallback Context

## Summary
Defines repository access requirements for reuse planning and the mandatory
fallback context bundle when direct repository access is unavailable.

---

## Rule: Read/Search Access and Fallback Bundle
**Rule ID:** rru-access-control  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Reuse decisions require repository evidence; fallback inputs must
be explicit when direct access is unavailable.

### Requirement

- Reuse planning should run with repository read/search access.
- Minimum read/search capabilities expected for decision-quality execution:
  - list `src/` tree shape
  - search code patterns (for example API/query/router identifiers)
  - read file contents on demand
  - read key tooling/config files relevant to architecture signals
- If direct repository access is unavailable, emit `dependency_error` and
  include a fallback context bundle requirement checklist covering:
  - file tree (top-level + `src/` depth ~3-4)
  - `package.json`
  - router entry/config files
  - API client location currently in use
  - representative examples (primitive, composite, section, hook, endpoint)
- Default write mode for this skill remains controlled planning output; direct
  code edits are out of scope for this skill unless explicitly enabled by
  upstream workflow.

### Forbidden

- Producing structural reuse decisions without repository evidence or fallback
  context inputs.
- Assuming architecture signals when both direct access and fallback context are
  missing.
- Treating direct implementation edits as part of this skill's normal output.

### Notes

- This skill is decision-planning only; implementation belongs to downstream
  execution skills.

---

# Skill Model Alignment

## Summary
Defines alignment with the fixed execution skill model and shared policy layer.

---

## Rule: Fixed Skill Model Compliance
**Rule ID:** rru-skill-model-alignment  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Prevents scope drift and keeps responsibilities aligned across
the four execution skills.

### Requirement

- Treat this skill as one of the fixed execution skills in the current model.
- Primary output remains a refined implementation plan with per-artifact
  reuse/update/new decisions.
- Shared policy/config remains a separate layer and must not be re-modeled as a
  new execution skill by this rule set.
- This skill may refine decisions but must not absorb responsibilities owned by
  architecture detection, placement/layering, or implementation discipline.

### Forbidden

- Reframing policy-layer concerns as new execution-skill behavior in this skill.
- Expanding this skill to replace other execution skills in the fixed model.

### Notes

- Cross-skill coordination is mandatory; ownership boundaries remain explicit.
