<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-24
-->

# React Reuse vs Update vs New â€” Agent Rules

## Table of contents
- [Summary](#summary)
- [Rule: Skill Scope Definition](#rule-skill-scope-definition)
- [Summary](#summary)
- [Rule: Decision Ladder](#rule-decision-ladder)
- [Summary](#summary)
- [Rule: Structured Decision Output](#rule-structured-decision-output)
- [Summary](#summary)
- [Rule: Discovery Coverage and Convention Fit](#rule-discovery-coverage-and-convention-fit)
- [Summary](#summary)
- [Rule: Deterministic Defaults and Pause Discipline](#rule-deterministic-defaults-and-pause-discipline)
- [Summary](#summary)
- [Rule: Upstream Decision Alignment](#rule-upstream-decision-alignment)
- [Summary](#summary)
- [Rule: Outcome Threshold Interpretation](#rule-outcome-threshold-interpretation)
- [Summary](#summary)
- [Rule: Scope Cap Enforcement](#rule-scope-cap-enforcement)
- [Summary](#summary)
- [Rule: Read/Search Access and Fallback Bundle](#rule-readsearch-access-and-fallback-bundle)
- [Summary](#summary)
- [Rule: Fixed Skill Model Compliance](#rule-fixed-skill-model-compliance)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-reuse-update-new` skill.

Key constraints:
- Follow `agent-policy-v1` unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- rru-overview-scope
- rru-process
- rru-output
- rru-discovery-conventions
- rru-default-bias
- rru-upstream-alignment
- rru-decision-thresholds
- rru-scope-governor
- rru-access-control
- rru-skill-model-alignment

---

# Overview

## Summary

This document defines the authoritative rules for the `react-reuse-update-new`
skill.

This skill operates under:
- `agent-policy-v1` (mandatory baseline policy)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rru-overview-scope  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Ensures reuse decisions stay within defined responsibilities.

### Requirement

- The skill must evaluate reuse vs update vs new for each needed artifact in
  scope.
- The skill must preserve deterministic behavior for thresholding, tie-breaks,
  and output states.
- The skill must avoid over-generalization of components and prefer minimal
  churn with clear ownership.
- The skill must emit planning guidance only and must not directly implement,
  move, or refactor project code.
- The skill must inherit and enforce shared baseline constraints from
  `agent-policy-v1`.

### Forbidden

- Introducing large refactors unrelated to the request.
- Forcing reuse through leaky domain flags in shared abstractions.
- Returning partial decision payloads when required inputs are invalid or
  discovery evidence is unavailable.
- Defining local mandatory rules that conflict with `agent-policy-v1`.

### Notes

- Use the decision ladder and deterministic defaults to guide outcomes.

---

# Reuse Decision Process

## Summary
Defines deterministic evaluation for reuse, update, or new creation.

---

## Rule: Decision Ladder
**Rule ID:** rru-process  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Keeps decisions consistent and bounded.

### Requirement

- Search for existing implementations before proposing new artifacts, using this
  lookup order for each needed artifact:
  1. Exact or near-name match
  2. Pattern/behavior match
  3. Primitive building-block match
  4. Endpoint/DTO/hook match
- For each lookup tier, record repository evidence as concrete paths or explicit
  `not_found`.
- Discovery coverage must include:
  - Existing domain modules (`sections/`, `hooks/`, `domain/`) in the owning
    feature area before proposing new modules.
  - Existing UI primitives and composites before proposing new UI artifacts.
  - Existing API client/endpoints/DTO patterns before proposing new data-access
    modules.
  - Existing state conventions for server-state, local state, and global store.
  - Existing naming/export conventions so new decisions do not introduce a new
    style in an established area.
- Evaluate each candidate with scored signals:
  - Required scores: `fit`, `complexity_cost`, `coupling_risk`,
    `divergence_risk`, and `locality_benefit` (0-10 scale)
- Apply the reuse ladder in strict order:
  1. Reuse as-is
  2. Update existing
  3. Create new
- Reuse as-is is preferred only when behavior fits with minimal glue, no mode
  flags, and no domain leakage.
- Apply safe-update defaults unless explicit overrides are provided:
  - `max_new_props_for_update=2`
  - `max_flags_allowed_composites=0` for domain mode flags
  - `max_generic_flags_allowed_primitives=1`
  - `max_abstraction_risk_score=6`
- Allow `update` only when changes remain small, abstraction quality improves,
  and existing callers remain compatible (or are straightforward to update).
- When candidate scores tie, resolve in deterministic order:
  1. Candidate in authoritative upstream home
  2. Lower coupling risk
  3. Lower divergence risk
  4. Lower complexity cost
  5. Lexical path order
- Document why reuse/update/new was selected for each needed artifact.
- Apply layer-specific reuse guidance:
  - UI primitives: reuse by default; if missing, create a primitive; if close,
    prefer small generic updates over domain-specific copies.
  - UI composites: reuse only for true UI patterns; generalize via
    slots/children/render props; do not add domain mode flags; if UI shape is
    shared but meaning differs by domain, inject content instead of encoding
    business meaning in the shared composite.
  - Feature sections: cross-domain section reuse defaults to duplication;
    same-domain section reuse is allowed.
  - Feature domain: prefer reuse within the feature domain; move logic to
    cross-domain `lib/` only when it is stable and truly shared.
  - API endpoints/DTOs: endpoint ownership and DTO contracts are reusable, but
    DTO-to-domain mapping remains feature-local unless it is stable cross-domain;
    endpoint modules should remain DTO-returning boundaries.
  - Store: use global store only for global client state and avoid duplicating
    server-state there.
- Creating new modules is preferred when existing code is too opinionated,
  update would require leaky flags/branches, or divergence is likely; duplicate
  feature sections when needed, but treat primitive/composite duplication as a
  design smell versus extending shared building blocks.
- Apply deterministic shortcut bias:
  - Low complexity + low coupling -> prefer reuse or small update.
  - High flag cost + high divergence -> prefer a new feature section while
    reusing shared primitives/composites where safe.
- Enforce anti-leakage guardrails:
  - Shared composites must not receive domain-specific mode flags.
  - Shared abstractions must not encode domain-specific naming.
  - If divergence risk is high, prefer domain-owned sections over forced
    cross-domain generalization.
- If explicit constraints block all safe options for an artifact, emit
  `decision_blocked` and require explicit override before accepting
  non-compliant paths.
- Pause only when reuse intent is unclear and structural cost is meaningful
  (for example: large composite expansion, unclear intentional divergence, or
  likely long-lived UX split). Otherwise proceed with deterministic defaults.
- If abstraction cost is clearly high, default to a feature-local
  section/module instead of forcing shared generalization.
- Do not pause for minor decisions when a safe default exists
  (for example: small harmless prop additions).
- Pause mode defaults are inherited from shared policy:
  - default `pause_mode` is `balanced`
  - use `strict` or `autonomous` only when explicitly configured by policy
    override
- Require upstream minimum decision context before finalizing outcomes:
  - feature owner/domain
  - route/page involvement
  - current data sources
  - intended state type
  - UI needs (primitive/composite/section shape)
- Validate required inputs before discovery and decisioning.
- If required inputs are missing or invalid, emit `validation_error` and stop.
- If repository discovery/search evidence is unavailable or incomplete, emit
  `dependency_error` and stop.
- Preserve `needed_artifact_id` identity from input through final output.

### Forbidden

- Skipping discovery of existing code.
- Returning `new` without repository evidence or explicit `not_found` outcome.
- Returning ambiguous outcomes with no single final decision per artifact.
- Allowing domain leakage to justify reuse/update in shared abstractions.
- Continuing decisioning after required validation or discovery failures.

### Notes

- Favor reuse when behavior matches without threshold violations.

---

# Output Contract

## Summary
Defines the expected deterministic output structure for reuse decisions.

---

## Rule: Structured Decision Output
**Rule ID:** rru-output  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Ensures decisions are actionable and traceable.

### Requirement

- Output must be one JSON object with `schema_version`, `skill`, `version`,
  `result_type`, and `validation_status`.
- `result_type=decision_plan` outputs must include:
  - `thresholds_applied`
  - `revised_plan.source_plan_ref`
  - `revised_plan.context_decisions`
  - `revised_plan.file_actions[]`
  - `revised_plan.layer_justifications[]`
  - per-artifact `decisions[]` entries
- Each decision entry must include:
  - `needed_artifact_id`
  - `decision` (`reuse|update|new|decision_blocked`)
  - `decision_mark` (`reuse as-is|updated|new|decision_blocked`)
  - `discovery_status` (`found|not_found`)
  - concise `reasons[]`
  - `override_required`
- If `discovery_status=found`, output must include concrete `discovery_paths[]`.
- If `decision` is `reuse`, `update`, or `new`, `target_path` must be present.
- If `decision` is `reuse` or `update`, `discovery_status` must be `found`.
- If score details are included, they must use `fit`, `complexity_cost`,
  `coupling_risk`, `divergence_risk`, and `locality_benefit`.
- `reuse`, `update`, and `new` decisions must include `score_profile`.
- If tie-break logic is applied, output must include `tie_break` metadata with
  ordered criteria and selected candidate information.
- Output must include explicit guardrails describing anti-leakage constraints.
- `revised_plan.guardrails[]` must also include concise constraints against:
  - new shared/common dumping-ground abstractions
  - endpoint bypass patterns in hooks/UI layers
  - inline utility placement in pages/sections when the utility belongs in
    domain/lib boundaries
  - mega component expansion through excessive mode/flag props
  - forcing multi-mode shared composites when section-level duplication is safer
  - "refactor for future" scope creep without immediate value
  - mixed migration + feature-behavior churn in one decision package unless explicitly requested
- `revised_plan.file_actions[]` must map each planned touch to `create`,
  `update`, or `reuse` and include concrete paths.
- If any move/rename is planned, output must include `revised_plan.move_actions[]`
  entries with `from_path`, `to_path`, and `import_update_targets[]`.
- `revised_plan.layer_justifications[]` must provide concise layer rationale and
  why adjacent layers were not chosen (1-2 sentences per touched layer).
- `decision_blocked` entries must include:
  - `constraint_blockers[]`
  - `override_required=true`
  - concise rationale describing why all safe paths were blocked
- `result_type=validation_error` outputs must include:
  - `validation_status.is_valid=false`
  - `notes[]` (max 5)
  - no decision payload
- `result_type=dependency_error` outputs must include:
  - `validation_status.is_valid=false`
  - `dependency_issue`
  - `fallback_context_bundle_requirements[]`
  - `notes[]` (max 5)
  - no decision payload
- `decision_plan` outputs must include concise `revised_plan.notes[]` (max 5)
  containing only high-leverage tradeoffs, uncertainties, constraints, or risks.
- `thresholds_applied` must always include:
  - `max_new_props_for_update`
  - `max_flags_allowed_composites`
  - `max_generic_flags_allowed_primitives`
  - `max_abstraction_risk_score`
- If scope caps would be exceeded for materially improved completeness, output
  may include `scope_expansion_needed[]` with bounded `why` and `would_touch`
  entries while still providing an in-cap minimal decision package.
- When `scope_expansion_needed[]` is present, include
  `revised_plan.follow_up_scope[]` as a short, concrete post-approval scope
  list.
- `needed_artifact_id` values must remain stable from request artifacts to
  final decision records.
- `needed_artifact_id` values must be unique within one `decision_plan` output.

### Forbidden

- Output that hides decision rationale.
- Ambiguous decisions without a single final action per artifact.
- Extra prose outside JSON output.
- `decision_blocked` outputs without actionable blocker context.

### Notes

- Keep reasoning concise and focused on material tradeoffs.

---

# Discovery and Convention Audit

## Summary
Defines the mandatory repository discovery and convention checks that must be
completed before final reuse/update/new decisions.

---

## Rule: Discovery Coverage and Convention Fit
**Rule ID:** rru-discovery-conventions  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Prevents duplicate artifacts and style drift by forcing
evidence-based discovery in the active repository.

### Requirement

- Discovery must examine existing homes before proposing new artifacts:
  - check whether `features/<domain>/` already exists before proposing a new
    domain module home
  - domain modules (`features/<domain>/sections`, `hooks`, `domain`)
  - UI primitives and composites
  - API client, endpoints, and DTO modules, following existing `api/client`
    usage patterns
  - state conventions (server-state, local-state, global store), including
    server-state cache wiring patterns (for example QueryClient usage in core
    wiring) when present
- Discovery must verify established naming/export conventions in the active area
  before proposing new paths, including:
  - one concept per role (avoid mixed `Page`/`Route`/`Screen` synonyms in one
    area)
  - deterministic role naming (`*Page`, `*Section`, `use*`, `*Dto`)
  - deterministic API placement naming (`api/endpoints/*` for endpoint modules)
  - file-name and primary-export alignment for searchable names
  - established error-handling style and DTO/domain typing style consistency
  - component naming (`PascalCase` file + export) and hook naming (`useXxx`
    camelCase file + export)
  - avoiding dotted suffix patterns (for example `.page.tsx` / `.route.tsx`)
    unless existing local conventions require them
  - stable export style consistency (prefer named exports; allow default exports
    only where framework conventions or established local area conventions
    require them)
  - avoidance of introducing barrels where area conventions do not use them
  - explicit-import consistency where local area conventions already use it, and
    no mixed barrel/deep-path imports in the same area
  - colocated test naming compatibility (`*.test.tsx` / `*.test.ts`) and
    colocated placement when tests already exist in the target area
- If naming is unclear, file names must still encode module role clearly (for
  example: page/section/hook/dto identity).
- If conventions are ambiguous, choose nearest-neighbor conventions and keep
  names searchable (file name and primary export aligned).
- Each decision must remain traceable to concrete discovery evidence or explicit
  `not_found`.

### Forbidden

- Proposing new modules before checking existing domain and shared homes.
- Inventing a new naming/export style in an established area.
- Treating naming uncertainty as justification for structural churn.

### Notes

- Convention checks are a discovery responsibility, not an implementation
  formatting concern.

---

# Deterministic Default Bias

## Summary
Defines mandatory default actions and pause behavior to keep reuse decisions
deterministic and low-friction.

---

## Rule: Deterministic Defaults and Pause Discipline
**Rule ID:** rru-default-bias  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Reduces over-asking and ensures predictable outcomes when
ambiguity exists but safe defaults are available.

### Requirement

- Apply these deterministic defaults unless structural risk requires a pause:
  - ambiguous feature owner -> choose the most specific domain
  - UI pattern unclear -> keep logic in the feature section
  - reuse vs generalize unclear -> duplicate section-level implementation
  - multiple state options -> prefer local state first
  - unsure store usage -> avoid introducing global store state
  - unsure abstraction -> keep implementation concrete
  - API placement unclear -> use the existing API home
  - folder placement unclear -> follow upstream gravity and nearest established
    home from placement outputs
  - naming unclear -> match nearest-neighbor naming
- Pause only when at least one condition is true:
  - safe progress is impossible without clarification
  - multiple structural paths are equally valid
  - wrong default choice likely creates long-term structural debt
- When pausing, use clean protocol:
  1. state the ambiguity
  2. offer 2-3 concrete options
  3. provide recommended default
  4. wait for confirmation

### Forbidden

- Pausing for minor naming or harmless small-prop decisions.
- Overriding deterministic defaults without explicit structural risk.
- Proceeding with conflicting structural assumptions after deciding to pause.

### Notes

- Default behavior should maximize forward progress and minimize architectural
  churn.

---

# Upstream Alignment and Migration Safety

## Summary
Defines how reuse decisions must honor upstream architecture/placement outputs
and avoid introducing parallel architecture paths.

---

## Rule: Upstream Decision Alignment
**Rule ID:** rru-upstream-alignment  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Keeps reuse decisions coherent with prior skills and prevents
conflicting structural guidance.

### Requirement

- Treat upstream `detection_result` and `placement_plan` as authoritative for:
  - feature/domain ownership
  - layer placement intent
  - endpoint home conventions and data-boundary expectations
- Reuse decisions must refine upstream plans, not recompute or override
  architecture/gravity outcomes within the same task.
- Preserve migration safety:
  - do not create parallel mixed architecture in one decision package
  - avoid half-old/half-new placement without explicit migration boundary
  - keep feature behavior decisions and broad structural migration separated
    unless explicitly requested
- Default move/rename behavior is no moves in feature-scope plans; only include
  move actions when migration scope is explicit and import updates are complete.

### Forbidden

- Overriding upstream feature ownership or layer placement decisions without an
  explicit pause/override path.
- Returning decision guidance that conflicts with established endpoint/layer
  homes in the same task.
- Bundling migration-scale restructuring into routine feature reuse decisions.

### Notes

- This rule constrains refinement scope, not implementation details.

---

# Decision Outcome Thresholds

## Summary
Defines deterministic decision outcome thresholds and scoring interpretation for
reuse/update/new selection.

---

## Rule: Outcome Threshold Interpretation
**Rule ID:** rru-decision-thresholds  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Converts scoring into predictable decisions and prevents
reviewer-dependent outcomes.

### Requirement

- Use score interpretation guidance for fit:
  - `10`: identical behavior
  - `7-9`: minor wiring/extension
  - `4-6`: significant differences
  - `0-3`: wrong abstraction
- Apply these default threshold values unless explicit overrides are supplied:
  - `max_new_props_for_update=2`
  - `max_flags_allowed_composites=0` (domain modes)
  - `max_generic_flags_allowed_primitives=1`
  - `max_abstraction_risk_score=6`
- Reuse is preferred when:
  - `fit >= 8`
  - `complexity_cost <= 3`
  - `coupling_risk <= 3`
  - `divergence_risk <= 4`
- Update is preferred when:
  - `fit >= 6`
  - change remains a small extension under update thresholds
  - coupling remains low
  - no domain mode flags are introduced in shared composites
- New is preferred when one or more are true:
  - fit is too low for safe reuse/update
  - update would require multiple flags/options that violate thresholds
  - divergence risk is high
  - coupling/domain leakage risk is high

### Forbidden

- Selecting `reuse` or `update` outcomes that violate threshold limits without
  explicit override handling.
- Treating high-divergence/high-coupling outcomes as reusable shared abstractions.
- Omitting applied threshold values from decision output.

### Notes

- Thresholds reduce ambiguity; they do not replace architectural judgment.

---

# Scope Governor Alignment

## Summary
Defines how reuse planning must honor hard scope caps and request explicit
approval when expanded scope is materially beneficial.

---

## Rule: Scope Cap Enforcement
**Rule ID:** rru-scope-governor  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Prevents refactor creep and keeps decision packages reviewable.

### Requirement

- Reuse planning must honor baseline hard defaults inherited from shared policy:
  - max files touched: `8`
  - max new files: `4`
  - max moved/renamed files: `0` unless migration mode is explicit
  - max new dependencies: `0` unless explicitly requested
  - max new top-level folders: `0` unless explicitly requested
- If a materially better plan exceeds caps, emit `scope_expansion_needed[]`
  entries with:
  - `why` (concrete reason)
  - `would_touch` (estimated additional files)
- Even when expansion is requested, output must still provide the in-cap
  minimal decision package.
- When caps are exceeded, include a short follow-up scope list describing what
  additional scope would be done after approval.

### Forbidden

- Expanding decision scope beyond hard defaults without explicit expansion
  signaling.
- Treating speculative refactors as valid cap-expansion justification.
- Emitting expansion requests without a bounded file-touch estimate.

### Notes

- Scope expansion is an explicit approval path, not an implicit default.

---

# Access Control and Fallback Context

## Summary
Defines repository access requirements for reuse planning and the mandatory
fallback context bundle when direct repository access is unavailable.

---

## Rule: Read/Search Access and Fallback Bundle
**Rule ID:** rru-access-control  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Reuse decisions require repository evidence; fallback inputs must
be explicit when direct access is unavailable.

### Requirement

- Reuse planning should run with repository read/search access.
- Minimum read/search capabilities expected for decision-quality execution:
  - list `src/` tree shape
  - search code patterns (for example API/query/router identifiers)
  - read file contents on demand
  - read key tooling/config files relevant to architecture signals
- If direct repository access is unavailable, emit `dependency_error` and
  include a fallback context bundle requirement checklist covering:
  - file tree (top-level + `src/` depth ~3-4)
  - `package.json`
  - router entry/config files
  - API client location currently in use
  - representative examples (primitive, composite, section, hook, endpoint)
- Default write mode for this skill remains controlled planning output; direct
  code edits are out of scope for this skill unless explicitly enabled by
  upstream workflow.

### Forbidden

- Producing structural reuse decisions without repository evidence or fallback
  context inputs.
- Assuming architecture signals when both direct access and fallback context are
  missing.
- Treating direct implementation edits as part of this skill's normal output.

### Notes

- This skill is decision-planning only; implementation belongs to downstream
  execution skills.

---

# Skill Model Alignment

## Summary
Defines alignment with the fixed execution skill model and shared policy layer.

---

## Rule: Fixed Skill Model Compliance
**Rule ID:** rru-skill-model-alignment  
**Priority:** MUST  
**Applies to:** react-reuse-update-new  
**Rationale:** Prevents scope drift and keeps responsibilities aligned across
the four execution skills.

### Requirement

- Treat this skill as one of the fixed execution skills in the current model.
- Primary output remains a refined implementation plan with per-artifact
  reuse/update/new decisions.
- Shared policy/config remains a separate layer and must not be re-modeled as a
  new execution skill by this rule set.
- This skill may refine decisions but must not absorb responsibilities owned by
  architecture detection, placement/layering, or implementation discipline.

### Forbidden

- Reframing policy-layer concerns as new execution-skill behavior in this skill.
- Expanding this skill to replace other execution skills in the fixed model.

### Notes

- Cross-skill coordination is mandatory; ownership boundaries remain explicit.
