<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-24
-->

# React Implementation Discipline â€” Agent Rules

## Table of contents
- [Rule: Skill Scope Definition [sr-overview-scope]](#rule-skill-scope-definition)
- [Rule: Baseline Non-goals [sr-overview-nongoals]](#rule-baseline-non-goals)
- [Rule: Minimal Scope Enforcement [sr-constraints]](#rule-minimal-scope-enforcement)
- [Rule: Scope Governor Hard Defaults [sr-scope-governor]](#rule-scope-governor-hard-defaults)
- [Rule: Governance Compliance [sr-governance]](#rule-governance-compliance)
- [Rule: Architecture and Dependency Boundaries [sr-architecture-boundaries]](#rule-architecture-and-dependency-boundaries)
- [Rule: Ownership and Naming Contract [sr-ownership-naming]](#rule-ownership-and-naming-contract)
- [Rule: Deterministic Defaults and Pause Protocol [sr-decision-defaults]](#rule-deterministic-defaults-and-pause-protocol)
- [Rule: Output and Planning Discipline [sr-output-discipline]](#rule-output-and-planning-discipline)
- [Rule: Completion and Quality Baseline [sr-dod-baseline]](#rule-completion-and-quality-baseline)
- [Rule: Planning and Reuse Workflow [sr-planning-reuse]](#rule-planning-and-reuse-workflow)
- [Rule: Migration and Placement Strategy [sr-migration-placement]](#rule-migration-and-placement-strategy)
- [Rule: Fallback Technology Defaults [sr-fallback-defaults]](#rule-fallback-technology-defaults)
- [Rule: Implementation Defaults [sr-implementation-defaults]](#rule-implementation-defaults)
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: Access and Write Control [sr-access-write-control]](#rule-access-and-write-control)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Architecture Detection Output and Bootstrap Contract [sr-architecture-detection-contract]](#rule-architecture-detection-output-and-bootstrap-contract)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: Skill Scope Definition [rid-overview-scope]](#rule-skill-scope-definition-1)
- [Rule: Plan-Driven Implementation [rid-process]](#rule-plan-driven-implementation)
- [Rule: Structured Implementation Output [rid-output]](#rule-structured-implementation-output)
- [Rule: Validation Gate Sequence [rid-validation-gates]](#rule-validation-gate-sequence)
- [Rule: Scope and Churn Caps [rid-scope-governor]](#rule-scope-and-churn-caps)
- [Rule: Context Access and Write Discipline [rid-access-control]](#rule-context-access-and-write-discipline)
- [Rule: Output Mode Selection [rid-output-mode-selection]](#rule-output-mode-selection)
- [Rule: UI Genericity and Anti-Leakage [rid-ui-genericity]](#rule-ui-genericity-and-anti-leakage)
- [Rule: Bottom-Up Flow and Minimal Export Wiring [rid-data-flow-exports]](#rule-bottom-up-flow-and-minimal-export-wiring)
- [Rule: Quick Validation Checklist [rid-quick-validation]](#rule-quick-validation-checklist)
- [Rule: Ambiguity Resolution Strategy [rid-ambiguity-strategy]](#rule-ambiguity-resolution-strategy)
- [Rule: Anti-Chaotic Change Guardrails [rid-chaotic-change-guardrails]](#rule-anti-chaotic-change-guardrails)
- [Rule: Deterministic Defaults and Pause Protocol [rid-pause-defaults-protocol]](#rule-deterministic-defaults-and-pause-protocol-1)
- [Rule: Boundary, Runtime, and Query Correctness [rid-boundary-runtime-query]](#rule-boundary-runtime-and-query-correctness)
- [Rule: Stop and Revise Conditions [rid-stop-conditions]](#rule-stop-and-revise-conditions)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-implementation-discipline` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-overview-scope
- sr-overview-nongoals
- sr-constraints
- sr-scope-governor
- sr-governance
- sr-architecture-boundaries
- sr-ownership-naming
- sr-decision-defaults
- sr-output-discipline
- sr-dod-baseline
- sr-planning-reuse
- sr-migration-placement
- sr-fallback-defaults
- sr-implementation-defaults
- sr-layer-contracts
- sr-access-write-control
- sr-file-size-guidance
- sr-architecture-detection-contract
- sr-enforcement-heuristics
- rid-overview-scope
- rid-process
- rid-output
- rid-validation-gates
- rid-scope-governor
- rid-access-control
- rid-output-mode-selection
- rid-ui-genericity
- rid-data-flow-exports
- rid-quick-validation
- rid-ambiguity-strategy
- rid-chaotic-change-guardrails
- rid-pause-defaults-protocol
- rid-boundary-runtime-query
- rid-stop-conditions

---

# Overview

## Summary

This document defines the authoritative rules for the `react-implementation-discipline` skill.

This skill operates under:
- `react-implementation-discipline` (with mandatory shared baseline policy baked in at build time)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** sr-overview-scope  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared baseline governance and scope constraints explicit.

### Requirement

- The skill must operate only within its defined responsibility.
- The skill must not perform responsibilities assigned to other skills.
- The skill must not reinterpret or override policy without explicit approval.
- The shared baseline must apply uniformly to:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`
- The production execution skill set for this initiative is fixed to those four
  skills; the shared baseline policy is not a production execution skill.
- Shared policy/config updates must not be modeled as new execution skills.
- Document precedence must remain deterministic:
  - `specs/001-agent-policy-v1/master_spec.md` is authoritative.
  - Supporting policy docs may fill non-conflicting open details only.
- The shared baseline must explicitly govern:
  - Architecture/dependency boundaries.
  - Deterministic defaults and pause behavior.
  - Scope-governor limits and expansion protocol.
  - Output consistency for planning and implementation.
  - Ownership/naming conventions and completion checks.

### Forbidden

- Expanding scope beyond the Scope Governor without explicit override.
- Introducing implicit changes to repository structure.
- Creating competing policy sources that conflict with shared baseline precedence.
- Adding new production execution skills without explicit scope/constitution
  update.

---

## Rule: Baseline Non-goals
**Rule ID:** sr-overview-nongoals  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents policy drift into implementation-specific prescriptions.

### Requirement

- Shared policy must define constraints and governance, not implementation
  recipes.
- Shared policy must not implicitly change through examples, migration behavior,
  or downstream reinterpretation.
- Downstream skills may add local guidance only when it does not conflict with
  shared mandatory rules.

### Forbidden

- Treating examples as policy overrides.
- Introducing stack/framework mandates as shared-policy requirements without
  explicit spec approval.

### Notes

- If uncertainty affects governance decisions, pause and request clarification.

---

# Policy Constraints

## Summary
Defines non-negotiable scope and cap controls for downstream skill work.

---

## Rule: Minimal Scope Enforcement
**Rule ID:** sr-constraints  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents uncontrolled scope expansion and dependency creep.

### Requirement

- Changes must stay within the requested feature scope.
- New top-level folders must not be added without explicit approval.
- New dependencies must not be added without explicit approval.
- `pre_approved_collisions` must exist only in shared baseline header and be
  empty unless explicitly approved in a future version.
- When work appears to exceed scope caps, deliver the smallest viable in-cap
  result and provide a structured follow-up scope list.

### Forbidden

- Silent expansion of scope.
- Introducing unapproved dependencies or repositories.
- Defining downstream-local collision registries.
- Mixing structural migration moves with feature behavior work unless explicitly
  requested.

### Notes

- If a requirement cannot be met without expanding scope, pause and request
  approval.

---

## Rule: Scope Governor Hard Defaults
**Rule ID:** sr-scope-governor  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Controls churn and keeps delivery bounded.

### Requirement

- Hard defaults (unless explicitly overridden):
  - Max files touched: `8`
  - Max new files: `4`
  - Max moved/renamed files: `0` (unless migration mode explicitly enabled)
  - Max new dependencies: `0`
  - Max new top-level folders: `0`
- When caps are exceeded, provide a structured scope expansion request with
  concrete `why` and `would_touch` fields, while still delivering an in-cap
  result.

### Forbidden

- Exceeding hard defaults silently.
- Expanding dependency or top-level folder scope without explicit approval.

---

# Governance

## Summary
Sets expectations for compliance, documentation, and review.

---

## Rule: Governance Compliance
**Rule ID:** sr-governance  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures policies are enforced consistently across changes.

### Requirement

- All changes must be validated against the constitution and project specs.
- Documentation updates must keep guidance accurate and current.
- Generated artifacts must be produced by the official build process.
- Shared-policy rule changes must include an explicit policy version increment
  with documented rationale.
- Shared-policy exception approvals must be performed by repo maintainers only.
- Exception records must include rationale and conflicting rule reference.
- Exception records must not include expiry metadata; approved exceptions remain
  active until explicitly revoked or superseded by newer policy version.
- `pre_approved_collisions` must be managed only in the shared baseline header.
- Policy behavior must not be changed implicitly via examples, migration
  behavior, or downstream reinterpretation.

### Forbidden

- Bypassing validation requirements.
- Manual edits to generated artifacts.
- Approving shared-policy exceptions from non-maintainer roles.
- Adding expiry fields to shared-policy exception records.
- Defining downstream-local `pre_approved_collisions` sources.
- Changing shared-policy semantics without a version and rationale update.

### Notes

- If governance rules conflict, the constitution takes precedence.

---

# Architecture Boundaries

## Summary
Defines shared architecture and dependency-boundary rules all downstream skills
must enforce.

---

## Rule: Architecture and Dependency Boundaries
**Rule ID:** sr-architecture-boundaries  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills enforce one consistent
architecture and import-boundary model.

### Requirement

- The following non-negotiables must be enforced:
  - Do not create new folders unless explicitly allowed by policy or user
    instruction.
  - Never place domain business logic in `ui/**` or `api/**`.
  - Never fetch outside the canonical endpoint layer
    (`api/endpoints/**` or gravity-equivalent API home).
  - Prefer small, composable changes over large refactors.
  - Avoid `shared/` or `common/` dumping-ground patterns.
- Dependency direction must remain consistent with the baseline:
  - `ui/**` must not import `features/**`, `api/**`, `store/**`, or `pages/**`.
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`.
  - `features/**` must not import `pages/**`.
  - `pages/**` must not import canonical endpoint modules directly.
  - `hooks/**` must not import `features/**`, `pages/**`, or `store/**`; imports
    from `api/**` are allowed only when documented in exactly one canonical
    policy location.
- The canonical endpoint layer must be determined once per task by Architecture
  Detection and reused consistently in boundary checks for that task.
- If a path alias exists (for example `@/`), all boundary rules apply equally to
  alias imports and raw `src/**` imports.
- Generic fetch-hook exceptions are valid only when documented in exactly one
  canonical policy location; multiple policy locations invalidate the exception.
- No second home may be introduced for the same concern (UI/API/store/routing)
  unless explicit migration scope is approved.

### Forbidden

- Competing homes for the same concern in the same scope.
- Domain terms in reusable `ui/**` component file names.
- DTO-to-domain mapping in `api/**`.

### Notes

- Architecture Detection owns gravity decisions; downstream skills inherit those
  decisions unless a valid pause is triggered.

---

# Ownership and Naming

## Summary
Defines shared ownership boundaries and naming conventions for downstream skill
specifications.

---

## Rule: Ownership and Naming Contract
**Rule ID:** sr-ownership-naming  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps responsibility boundaries and naming deterministic across
all downstream specs.

### Requirement

- `pages/**` remain thin route orchestrators.
- `features/**` own domain behavior, feature hooks, and domain mapping.
- `ui/primitives/**` and `ui/composites/**` stay domain-agnostic.
- `api/**` stays transport-only and returns DTOs or normalized errors.
- `store/**` is global client-state only; do not mirror server-state without
  explicit justification.
- Naming conventions must remain deterministic:
  - `*Page.tsx` for pages.
  - `*Section.tsx` for feature sections.
  - `use*.ts` for hooks.
  - `*.dto.ts` and `*Dto` for DTOs.
- Naming and exports must remain searchable and consistent:
  - Prefer matching file/export names.
  - Prefer named exports unless framework conventions require default exports.
  - Avoid introducing barrel files unless the local area already uses them
    consistently.

### Forbidden

- Domain mode flags in shared composites.
- Introducing new naming schemes when local patterns are clear.
- API transport concerns in UI or generic hook layers.
- Mixed synonym vocabularies for the same role in the same scope (for example
  mixing `Page` and `Route` naming without existing convention).

---

# Decision Defaults and Pause Rules

## Summary
Defines deterministic default behavior and high-impact clarification triggers.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** sr-decision-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Reduces unnecessary clarification loops while protecting
high-impact structural decisions.

### Requirement

- Use deterministic defaults for non-structural ambiguity.
- Pause only when both are true:
  - `confidence < 0.7`
  - `impact = structural`
- Structural impact includes top-level structure changes, competing concern
  homes, dependency-direction changes, cross-layer moves, global state strategy
  changes, or scope-cap violations.
- When pausing, use clean pause protocol:
  - State ambiguity clearly.
  - Present 2-3 options.
  - Recommend a default.
  - Wait for confirmation.
- Use `balanced` pause mode by default unless explicitly configured otherwise.
- Do not pause for minor decisions when a safe default exists.

### Forbidden

- Proceeding on structural ambiguity without pause.
- Repeated low-value questions when a safe deterministic default exists.
- Vague, non-blocking, or style-only clarification questions that do not change
  structural outcomes.

---

# Output and Planning Discipline

## Summary
Defines required output structure for planning and implementation guidance.

---

## Rule: Output and Planning Discipline
**Rule ID:** sr-output-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps downstream planning and implementation outputs consistent,
compact, and reviewable.

### Requirement

- Planning outputs must include:
  - File touch plan (`Create`/`Update`/`Reuse` with paths).
  - Layer justification.
  - Reuse decision notes (`reuse as-is`, `updated`, `new`).
  - A short decision explanation that states detected architecture signals and
    chosen direction.
- Planning outputs must use a machine-readable JSON object with `notes[]`
  limited to 5 items.
- Implementation output must:
  - Use changed snippets for updated files by default.
  - Use unified diff when edits are scattered across non-adjacent regions.
  - Use full content for new files.

### Forbidden

- Full existing-file dumps unless explicitly requested or file is small and
  fully changed.
- Unstructured narrative-only planning outputs.

---

# Completion and Quality Baseline

## Summary
Defines mandatory completion checks and runtime-safety expectations inherited by
all downstream skills.

---

## Rule: Completion and Quality Baseline
**Rule ID:** sr-dod-baseline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures every downstream skill validates critical correctness and
safety gates before completion.

### Requirement

- Boundary audit must pass:
  - No forbidden imports by layer.
  - No fetching outside canonical endpoint layer.
  - `api/**` remains transport-only.
- Runtime safety baseline:
  - Loading state handling when server data is involved.
  - Error state handling.
  - Empty state handling for list/collection views.
  - No unhandled promise rejections.
- Minimal churn baseline:
  - Touch only planned files unless deviations are explained.
  - Avoid unrelated refactors.
- If tooling exists, applicable checks must pass (`tsc`, lint, and existing test
  suites relevant to changed behavior).
- If TanStack Query (or equivalent) is used, query correctness checks must
  ensure stable keys, intended invalidation, and justified server-state/store
  boundaries.
- Tests are required only when a suite already exists and changed behavior falls
  within that suite's scope.

### Forbidden

- Marking work done without boundary/safety checks.
- Treating optional quality checks as mandatory when repository tooling does not
  exist.
- Claiming compliance while skipping available type/lint checks in repositories
  that provide those checks.

---

# Planning and Reuse Workflow

## Summary
Defines required pre-implementation workflow and reuse decision discipline for
all downstream skills.

---

## Rule: Planning and Reuse Workflow
**Rule ID:** sr-planning-reuse  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents ad hoc implementation choices and improves consistency
across downstream planning outputs.

### Requirement

- Before implementation, downstream skills must:
  - Classify request type (feature, route/page, API integration, refactor, bug
    fix).
  - Choose a domain owner.
  - Map affected layers.
  - Identify expected data sources.
  - Decide server/local/global state ownership.
  - Decide UI reuse shape (reuse/update/new).
  - List planned file touches.
- Existing implementations must be searched before creating new modules in:
  - Feature/domain modules.
  - UI primitives/composites.
  - API endpoints/DTOs.
  - State patterns.
- Reuse decisions must follow the ladder:
  - Reuse as-is.
  - Update existing (small, clean extension).
  - Create new (when reuse would leak domain concerns or force excessive
    complexity).
- For shared composites, if reuse requires too many domain-specific options,
  prefer feature-level duplication instead of adding domain mode flags.
- Reuse evaluation should weigh complexity cost, coupling risk, divergence
  probability, and locality benefit.

### Forbidden

- Creating new modules without checking existing alternatives.
- Skipping explicit reuse/update/new decision capture.
- Forcing domain behavior into reusable shared composites.

---

# Migration and Placement Strategy

## Summary
Defines migration-aware placement rules and strategy selection constraints.

---

## Rule: Migration and Placement Strategy
**Rule ID:** sr-migration-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents mixed-architecture drift and keeps placement decisions
deterministic in legacy or evolving repositories.

### Requirement

- Do not introduce parallel architectures for the same concern.
- Choose a strategy per change:
  - Follow existing.
  - Introduce target structure at boundaries.
  - Migrate as you touch (explicit migration scope only).
- Default balanced behavior:
  - No moves/renames unless explicitly enabled.
  - Introduce new homes only when isolated and non-competing.
  - Keep feature behavior and structural migration separate unless explicitly
    requested.
- Gravity decisions from Architecture Detection are inherited by downstream
  skills and must not be recomputed unless pause/escalation resolves a conflict.
- If move mode is explicitly enabled, keep moves small and complete import
  updates in the same change.

### Forbidden

- Two active homes for the same concern in one scope.
- Mixing broad structural migration with unrelated behavior changes.
- Recomputing gravity independently in downstream skills without escalation.

---

# Fallback Technology Defaults

## Summary
Defines shared fallback defaults used only when repository conventions are
missing or ambiguous.

---

## Rule: Fallback Technology Defaults
**Rule ID:** sr-fallback-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic cross-skill defaults while honoring
existing repository gravity first.

### Requirement

- Existing repository stack/conventions take precedence over fallback defaults.
- If no clear convention exists, defaults are:
  - Server-state: TanStack Query; keep transport in `api/endpoints/**`.
  - Client-state: local-first; global store only when truly global.
  - Routing: React Router for plain React; framework-native routing when
    framework is detected.
  - Styling: follow existing; Tailwind default only for greenfield.
  - Forms: react-hook-form.
  - Validation: Zod at boundaries (DTO/form), with domain schema ownership in
    feature domain layers.
  - HTTP client: native `fetch` via shared wrapper; normalized `ApiError`;
    conservative retry posture.
  - Build tool: Vite for greenfield plain React unless existing conventions say
    otherwise.
  - Date/localization: native `Date` and `Intl` unless domain needs justify
    more.
  - Identifier strategy: string IDs by default.

### Forbidden

- Introducing competing stack choices mid-repository without explicit request.
- Mirroring server-state into global store without explicit justification.

---

# Implementation Defaults

## Summary
Defines shared implementation posture defaults inherited by downstream skills.

---

## Rule: Implementation Defaults
**Rule ID:** sr-implementation-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Aligns downstream implementation behavior on quality, environment
access, logging, and tooling posture.

### Requirement

- Feature flags must be centralized in `config/featureFlags.ts` and evaluated at
  composition boundaries.
- Reusable UI components should support class extension patterns consistently
  (for example `className` with shared merge helper where applicable).
- Accessibility baseline is required for reusable UI.
- Performance posture is readability-first; memoization optimizations require
  concrete justification.
- Repository topology must be detected (single-app vs monorepo) and rules
  applied per app root when monorepo signals exist.
- Module-boundary tooling posture is spec-first:
  - Start with import-boundary review checks.
  - Add lint/tool enforcement only when explicitly requested as dedicated
    hardening scope.
  - Mirror alias paths in boundary lint rules when aliases are present.
- Environment access must be centralized through `config/env.ts`.
- Logging should use shared logger abstractions; avoid committed debug logging.
- Codegen is opt-in only; default to handwritten endpoint/DTO ownership.
- Storybook/docs are optional and should follow existing setup when present.

### Forbidden

- Direct environment reads outside `config/env.ts`.
- Committing `console.log`/`console.debug` in production code paths.
- Introducing codegen or docs platforms as implicit scope expansion.
- Adding boundary/tooling stacks implicitly in routine feature scope.

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# Access and Write Control

## Summary
Defines shared access assumptions and write-control behavior for downstream
skills.

---

## Rule: Access and Write Control
**Rule ID:** sr-access-write-control  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps structural decisions grounded in repository signals and
maintains controlled, reviewable changes.

### Requirement

- Detection/reuse/planning stages require repository read/search access.
- Minimum capabilities include:
  - Listing relevant file trees.
  - Searching code patterns.
  - Reading source/config files on demand.
- If direct access is unavailable, require a fallback context bundle with file
  tree, package/tooling config, router entry, API home, and representative
  module examples.
- Default write posture must be controlled and reviewable.
- If direct writes are enabled, scope-governor and minimal-churn rules still
  apply.
- Architecture/specification document edits require explicit request and must be
  treated as dedicated documentation scope.

### Forbidden

- Structural placement decisions without repository signal checks.
- Silent broad writes that bypass scope and review controls.
- Auto-editing architecture/spec documents during regular implementation work.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Architecture Detection Contract

## Summary
Defines the shared contract that downstream skills must inherit from
architecture-detection outputs, including bootstrap behavior.

---

## Rule: Architecture Detection Output and Bootstrap Contract
**Rule ID:** sr-architecture-detection-contract  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills consume one consistent
architecture-detection result and bootstrap behavior.

### Requirement

- Architecture detection output must include the shared structural signals:
  - `routing.type`
  - `ui.home`
  - `api.home` (canonical endpoint layer for boundary checks)
  - `domain.organization`
  - `gravity_map`
  - `alignment_score`
  - `strategy`
  - `notes[]`
- Gravity decisions are owned by architecture detection and reused by all
  downstream skills within the same task.
- Downstream skills must not recompute/override gravity unless a structural
  pause is triggered and explicitly resolved.
- Bootstrap behavior applies only when no clear concern homes exist:
  - Allow folder creation only from the canonical set:
    `pages/`, `features/`, `ui/primitives/`, `ui/composites/`, `api/client/`,
    `api/dto/`, `api/endpoints/`, `core/`, `lib/`, `hooks/`, `config/`
  - `store/` may be created only when truly global client-state is required.
  - Prefer minimal bootstrap: create only folders needed for the current task.

### Forbidden

- Consuming inconsistent architecture-detection outputs across downstream skills
  for the same task.
- Creating speculative bootstrap folders not needed by the current task.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# Overview

## Summary

This document defines authoritative constraints for
`react-implementation-discipline`.

This skill operates under:

- `shared-rules` (mandatory baseline policy)

All rules here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rid-overview-scope  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep implementation output disciplined, reviewable, and aligned
with architecture and policy.

### Requirement

- Enforce plan fidelity: implementation must follow the approved revised plan.
- Enforce boundary and quality gates before output is finalized.
- Enforce minimal churn: avoid unrelated refactors and speculative cleanup.
- Inherit and enforce shared baseline constraints from `shared-rules`.
- Treat these by default as out of scope unless explicitly approved:
  - architecture migration
  - new dependencies
  - unrelated cleanup/refactor work
  - policy/spec document edits
- Require deterministic output states:
  - `accepted`
  - `blocked`
  - `dependency_error`
  - `validation_error`

### Forbidden

- Skipping required validation, boundary, or scope checks.
- Modifying architecture/specification policy artifacts unless explicitly requested.
- Defining local mandatory rules that conflict with `shared-rules`.
- Returning unqualified implementation output when mandatory checks fail.

### Notes

- If required repository context is unavailable, fail closed.
- Always prefer bounded, reviewable changes over large structural drift.

---

# Implementation Process

## Summary

Defines disciplined, plan-driven implementation with fail-closed safeguards.

---

## Rule: Plan-Driven Implementation
**Rule ID:** rid-process  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensure deterministic execution that matches approved planning and
policy constraints.

### Requirement

- Validate required inputs before any implementation output:
  - `revised_plan`
  - `detection_result`
  - repository context needed for convention and boundary checks
- If required inputs are invalid, return `validation_error` and stop.
- If required repository context is unavailable, return `dependency_error` and
  stop.
- Dependency-error handling must include actionable fallback context-bundle
  requirements for no-direct-access execution.
- Honor optional execution controls when provided:
  - `diff_preference`: prefer snippet-first or unified-diff output as requested,
    unless safer output mode rules require escalation.
  - `strictness`: default to `strict`; allow `relaxed` only when explicitly
    permitted in request context.
  - `max_lines_policy`: allow explicit soft-cap overrides when provided.
- Enforce plan fidelity:
  - touch only files in the revised plan
  - allow extra touches only for minimal dependency/export wiring requirements
  - record each extra touch with one-line rationale
- Enforce boundary checks for modified artifacts:
  - `ui/**` must not import from `features/**`, `api/**`, `store/**`, `pages/**`
  - `api/**` must not import React or UI/presentation layers
  - `pages/**` must not call canonical endpoint modules directly
  - hooks must follow documented exception policy for `hooks/** -> api/**`
- Enforce convention matching using nearest repository analogs:
  - naming style
  - export style
  - local error-handling patterns
  - path alias conventions
- Enforce minimal churn:
  - no unrelated renames
  - no broad formatting-only rewrites
  - no speculative refactors
- Enforce file-size discipline:
  - soft caps by layer: pages `120-150`, sections `200-250`, composites
    `200-250`, hooks `150-200`, feature domain files around `200`, endpoints
    `80-120`, primitives `<=150`, `lib` files `120-200`, `store` slices
    `150-250`, and `core` files around `150`
  - mandatory split/extraction when any touched file would exceed `400` lines
  - hard stop when any touched file would exceed `600` lines
- Enforce out-of-scope policy:
  - unapproved migration/dependency/cleanup/spec edits must be excluded
  - represent excluded work through bounded scope-expansion guidance
- Require final quality-gate checks before completion and map result to final
  state (`accepted` or `blocked`).

### Forbidden

- Implementing without required upstream inputs.
- Continuing execution after missing repository context.
- Returning accepted output when mandatory quality checks fail.
- Including unapproved out-of-scope work in implementation payload.
- Violating boundary rules to satisfy convenience implementation.

### Notes

- Prefer deterministic defaults when safe and compliant.
- Keep changes reviewable and constrained to requested scope.

---

# Output Contract

## Summary

Defines strict output envelopes for accepted, blocked, validation-error, and
dependency-error outcomes.

---

## Rule: Structured Implementation Output
**Rule ID:** rid-output  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensure implementation outcomes are machine-consumable,
review-ready, and policy-verifiable.

### Requirement

- Output must be JSON only.
- Output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `result_type`
  - `validation_status`
- `validation_status` must report:
  - `is_valid`
  - `stage`
  - `quality_check_status`
  - `boundary_status`
  - `scope_deviation_status`
  - `final_state`
  - `errors`
  - optional `warnings`
- Supported `result_type` values:
  - `implementation_package`
  - `validation_error`
  - `dependency_error`
- `implementation_package` must include `output_package` with:
  - `changed_files`
  - optional `updated_patches`
  - optional `new_files`
  - `quality_checks`
  - `boundary_audit`
  - `scope_deviations`
  - optional `required_fixes` (required when `final_state=blocked`)
  - optional `recommended_follow_up_scope`
  - optional `notes`
- If `scope_expansion_needed` is present, include
  `output_package.recommended_follow_up_scope`.
- `validation_error` output must include `notes` and must not include
  `output_package`.
- `dependency_error` output must include:
  - `dependency_issue`
  - `fallback_context_bundle_requirements`
  - `notes`
  and must not include `output_package`.

### Forbidden

- Returning unstructured prose.
- Omitting validation summary fields.
- Returning `blocked` without `required_fixes`.
- Returning error outputs with implementation payload.

### Notes

- Keep notes concise (max 5 items where applicable).
- Prefer deterministic field population for downstream consumers.

---

# Validation Gates

## Summary

Defines mandatory implementation validation checks and execution order.

---

## Rule: Validation Gate Sequence
**Rule ID:** rid-validation-gates  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Catch high-risk defects early and keep completion criteria
consistent.

### Requirement

- Always execute this high-signal sequence before final output:
  1. Boundary audit
  2. Type/lint checks when tooling exists
  3. Loading/error/empty state review when relevant
  4. Query key/invalidation sanity when relevant
  5. Scope/minimal churn audit
  6. Existing test suite checks when present
- Required always:
  - boundary rules satisfied
  - no fetching outside canonical endpoint ownership
  - plan-followed minimal churn
- Required when tooling exists:
  - type/lint commands pass using repository-standard checks
- Required when test suite exists:
  - relevant tests updated or added for changed behavior
- Any failed mandatory gate must set `final_state=blocked`.

### Forbidden

- Declaring success when required gates were skipped.
- Treating failed mandatory gates as warnings-only output.

### Notes

- Keep validation deterministic and evidence-based.

---

# Scope Governor

## Summary

Defines hard execution caps and bounded scope expansion behavior.

---

## Rule: Scope and Churn Caps
**Rule ID:** rid-scope-governor  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent implementation drift and keep output reviewable.

### Requirement

- Enforce default hard caps unless explicitly overridden:
  - max files touched: `8`
  - max new files: `4`
  - max moved/renamed files: `0`
  - max new dependencies: `0`
  - max new top-level folders: `0`
- When caps are exceeded but minimum delivery is possible:
  - return the in-cap minimal output
  - include bounded `scope_expansion_needed[]` with `why` and `would_touch`
  - include concise `recommended_follow_up_scope[]`
- Out-of-scope requests without explicit approval must be excluded from
  implementation payload.

### Forbidden

- Expanding scope silently.
- Adding dependencies without explicit approval.
- Mixing migration moves with feature behavior without explicit request.

### Notes

- Favor smallest viable in-cap delivery first.

---

# Access and Write Control

## Summary

Defines repository-access requirements and fail-closed behavior when context is
missing.

---

## Rule: Context Access and Write Discipline
**Rule ID:** rid-access-control  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent unsafe assumptions and maintain controlled change output.

### Requirement

- Require repository read/search capability for convention and boundary checks.
- Minimum context capabilities:
  - list relevant tree
  - search patterns
  - read target files and config files
- If direct repository context is unavailable, return `dependency_error` with
  actionable `fallback_context_bundle_requirements`, including at least:
  - feature-relevant file tree
  - `package.json`
  - router/entry files when applicable
  - canonical API home information
  - sample primitive/composite/section/hook/endpoint modules
- Default write control behavior:
  - produce reviewable patch/new-file output
  - avoid direct structural writes outside approved plan
  - never auto-edit architecture docs or specification docs (`specs/**`, including `specs/**/master_spec.md`) unless requested

### Forbidden

- Producing accepted implementation output without required context evidence.
- Silent direct-write behavior that bypasses planned review controls.

### Notes

- Fail closed on missing context; do not guess structural conventions.

---

# Output Mode Selection

## Summary

Defines deterministic selection between snippet/diff updates and full-file output.

---

## Rule: Output Mode Selection
**Rule ID:** rid-output-mode-selection  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep implementation output reviewable while minimizing misapply risk.

### Requirement

- For existing files, default to changed snippets or unified diffs.
- If `diff_preference` is provided, treat it as the initial mode bias:
  - `snippet_first` -> prefer snippets when safe.
  - `unified_diff` -> prefer unified diffs.
- Automatically prefer unified diff when:
  - edits are non-adjacent in one file
  - imports/exports and logic are changed together
  - snippet-only output risks incorrect application
- For new files, provide full file content.
- Do not return unrelated full files.
- If an existing file is very small and fully changed, full-file output is
  allowed.
- If a newly created file would exceed about 250 lines, prefer splitting
  responsibilities before finalizing output.

### Forbidden

- Returning entire existing files by default.
- Mixing unrelated file content into one output package.

### Notes

- Favor the smallest clear output that preserves apply correctness.

---

# UI Genericity

## Summary

Defines anti-leakage rules for primitives/composites during implementation.

---

## Rule: UI Genericity and Anti-Leakage
**Rule ID:** rid-ui-genericity  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent domain coupling and unstable abstractions in shared UI.

### Requirement

- When updating shared composites:
  - prefer slots/children/render composition
  - do not add domain-specific props or enums
  - do not import domain types
- When updating primitives:
  - small ergonomic props are allowed
  - do not introduce domain mode flags
- If reuse would require leaky abstraction via `variant`, `mode`, or `context`
  flags, prefer feature-section ownership or safe duplication.
- Keep domain behavior in feature sections/hooks, not in shared UI layers.

### Forbidden

- Encoding domain terms or domain logic in shared `ui/**` components.
- Forcing multi-domain behavior through large flag matrices in composites.

### Notes

- Optimize for long-term divergence safety over short-term over-generalization.

---

# Data Flow and Exports

## Summary

Defines execution order, data-flow boundaries, and export wiring discipline.

---

## Rule: Bottom-Up Flow and Minimal Export Wiring
**Rule ID:** rid-data-flow-exports  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep implementation predictable and avoid boundary leakage.

### Requirement

- Prefer bottom-up implementation order when applicable:
  1. DTO/type boundaries
  2. endpoint modules
  3. domain/adapters
  4. feature hooks
  5. UI primitives/composites
  6. feature sections
  7. page composition
- Enforce predictable data flow:
  - endpoint modules return transport DTO data
  - feature layer maps DTO to domain where needed
  - sections render domain-facing data
  - pages compose sections
- Do not fetch inside UI components when canonical endpoint flow exists.
- Wire exports minimally:
  - update nearest existing barrel only when the area already uses barrels
  - avoid introducing new barrel files unless local convention requires it

### Forbidden

- Bypassing endpoint ownership from UI/page layers.
- Creating broad barrel rewires unrelated to requested change.

### Notes

- Keep wiring changes local to reduce merge and review risk.

---

# Quick Validation

## Summary

Defines pre-output lightweight checks required for disciplined completion.

---

## Rule: Quick Validation Checklist
**Rule ID:** rid-quick-validation  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Catch common correctness issues before output is finalized.

### Requirement

- Before final output, confirm:
  - no circular imports introduced by touched files
  - no forbidden imports or boundary violations
  - changed code references valid existing types/contracts
  - query keys remain stable where server-state hooks are updated
  - loading/error/empty handling remains consistent with local patterns
- If repository tests exist and touched behavior requires updates, include
  relevant test adjustments.

### Forbidden

- Finalizing output without running these checks.
- Marking output accepted when these checks identify unresolved failures.

### Notes

- This rule complements (not replaces) formal lint/type/test commands.

---

# Ambiguity Strategy

## Summary

Defines deterministic behavior when local patterns conflict or are unclear.

---

## Rule: Ambiguity Resolution Strategy
**Rule ID:** rid-ambiguity-strategy  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep delivery moving while minimizing structural mistakes.

### Requirement

- When multiple local patterns exist, use this order:
  1. `follow-existing`: mimic the area being modified
  2. `introduce-boundaries`: keep new module internally consistent
  3. `migrate-as-you-touch`: only when it reduces confusion without scope drift
- Prefer the lowest-churn compliant option when multiple choices are valid.
- Pause only for structural blockers:
  - no boundary-compliant implementation path exists
  - conflicting patterns prevent safe placement
  - scope cannot be reduced to a safe minimum
- For non-structural ambiguity, apply deterministic defaults and proceed.

### Forbidden

- Pausing for minor naming/style choices with safe defaults.
- Introducing broad migrations to resolve local ambiguity.

### Notes

- Interruptions should be rare and high-leverage.

---

# Chaotic Change Guardrails

## Summary

Defines explicit anti-patterns that must be avoided during implementation.

---

## Rule: Anti-Chaotic Change Guardrails
**Rule ID:** rid-chaotic-change-guardrails  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent architecture drift and uncontrolled maintenance debt.

### Requirement

- Do not introduce new `shared/` or `common/` dumping-ground abstractions.
- Do not move inline utility/domain logic into pages/sections when it belongs
  in domain/lib layers.
- Do not bypass canonical endpoint layers from hooks/UI.
- Do not combine structural migration with feature behavior in the same change
  unless explicitly requested.
- Keep feature changes local and migration-aware; avoid two-architecture
  parallelism.

### Forbidden

- Refactor-for-future changes without immediate feature value.
- Creating mega components with many mode/flag combinations.

### Notes

- If migration work is necessary, isolate it as explicit scope.

---

# Pause Defaults Protocol

## Summary

Defines deterministic default behavior and strict pause protocol for structural
ambiguity.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** rid-pause-defaults-protocol  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Avoid unnecessary interruptions while preventing structural debt.

### Requirement

- Apply deterministic defaults when safe:
  - ambiguous feature owner -> choose most specific domain
  - unclear UI pattern -> keep logic in feature section
  - unclear reuse/generalize -> prefer section-level duplication
  - unclear state ownership -> prefer local state first
  - unclear abstraction value -> keep implementation concrete
  - unclear naming -> match nearest neighbor naming
- Pause only when cost of guessing is structurally high:
  - no boundary-compliant path exists
  - conflicting patterns block safe placement
  - scope cannot be reduced to minimum safe delivery
- When pausing, follow clean protocol:
  1. state ambiguity precisely
  2. offer 2-3 concrete options
  3. recommend a default option
  4. stop and wait for confirmation
- Keep questions high-leverage and structural; avoid broad or stylistic
  questions when safe defaults exist.

### Forbidden

- Pausing for minor naming/styling choices.
- Asking vague architecture questions during implementation.
- Blocking delivery when a safe deterministic default exists.

### Notes

- Default pause mode is effectively balanced: pause only for structural blockers.

---

# Boundary Runtime Query

## Summary

Defines boundary-audit detail, runtime safety essentials, and query correctness
requirements.

---

## Rule: Boundary, Runtime, and Query Correctness
**Rule ID:** rid-boundary-runtime-query  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensure implementation output is safe at architecture and runtime
levels.

### Requirement

- Boundary audit must enforce all canonical restrictions, including alias paths
  when aliases are used.
- `ui/**` must not import `features/**`, `api/**`, `store/**`, `pages/**`.
- `api/**` must not import React/UI/features/pages/store.
- `features/**` must not import `pages/**`.
- `pages/**` must not import canonical endpoint layer directly.
- Do not fetch outside canonical endpoint layer.
- Prevent domain terms in shared UI component/file naming.
- Runtime safety essentials when server data is involved:
  - handle loading state
  - handle error state
  - handle empty state for collection/list views
  - avoid unhandled promise rejections
  - avoid fire-and-forget fetch in UI layers
- Query correctness when server-state caching exists:
  - stable query keys
  - correct invalidation/cache updates after mutations
  - avoid duplicating server-state in global store unless explicitly justified
  - keep retry behavior intentional (small capped retries for transient query
    failures; no automatic mutation retries unless explicitly required)

### Forbidden

- Accepting outputs with unresolved boundary violations.
- Accepting outputs that skip required runtime state handling.
- Duplicating server-state into store without explicit justification.

### Notes

- Record failures in `validation_status` and return `blocked` when mandatory.

---

# Stop Conditions

## Summary

Defines hard stop/revise conditions before output finalization.

---

## Rule: Stop and Revise Conditions
**Rule ID:** rid-stop-conditions  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent knowingly non-compliant output from being emitted.

### Requirement

- Stop and revise plan/output if implementation would require:
  - domain knowledge inside shared `ui/**`
  - endpoint fetch outside canonical endpoint layer
  - leaky shared-composite generalization beyond safe thresholds
  - touched files exceeding 400 lines without extraction/split path
  - touched files exceeding 600 lines at all
- If blocked due to unresolved stop conditions, return `blocked` state with
  explicit required fixes.
- If stop condition is caused by missing mandatory context, return
  `dependency_error` instead of `blocked`.

### Forbidden

- Proceeding with known stop-condition violations.
- Hiding stop-condition violations as warnings-only output.

### Notes

- Stop conditions are hard gates, not advisory guidance.
