<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-27
-->

# React Implementation Discipline â€” Agent Rules

## Table of contents
- [Rule: Skill Scope Definition [sr-overview-scope]](#rule-skill-scope-definition)
- [Rule: Baseline Non-goals [sr-overview-nongoals]](#rule-baseline-non-goals)
- [Rule: Minimal Scope Enforcement [sr-constraints]](#rule-minimal-scope-enforcement)
- [Rule: Scope Governor Hard Defaults [sr-scope-governor]](#rule-scope-governor-hard-defaults)
- [Rule: Governance Compliance [sr-governance]](#rule-governance-compliance)
- [Rule: Architecture and Dependency Boundaries [sr-architecture-boundaries]](#rule-architecture-and-dependency-boundaries)
- [Rule: Ownership and Naming Contract [sr-ownership-naming]](#rule-ownership-and-naming-contract)
- [Rule: Deterministic Defaults and Pause Protocol [sr-decision-defaults]](#rule-deterministic-defaults-and-pause-protocol)
- [Rule: Output and Planning Discipline [sr-output-discipline]](#rule-output-and-planning-discipline)
- [Rule: Completion and Quality Baseline [sr-dod-baseline]](#rule-completion-and-quality-baseline)
- [Rule: Planning and Reuse Workflow [sr-planning-reuse]](#rule-planning-and-reuse-workflow)
- [Rule: Migration and Placement Strategy [sr-migration-placement]](#rule-migration-and-placement-strategy)
- [Rule: Fallback Technology Defaults [sr-fallback-defaults]](#rule-fallback-technology-defaults)
- [Rule: Implementation Defaults [sr-implementation-defaults]](#rule-implementation-defaults)
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: Access and Write Control [sr-access-write-control]](#rule-access-and-write-control)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Architecture Detection Output and Bootstrap Contract [sr-architecture-detection-contract]](#rule-architecture-detection-output-and-bootstrap-contract)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: Micro-change Bypass and Skill 4 Micro Mode [sr-micro-change-bypass]](#rule-micro-change-bypass-and-skill-4-micro-mode)
- [Rule: Component and Client Module Folderization Threshold Index [sr-component-folderization]](#rule-component-and-client-module-folderization-threshold-index)
- [Rule: Component File Folderization Threshold [sr-component-file-threshold]](#rule-component-file-folderization-threshold)
- [Rule: Transport Client Module Threshold [sr-client-module-threshold]](#rule-transport-client-module-threshold)
- [Rule: Folder Structure for a Folderized Component [sr-component-folder-structure]](#rule-folder-structure-for-a-folderized-component)
- [Rule: Naming and Exports Inside Folderized Components [sr-component-folder-exports]](#rule-naming-and-exports-inside-folderized-components)
- [Rule: Promotion and Demotion for Component Helpers [sr-component-helper-promotion]](#rule-promotion-and-demotion-for-component-helpers)
- [Rule: Folderization Must Not Create a New Home [sr-folderization-no-new-home]](#rule-folderization-must-not-create-a-new-home)
- [Rule: Layout and Shell Ownership Decision [sr-layout-shell-placement]](#rule-layout-and-shell-ownership-decision)
- [Rule: Layout and Shell Subfolder Policy [sr-layout-shell-subfolder-policy]](#rule-layout-and-shell-subfolder-policy)
- [Rule: `className` Support Policy [sr-ui-classname-support]](#rule-classname-support-policy)
- [Rule: `aria-label` and Accessible Name Policy [sr-a11y-aria-label]](#rule-aria-label-and-accessible-name-policy)
- [Rule: DOM Rendering and Primitive Discipline Index [sr-dom-rendering-and-primitives]](#rule-dom-rendering-and-primitive-discipline-index)
- [Rule: DOM Rendering Boundaries [sr-dom-rendering-boundaries]](#rule-dom-rendering-boundaries)
- [Rule: Primitive Creation Threshold and Raw DOM Usage [sr-primitive-creation-threshold]](#rule-primitive-creation-threshold-and-raw-dom-usage)
- [Rule: Shared UI Domain Discipline [sr-shared-ui-domain-discipline]](#rule-shared-ui-domain-discipline)
- [Rule: Prop Count Caps and Escalation Actions [sr-prop-count-caps]](#rule-prop-count-caps-and-escalation-actions)
- [Rule: Mega-File Triage and Extraction Plan Index [sr-mega-file-triage]](#rule-mega-file-triage-and-extraction-plan-index)
- [Rule: Mega-File Trigger and Safety Baseline [sr-mega-file-trigger-safety]](#rule-mega-file-trigger-and-safety-baseline)
- [Rule: Mega-File Extraction Ordering [sr-mega-file-extraction-order]](#rule-mega-file-extraction-ordering)
- [Rule: Mega-File Safety Checks and Output Contract [sr-mega-file-validation-output]](#rule-mega-file-safety-checks-and-output-contract)
- [Rule: Prop Grouping Discipline [sr-prop-grouping-discipline]](#rule-prop-grouping-discipline)
- [Rule: i18n Extraction for User-Facing UI Text [sr-i18n-text-extraction]](#rule-i18n-extraction-for-user-facing-ui-text)
- [Rule: `*Like` and `Maybe<T>` Discipline Index [sr-type-like-maybe]](#rule-like-and-maybet-discipline-index)
- [Rule: `*Like` Boundary Discipline [sr-type-like-boundary]](#rule-like-boundary-discipline)
- [Rule: `Maybe<T>` Semantics Discipline [sr-type-maybe-semantics]](#rule-maybet-semantics-discipline)
- [Rule: Domain Type Integrity [sr-domain-type-integrity]](#rule-domain-type-integrity)
- [Rule: Test Selectors and `aria-label` Usage [sr-tests-aria-label-selectors]](#rule-test-selectors-and-aria-label-usage)
- [Rule: No Duplicate UI Patterns (Composites) [sr-no-duplicate-ui-patterns]](#rule-no-duplicate-ui-patterns-composites)
- [Rule: Browser Side-Effects and Routing Boundary [sr-browser-side-effects-boundary]](#rule-browser-side-effects-and-routing-boundary)
- [Rule: Empty Catch and Swallowed Error Discipline [sr-no-empty-catch]](#rule-empty-catch-and-swallowed-error-discipline)
- [Rule: JSX Logic Density and Handler Extraction [sr-jsx-logic-density]](#rule-jsx-logic-density-and-handler-extraction)
- [Rule: Time and "Now" Semantics in Derived State [sr-time-derived-state]](#rule-time-and-now-semantics-in-derived-state)
- [Rule: Hidden Interactive Controls and Accessibility Contract [sr-hidden-interactive-controls]](#rule-hidden-interactive-controls-and-accessibility-contract)
- [Rule: No Cross-Feature Dependencies [sr-features-no-cross-deps]](#rule-no-cross-feature-dependencies)
- [Rule: Type Assertion Discipline (`as T`) [sr-types-assertion-discipline]](#rule-type-assertion-discipline-as-t)
- [Rule: Double Type Assertion Discipline (`as unknown as T`) [sr-types-double-assertion]](#rule-double-type-assertion-discipline-as-unknown-as-t)
- [Rule: Deep Relative Imports Should Trigger `@/` Alias Suggestion [sr-import-alias-suggestion]](#rule-deep-relative-imports-should-trigger-alias-suggestion)
- [Rule: Umbrella Feature Split and Domain Extraction [sr-feature-split-domain-extraction]](#rule-umbrella-feature-split-and-domain-extraction)
- [Rule: What May Live in `features/<domain>/components/` [sr-feature-components-scope]](#rule-what-may-live-in-featuresdomaincomponents)
- [Rule: No `api/` Inside Features When Canonical API Home Exists [sr-no-feature-api-home]](#rule-no-api-inside-features-when-canonical-api-home-exists)
- [Rule: No `views/` or `*View` in Features [sr-no-feature-views]](#rule-no-views-or-view-in-features)
- [Rule: File Name Length Discipline [sr-filename-length]](#rule-file-name-length-discipline)
- [Rule: Output Mode Resolution and Display Safety [sr-output-mode-resolution]](#rule-output-mode-resolution-and-display-safety)
- [Rule: Prop Drilling Discipline and Escalation [sr-props-drilling-discipline]](#rule-prop-drilling-discipline-and-escalation)
- [Rule: Skill Scope Definition [rid-overview-scope]](#rule-skill-scope-definition-1)
- [Rule: Plan-Driven Implementation [rid-process]](#rule-plan-driven-implementation)
- [Rule: Structured Implementation Output [rid-output]](#rule-structured-implementation-output)
- [Rule: Validation Gate Sequence [rid-validation-gates]](#rule-validation-gate-sequence)
- [Rule: Scope and Churn Caps [rid-scope-governor]](#rule-scope-and-churn-caps)
- [Rule: Context Access and Write Discipline [rid-access-control]](#rule-context-access-and-write-discipline)
- [Rule: Output Mode Selection [rid-output-mode-selection]](#rule-output-mode-selection)
- [Rule: UI Genericity and Anti-Leakage [rid-ui-genericity]](#rule-ui-genericity-and-anti-leakage)
- [Rule: Bottom-Up Flow and Minimal Export Wiring [rid-data-flow-exports]](#rule-bottom-up-flow-and-minimal-export-wiring)
- [Rule: Quick Validation Checklist [rid-quick-validation]](#rule-quick-validation-checklist)
- [Rule: Ambiguity Resolution Strategy [rid-ambiguity-strategy]](#rule-ambiguity-resolution-strategy)
- [Rule: Anti-Chaotic Change Guardrails [rid-chaotic-change-guardrails]](#rule-anti-chaotic-change-guardrails)
- [Rule: Deterministic Defaults and Pause Protocol [rid-pause-defaults-protocol]](#rule-deterministic-defaults-and-pause-protocol-1)
- [Rule: Boundary, Runtime, and Query Correctness [rid-boundary-runtime-query]](#rule-boundary-runtime-and-query-correctness)
- [Rule: Stop and Revise Conditions [rid-stop-conditions]](#rule-stop-and-revise-conditions)
- [Rule: Naming and Discoverability Contract Index [rid-naming-discoverability]](#rule-naming-and-discoverability-contract-index)
- [Rule: File and Export Naming Alignment [rid-file-export-alignment]](#rule-file-and-export-naming-alignment)
- [Rule: Component Role Naming [rid-component-role-naming]](#rule-component-role-naming)
- [Rule: Naming Boundary Hygiene [rid-naming-boundary-hygiene]](#rule-naming-boundary-hygiene)
- [Rule: Hook, Endpoint, and DTO Naming [rid-hook-endpoint-type-naming]](#rule-hook-endpoint-and-dto-naming)
- [Rule: Mandatory Opportunistic Refactoring Consult [rid-refactoring-consult]](#rule-mandatory-opportunistic-refactoring-consult)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-implementation-discipline` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-overview-scope
- sr-overview-nongoals
- sr-constraints
- sr-scope-governor
- sr-governance
- sr-architecture-boundaries
- sr-ownership-naming
- sr-decision-defaults
- sr-output-discipline
- sr-dod-baseline
- sr-planning-reuse
- sr-migration-placement
- sr-fallback-defaults
- sr-implementation-defaults
- sr-layer-contracts
- sr-access-write-control
- sr-file-size-guidance
- sr-architecture-detection-contract
- sr-enforcement-heuristics
- sr-micro-change-bypass
- sr-component-folderization
- sr-component-file-threshold
- sr-client-module-threshold
- sr-component-folder-structure
- sr-component-folder-exports
- sr-component-helper-promotion
- sr-folderization-no-new-home
- sr-layout-shell-placement
- sr-layout-shell-subfolder-policy
- sr-ui-classname-support
- sr-a11y-aria-label
- sr-dom-rendering-and-primitives
- sr-dom-rendering-boundaries
- sr-primitive-creation-threshold
- sr-shared-ui-domain-discipline
- sr-prop-count-caps
- sr-mega-file-triage
- sr-mega-file-trigger-safety
- sr-mega-file-extraction-order
- sr-mega-file-validation-output
- sr-prop-grouping-discipline
- sr-i18n-text-extraction
- sr-type-like-maybe
- sr-type-like-boundary
- sr-type-maybe-semantics
- sr-domain-type-integrity
- sr-tests-aria-label-selectors
- sr-no-duplicate-ui-patterns
- sr-browser-side-effects-boundary
- sr-no-empty-catch
- sr-jsx-logic-density
- sr-time-derived-state
- sr-hidden-interactive-controls
- sr-features-no-cross-deps
- sr-types-assertion-discipline
- sr-types-double-assertion
- sr-import-alias-suggestion
- sr-feature-split-domain-extraction
- sr-feature-components-scope
- sr-no-feature-api-home
- sr-no-feature-views
- sr-filename-length
- sr-output-mode-resolution
- sr-props-drilling-discipline
- rid-overview-scope
- rid-process
- rid-output
- rid-validation-gates
- rid-scope-governor
- rid-access-control
- rid-output-mode-selection
- rid-ui-genericity
- rid-data-flow-exports
- rid-quick-validation
- rid-ambiguity-strategy
- rid-chaotic-change-guardrails
- rid-pause-defaults-protocol
- rid-boundary-runtime-query
- rid-stop-conditions
- rid-naming-discoverability
- rid-file-export-alignment
- rid-component-role-naming
- rid-naming-boundary-hygiene
- rid-hook-endpoint-type-naming
- rid-refactoring-consult

---

# Overview

## Summary

This document defines the authoritative rules for the `react-implementation-discipline` skill.

This skill operates under:
- `react-implementation-discipline` (with mandatory shared baseline policy baked in at build time)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** sr-overview-scope  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared baseline governance and scope constraints explicit.

### Requirement

- The skill must operate only within its defined responsibility.
- The skill must not perform responsibilities assigned to other skills.
- The skill must not reinterpret or override policy without explicit approval.
- The shared baseline must apply uniformly to:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`
- The production execution skill set for this initiative is fixed to those four
  skills; the shared baseline policy is not a production execution skill.
- Shared policy/config updates must not be modeled as new execution skills.
- Document precedence must remain deterministic:
  - `specs/001-agent-policy-v1/master_spec.md` is authoritative.
  - Supporting policy docs may fill non-conflicting open details only.
- The shared baseline must explicitly govern:
  - Architecture/dependency boundaries.
  - Deterministic defaults and pause behavior.
  - Scope-governor limits and expansion protocol.
  - Output consistency for planning and implementation.
  - Ownership/naming conventions and completion checks.

### Forbidden

- Expanding scope beyond the Scope Governor without explicit override.
- Introducing implicit changes to repository structure.
- Creating competing policy sources that conflict with shared baseline precedence.
- Adding new production execution skills without explicit scope/constitution
  update.

---

## Rule: Baseline Non-goals
**Rule ID:** sr-overview-nongoals  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents policy drift into implementation-specific prescriptions.

### Requirement

- Shared policy must define constraints and governance, not implementation
  recipes.
- Shared policy must not implicitly change through examples, migration behavior,
  or downstream reinterpretation.
- Downstream skills may add local guidance only when it does not conflict with
  shared mandatory rules.

### Forbidden

- Treating examples as policy overrides.
- Introducing stack/framework mandates as shared-policy requirements without
  explicit spec approval.

### Notes

- If uncertainty affects governance decisions, pause and request clarification.

---

# Policy Constraints

## Summary
Defines non-negotiable scope and cap controls for downstream skill work.

---

## Rule: Minimal Scope Enforcement
**Rule ID:** sr-constraints  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents uncontrolled scope expansion and dependency creep.

### Requirement

- Changes must stay within the requested feature scope.
- New top-level folders must not be added without explicit approval.
- New dependencies must not be added without explicit approval.
- `pre_approved_collisions` must exist only in shared baseline header and be
  empty unless explicitly approved in a future version.
- When work appears to exceed scope caps, deliver the smallest viable in-cap
  result and provide a structured follow-up scope list.

### Forbidden

- Silent expansion of scope.
- Introducing unapproved dependencies or repositories.
- Defining downstream-local collision registries.
- Mixing structural migration moves with feature behavior work unless explicitly
  requested.

### Notes

- If a requirement cannot be met without expanding scope, pause and request
  approval.

---

## Rule: Scope Governor Hard Defaults
**Rule ID:** sr-scope-governor  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Controls churn and keeps delivery bounded.

### Requirement

- Hard defaults (unless explicitly overridden):
  - Max files touched: `8`
  - Max new files: `4`
  - Max moved/renamed files: `0` (unless migration mode explicitly enabled)
  - Max new dependencies: `0`
  - Max new top-level folders: `0`
- When caps are exceeded, provide a structured scope expansion request with
  concrete `why` and `would_touch` fields, while still delivering an in-cap
  result.

### Forbidden

- Exceeding hard defaults silently.
- Expanding dependency or top-level folder scope without explicit approval.

---

# Governance

## Summary
Sets expectations for compliance, documentation, and review.

---

## Rule: Governance Compliance
**Rule ID:** sr-governance  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures policies are enforced consistently across changes.

### Requirement

- All changes must be validated against the constitution and project specs.
- Documentation updates must keep guidance accurate and current.
- Generated artifacts must be produced by the official build process.
- Shared-policy rule changes must include an explicit policy version increment
  with documented rationale.
- Shared-policy exception approvals must be performed by repo maintainers only.
- Exception records must include rationale and conflicting rule reference.
- Exception records must not include expiry metadata; approved exceptions remain
  active until explicitly revoked or superseded by newer policy version.
- `pre_approved_collisions` must be managed only in the shared baseline header.
- Policy behavior must not be changed implicitly via examples, migration
  behavior, or downstream reinterpretation.

### Forbidden

- Bypassing validation requirements.
- Manual edits to generated artifacts.
- Approving shared-policy exceptions from non-maintainer roles.
- Adding expiry fields to shared-policy exception records.
- Defining downstream-local `pre_approved_collisions` sources.
- Changing shared-policy semantics without a version and rationale update.

### Notes

- If governance rules conflict, the constitution takes precedence.

---

# Architecture Boundaries

## Summary
Defines shared architecture and dependency-boundary rules all downstream skills
must enforce.

---

## Rule: Architecture and Dependency Boundaries
**Rule ID:** sr-architecture-boundaries  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills enforce one consistent
architecture and import-boundary model.

### Requirement

- The following non-negotiables must be enforced:
  - Do not create new folders unless explicitly allowed by policy or user
    instruction.
  - Never place domain business logic in `ui/**` or `api/**`.
  - Never fetch outside the canonical endpoint layer
    (`api/endpoints/**` or gravity-equivalent API home).
  - Prefer small, composable changes over large refactors.
  - Avoid `shared/` or `common/` dumping-ground patterns.
- Dependency direction must remain consistent with the baseline:
  - `ui/**` must not import `features/**`, `api/**`, `store/**`, or `pages/**`.
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`.
  - `features/**` must not import `pages/**`.
  - `pages/**` must not import canonical endpoint modules directly.
  - `hooks/**` must not import `features/**`, `pages/**`, or `store/**`; imports
    from `api/**` are allowed only when documented in exactly one canonical
    policy location.
- The canonical endpoint layer must be determined once per task by Architecture
  Detection and reused consistently in boundary checks for that task.
- If a path alias exists (for example `@/`), all boundary rules apply equally to
  alias imports and raw `src/**` imports.
- Generic fetch-hook exceptions are valid only when documented in exactly one
  canonical policy location; multiple policy locations invalidate the exception.
- No second home may be introduced for the same concern (UI/API/store/routing)
  unless explicit migration scope is approved.

### Forbidden

- Competing homes for the same concern in the same scope.
- Domain terms in reusable `ui/**` component file names.
- DTO-to-domain mapping in `api/**`.

### Notes

- Architecture Detection owns gravity decisions; downstream skills inherit those
  decisions unless a valid pause is triggered.

---

# Ownership and Naming

## Summary
Defines shared ownership boundaries and naming conventions for downstream skill
specifications.

---

## Rule: Ownership and Naming Contract
**Rule ID:** sr-ownership-naming  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps responsibility boundaries and naming deterministic across
all downstream specs.

### Requirement

- `pages/**` remain thin route orchestrators.
- `features/**` own domain behavior, feature hooks, and domain mapping.
- `ui/primitives/**` and `ui/composites/**` stay domain-agnostic.
- `api/**` stays transport-only and returns DTOs or normalized errors.
- `store/**` is global client-state only; do not mirror server-state without
  explicit justification.
- Naming conventions must remain deterministic:
  - `*Page.tsx` for pages.
  - `*Section.tsx` for feature sections.
  - `use*.ts` for hooks.
  - `*.dto.ts` and `*Dto` for DTOs.
- Naming and exports must remain searchable and consistent:
  - Prefer matching file/export names.
  - Prefer named exports unless framework conventions require default exports.
  - Avoid introducing barrel files unless the local area already uses them
    consistently.

### Forbidden

- Domain mode flags in shared composites.
- Introducing new naming schemes when local patterns are clear.
- API transport concerns in UI or generic hook layers.
- Mixed synonym vocabularies for the same role in the same scope (for example
  mixing `Page` and `Route` naming without existing convention).

---

# Decision Defaults and Pause Rules

## Summary
Defines deterministic default behavior and high-impact clarification triggers.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** sr-decision-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Reduces unnecessary clarification loops while protecting
high-impact structural decisions.

### Requirement

- Use deterministic defaults for non-structural ambiguity.
- Pause only when both are true:
  - `confidence < 0.7`
  - `impact = structural`
- Structural impact includes top-level structure changes, competing concern
  homes, dependency-direction changes, cross-layer moves, global state strategy
  changes, or scope-cap violations.
- When pausing, use clean pause protocol:
  - State ambiguity clearly.
  - Present 2-3 options.
  - Recommend a default.
  - Wait for confirmation.
- Use `balanced` pause mode by default unless explicitly configured otherwise.
- Do not pause for minor decisions when a safe default exists.

### Forbidden

- Proceeding on structural ambiguity without pause.
- Repeated low-value questions when a safe deterministic default exists.
- Vague, non-blocking, or style-only clarification questions that do not change
  structural outcomes.

---

# Output and Planning Discipline

## Summary
Defines required output structure for planning and implementation guidance.

---

## Rule: Output and Planning Discipline
**Rule ID:** sr-output-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps downstream planning and implementation outputs consistent,
compact, and reviewable.

### Requirement

- Planning outputs must include:
  - File touch plan (`Create`/`Update`/`Reuse` with paths).
  - Layer justification.
  - Reuse decision notes (`reuse as-is`, `updated`, `new`).
  - A short decision explanation that states detected architecture signals and
    chosen direction.
- Planning outputs must use a machine-readable JSON object with:
  - `output_mode` (`human|agent`)
  - `presentation.user_markdown` (prettified summary of the payload)
  - `notes[]` limited to 5 items
- Resolve `output_mode` precedence and display behavior via
  `sr-output-mode-resolution`.
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.
- Implementation output must:
  - Use changed snippets for updated files by default.
  - Use unified diff when edits are scattered across non-adjacent regions.
  - Use full content for new files.

### Forbidden

- Full existing-file dumps unless explicitly requested or file is small and
  fully changed.
- Unstructured narrative-only planning outputs.
- Omitting `presentation.user_markdown` from output payloads.
- Selecting `output_mode=agent` by habit/default when a human-invoked run does
  not explicitly request machine-readable output.

---

# Completion and Quality Baseline

## Summary
Defines mandatory completion checks and runtime-safety expectations inherited by
all downstream skills.

---

## Rule: Completion and Quality Baseline
**Rule ID:** sr-dod-baseline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures every downstream skill validates critical correctness and
safety gates before completion.

### Requirement

- Boundary audit must pass:
  - No forbidden imports by layer.
  - No fetching outside canonical endpoint layer.
  - `api/**` remains transport-only.
- Runtime safety baseline:
  - Loading state handling when server data is involved.
  - Error state handling.
  - Empty state handling for list/collection views.
  - No unhandled promise rejections.
- Minimal churn baseline:
  - Touch only planned files unless deviations are explained.
  - Avoid unrelated refactors.
- If tooling exists, applicable checks must pass (`tsc`, lint, and existing test
  suites relevant to changed behavior).
- If TanStack Query (or equivalent) is used, query correctness checks must
  ensure stable keys, intended invalidation, and justified server-state/store
  boundaries.
- Tests are required only when a suite already exists and changed behavior falls
  within that suite's scope.

### Forbidden

- Marking work done without boundary/safety checks.
- Treating optional quality checks as mandatory when repository tooling does not
  exist.
- Claiming compliance while skipping available type/lint checks in repositories
  that provide those checks.

---

# Planning and Reuse Workflow

## Summary
Defines required pre-implementation workflow and reuse decision discipline for
selected downstream skills.

---

## Rule: Planning and Reuse Workflow
**Rule ID:** sr-planning-reuse  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents ad hoc implementation choices and improves consistency
across downstream planning outputs.

### Requirement

- Before implementation, downstream skills must:
  - Classify request type (feature, route/page, API integration, refactor, bug
    fix).
  - Choose a domain owner.
  - Map affected layers.
  - Identify expected data sources.
  - Decide server/local/global state ownership.
  - Decide UI reuse shape (reuse/update/new).
  - List planned file touches.
- For `micro_change` runs that satisfy `sr-micro-change-bypass`, the full
  pre-implementation planning sequence may be abbreviated and handled directly
  by Skill 4 micro mode.
- Existing implementations must be searched before creating new modules in:
  - Feature/domain modules.
  - UI primitives/composites.
  - API endpoints/DTOs.
  - State patterns.
- Reuse decisions must follow the ladder:
  - Reuse as-is.
  - Update existing (small, clean extension).
  - Create new (when reuse would leak domain concerns or force excessive
    complexity).
- For shared composites, if reuse requires too many domain-specific options,
  prefer feature-level duplication instead of adding domain mode flags.
- Reuse evaluation should weigh complexity cost, coupling risk, divergence
  probability, and locality benefit.

### Forbidden

- Creating new modules without checking existing alternatives.
- Skipping explicit reuse/update/new decision capture.
- Forcing domain behavior into reusable shared composites.

---

# Migration and Placement Strategy

## Summary
Defines migration-aware placement rules and strategy selection constraints.

---

## Rule: Migration and Placement Strategy
**Rule ID:** sr-migration-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents mixed-architecture drift and keeps placement decisions
deterministic in legacy or evolving repositories.

### Requirement

- Do not introduce parallel architectures for the same concern.
- Choose a strategy per change:
  - Follow existing.
  - Introduce target structure at boundaries.
  - Migrate as you touch (explicit migration scope only).
- Default balanced behavior:
  - No moves/renames unless explicitly enabled.
  - Introduce new homes only when isolated and non-competing.
  - Keep feature behavior and structural migration separate unless explicitly
    requested.
- Gravity decisions from Architecture Detection are inherited by downstream
  skills and must not be recomputed unless pause/escalation resolves a conflict.
- If move mode is explicitly enabled, keep moves small and complete import
  updates in the same change.

### Forbidden

- Two active homes for the same concern in one scope.
- Mixing broad structural migration with unrelated behavior changes.
- Recomputing gravity independently in downstream skills without escalation.

---

# Fallback Technology Defaults

## Summary
Defines shared fallback defaults used only when repository conventions are
missing or ambiguous.

---

## Rule: Fallback Technology Defaults
**Rule ID:** sr-fallback-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic cross-skill defaults while honoring
existing repository gravity first.

### Requirement

- Existing repository stack/conventions take precedence over fallback defaults.
- If no clear convention exists, defaults are:
  - Server-state: TanStack Query; keep transport in `api/endpoints/**`.
  - Client-state: local-first; global store only when truly global.
  - Routing: React Router for plain React; framework-native routing when
    framework is detected.
  - Styling: follow existing; Tailwind default only for greenfield.
  - Forms: react-hook-form.
  - Validation: Zod at boundaries (DTO/form), with domain schema ownership in
    feature domain layers.
  - HTTP client: native `fetch` via shared wrapper; normalized `ApiError`;
    conservative retry posture.
  - Build tool: Vite for greenfield plain React unless existing conventions say
    otherwise.
  - Date/localization: native `Date` and `Intl` unless domain needs justify
    more.
  - Identifier strategy: string IDs by default.

### Forbidden

- Introducing competing stack choices mid-repository without explicit request.
- Mirroring server-state into global store without explicit justification.

---

# Implementation Defaults

## Summary
Defines shared implementation posture defaults inherited by downstream skills.

---

## Rule: Implementation Defaults
**Rule ID:** sr-implementation-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Aligns downstream implementation behavior on quality, environment
access, logging, and tooling posture.

### Requirement

- Feature flags must be centralized in `config/featureFlags.ts` and evaluated at
  composition boundaries.
- Reusable UI components should support class extension patterns consistently
  (for example `className` with shared merge helper where applicable).
- Accessibility baseline is required for reusable UI.
- Performance posture is readability-first; memoization optimizations require
  concrete justification.
- Repository topology must be detected (single-app vs monorepo) and rules
  applied per app root when monorepo signals exist.
- Module-boundary tooling posture is spec-first:
  - Start with import-boundary review checks.
  - Add lint/tool enforcement only when explicitly requested as dedicated
    hardening scope.
  - Mirror alias paths in boundary lint rules when aliases are present.
- Environment access must be centralized through `config/env.ts`.
- Logging should use shared logger abstractions; avoid committed debug logging.
- Codegen is opt-in only; default to handwritten endpoint/DTO ownership.
- Storybook/docs are optional and should follow existing setup when present.

### Forbidden

- Direct environment reads outside `config/env.ts`.
- Committing `console.log`/`console.debug` in production code paths.
- Introducing codegen or docs platforms as implicit scope expansion.
- Adding boundary/tooling stacks implicitly in routine feature scope.

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# Access and Write Control

## Summary
Defines shared access assumptions and write-control behavior for downstream
skills.

---

## Rule: Access and Write Control
**Rule ID:** sr-access-write-control  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps structural decisions grounded in repository signals and
maintains controlled, reviewable changes.

### Requirement

- Detection/reuse/planning stages require repository read/search access.
- Minimum capabilities include:
  - Listing relevant file trees.
  - Searching code patterns.
  - Reading source/config files on demand.
- If direct access is unavailable, require a fallback context bundle with file
  tree, package/tooling config, router entry, API home, and representative
  module examples.
- Default write posture must be controlled and reviewable.
- If direct writes are enabled, scope-governor and minimal-churn rules still
  apply.
- Architecture/specification document edits require explicit request and must be
  treated as dedicated documentation scope.

### Forbidden

- Structural placement decisions without repository signal checks.
- Silent broad writes that bypass scope and review controls.
- Auto-editing architecture/spec documents during regular implementation work.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Architecture Detection Contract

## Summary
Defines the shared contract that downstream skills must inherit from
architecture-detection outputs, including bootstrap behavior.

---

## Rule: Architecture Detection Output and Bootstrap Contract
**Rule ID:** sr-architecture-detection-contract  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills consume one consistent
architecture-detection result and bootstrap behavior.

### Requirement

- Architecture detection output must include the shared structural signals:
  - `routing.type`
  - `ui.home`
  - `api.home` (canonical endpoint layer for boundary checks)
  - `domain.organization`
  - `gravity_map`
  - `alignment_score`
  - `strategy`
  - `notes[]`
- Gravity decisions are owned by architecture detection and reused by all
  downstream skills within the same task.
- Downstream skills must not recompute/override gravity unless a structural
  pause is triggered and explicitly resolved.
- Bootstrap behavior applies only when no clear concern homes exist:
  - Allow folder creation only from the canonical set:
    `pages/`, `features/`, `ui/primitives/`, `ui/composites/`, `api/client/`,
    `api/dto/`, `api/endpoints/`, `core/`, `lib/`, `hooks/`, `config/`
  - `store/` may be created only when truly global client-state is required.
  - Prefer minimal bootstrap: create only folders needed for the current task.

### Forbidden

- Consuming inconsistent architecture-detection outputs across downstream skills
  for the same task.
- Creating speculative bootstrap folders not needed by the current task.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# Micro-change Bypass

## Summary
Defines deterministic conditions for bypassing Skills 1-3 and invoking
implementation discipline directly in micro mode.

---

## Rule: Micro-change Bypass and Skill 4 Micro Mode
**Rule ID:** sr-micro-change-bypass  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Allows low-risk behavior-preserving refactors to stay fast while
still enforcing implementation discipline and boundary checks.

### Requirement

- A request may be classified as `micro_change` only when all are true:
  - behavior-preserving refactor intent is explicit.
  - expected touched files are `<= 2`.
  - no new files are required.
  - no move/rename operations are required.
  - no new endpoint/hook/composite homes are introduced.
  - no routing changes are required.
- If `micro_change` is confirmed:
  - Skills 1-3 may be bypassed.
  - Skill 4 may be used directly in `micro mode`.
  - As an alternative, an external checklist-only path may be used when Skill 4
    is not selected.
- Skill 4 `micro mode` must still enforce:
  - boundary audits
  - minimal churn
  - validation/quality checks and explicit check results
  - structured output discipline
- If any `micro_change` condition cannot be confirmed, use the normal staged
  pipeline instead of bypass.

### Forbidden

- Using micro-change bypass for feature additions or structural migrations.
- Skipping boundary/quality validation because the change is small.
- Treating uncertain scope as micro-change without explicit evidence.

---

# Component Folderization

## Summary
Defines when components and transport client modules should remain single-file
versus decomposed/folderized, and how extracted modules must be structured and
named.

---

## Rule: Component and Client Module Folderization Threshold Index
**Rule ID:** sr-component-folderization  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Preserves a stable entrypoint while delegating to focused
component and client-threshold rules.

### Requirement

- When this rule is in scope, enforce both:
  - `sr-component-file-threshold`,
  - `sr-client-module-threshold`.

### Forbidden

- Treating this index rule as sufficient without enforcing the referenced
  threshold rules.

---

## Rule: Component File Folderization Threshold
**Rule ID:** sr-component-file-threshold  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps components maintainable by triggering folderization when
size/responsibility thresholds are exceeded.

### Requirement

- Keep a component as a single file when all are true:
  - file is about `<= 200` lines and has one clear responsibility,
  - helpers are small and render-support only,
  - there are at most two closely related internal subcomponents.
- Folderize component modules when any is true:
  1. file is about `> 250-300` lines and splitting reduces responsibilities,
  2. component contains three or more meaningful internal subcomponents,
  3. non-trivial local logic should be isolated (mapping/formatting, keyboard
     handling, complex derived state),
  4. it has component-scoped assets (styles/icons/constants),
  5. it is reused broadly and needs a stable module boundary.
- Hard rule:
  - if a single component file exceeds `400` lines, folderization is required
    unless explicitly justified in output notes and/or review metadata.
- Quick heuristic:
  - folderize when file has multiple responsibilities and is above about
    `300` lines and still growing.

### Forbidden

- Keeping oversized multi-responsibility component files as single files without
  explicit justification.
- Treating component folderization as optional after the hard threshold is
  crossed.

---

## Rule: Transport Client Module Threshold
**Rule ID:** sr-client-module-threshold  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents mega transport clients by keeping endpoint orchestration
out of shared client foundations.

### Requirement

- Keep a transport client module as a single file when all are true:
  - it stays focused on shared transport concerns (request wrapper, auth/header
    wiring, transport error normalization),
  - endpoint/domain-specific call orchestration is not embedded in client file,
  - file is reasonably small (about `<= 250` lines).
- Decompose transport client logic when any is true:
  1. canonical client file grows to about `> 250-300` lines and mixes concerns,
  2. endpoint-specific URLs/methods/payload shaping accumulate in client file,
  3. multiple domain endpoint calls are orchestrated from one client file.
- Hard rule:
  - if a transport client file (for example `api/client/client.ts`) exceeds
    `400` lines, extraction is required unless explicitly justified in output
    notes and/or review metadata.
- Expected extraction target:
  - endpoint/domain call functions must be extracted to `api/endpoints/**` or
    gravity-equivalent canonical endpoint home,
  - `api/client/**` remains a thin transport foundation (request wrapper,
    auth/header wiring, retry policy, normalized transport errors).

### Forbidden

- Keeping endpoint-specific call orchestration in mega transport client files.
- Treating transport extraction as optional after hard threshold exceedance.

---

## Rule: Folder Structure for a Folderized Component
**Rule ID:** sr-component-folder-structure  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents random folder soup and keeps discovery/search
predictable.

### Requirement

- Default required structure for folderized component `ProjectSelector`:

```text
ProjectSelector/
  ProjectSelector.tsx
  index.ts            (optional; only when local area already uses barrels)
```

- Allowed colocated files must be component-scoped only:
  - `ProjectSelector.utils.ts` (component-local pure helpers)
  - `ProjectSelector.types.ts` (component-local types)
  - `ProjectSelector.constants.ts` (component-local constants)
  - `ProjectSelector.styles.module.css` (or local styling per repo convention)
  - `ProjectSelector.test.tsx` (component tests)
- `components/` subfolder is allowed only when module size/complexity justifies
  it and subcomponents remain component-local.

### Forbidden

- Adding transport/backend access layers (`api/`) inside a component folder.
- Adding cross-domain generic utility buckets (for example `utils/` junk drawer
  subfolders).
- Placing shared primitives inside component-owned folders (shared primitives
  belong in `ui/primitives/**`).

---

## Rule: Naming and Exports Inside Folderized Components
**Rule ID:** sr-component-folder-exports  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps imports stable and grep-friendly.

### Requirement

- Main component file must match folder name and primary export:
  - `ProjectSelector/ProjectSelector.tsx` exports `ProjectSelector`.
- Import style:
  - prefer explicit import path to main file, or
  - folder import only when `index.ts` exists and local area already uses
    barrels.
- Subcomponents should carry module prefix (for example
  `ProjectSelectorItem`, `ProjectSelectorDropdown`) for searchability.

### Forbidden

- Random unprefixed subcomponent names like `Item.tsx` and `Dropdown.tsx`.
- Introducing new barrel patterns in areas that do not already use them.

---

## Rule: Promotion and Demotion for Component Helpers
**Rule ID:** sr-component-helper-promotion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents leaking component-specific helpers into global utility
layers.

### Requirement

- Move helper from component folder to `lib/**` only when both are true:
  - helper is reused by two or more domains/features
  - helper is pure (no React imports and no feature/domain knowledge)
- Move helper to `features/<domain>/domain/**` when helper encodes domain
  behavior, even if used across multiple files within that feature.
- Keep component-local helpers colocated when reuse and purity thresholds for
  promotion are not met.

### Forbidden

- Promoting helpers to `lib/**` solely because the source component file is
  large.
- Promoting domain-aware helpers to `lib/**`.

---

## Rule: Folderization Must Not Create a New Home
**Rule ID:** sr-folderization-no-new-home  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents second-architecture drift.

### Requirement

- Folderization must stay inside existing gravity home:
  - if component is under `src/components/**`, folderized module stays there
  - if component is feature-owned, folderized module stays in that feature path
- Folderization must preserve current concern ownership and import-boundary
  rules.
- Relocation across homes during folderization is allowed only in explicit
  migration mode with clear boundary scope.

### Forbidden

- Using folderization as justification to create a new top-level `ui/`,
  `shared/`, or other competing concern home.
- Silent home relocation under the guise of formatting/refactor-only work.

---

# Layout and Shell Placement

## Summary
Defines deterministic placement for layout/shell components and prevents
parallel layout homes.

---

## Rule: Layout and Shell Ownership Decision
**Rule ID:** sr-layout-shell-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Removes ambiguity between `ui/primitives`, `ui/composites`, and
`features/<domain>/sections` for layout-like components.

### Requirement

- Place in `ui/primitives/**` only when the component is a low-level building
  block with minimal structure/behavior.
  - Typical primitives: `Stack`, `Box`, `Spacer`, `Grid`, thin `Container`.
- Place in `ui/composites/**` when the component composes multiple primitives
  into a reusable UI pattern.
  - Typical composites: `PageShell`, `ModalShell`, `PanelShell`,
    `MasterDetailLayout`, `AppShell`, `SidebarLayout`, `CardLayout`,
    `TableShell`, `EmptyStatePanel`.
- Place in `features/<domain>/sections/**` when the layout is domain-owned
  composition, even if it looks like a generic layout.
  - Example: project-specific layout section with domain navigation, filters,
    or domain-state behavior.
- Fast decision rule:
  - minimal low-level building block -> primitive
  - reusable composed pattern -> composite
  - domain-owned composition/behavior -> feature section
- This rule applies to all skills and must be enforced most strongly during
  execution in `react-implementation-discipline`.

### Forbidden

- Treating reusable shells/layout patterns as primitives.
- Treating domain-owned layout composition as shared composite by default.
- Using unclear "looks like layout" labeling to bypass domain ownership checks.

### Notes

- If ownership is ambiguous and impact is structural, use shared pause protocol
  thresholds.

---

## Rule: Layout and Shell Subfolder Policy
**Rule ID:** sr-layout-shell-subfolder-policy  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents creation of competing layout homes while allowing
bounded categorization inside composites when needed.

### Requirement

- Default policy: do not create dedicated top-level layout homes for
  `layouts/` or `shells/`.
- If categorization is needed, keep it inside existing composite home:
  - `src/ui/composites/layouts/*`
  - `src/ui/composites/shells/*`
- Allow this subfolder split only when all are true:
  - composite catalog is large/noisy (for example around ten or more layout/shell
    components)
  - repository already uses category subfolders inside `ui/**`
  - split does not create a competing second home
- Folderization/categorization must preserve existing gravity home and
  one-home-per-concern discipline.

### Forbidden

- Creating a parallel top-level home like `src/ui/layouts/*` or
  `src/ui/shells/*` by default.
- Using category split to bypass migration-scope rules.
- Introducing both `ui/composites/*` and new top-level `ui/layouts/*` as active
  homes for the same concern.

---

# UI Extension and Accessibility Policies

## Summary
Defines shared UI `className` extensibility and accessible-name rules for
placement, reuse, and implementation stages.

---

## Rule: `className` Support Policy
**Rule ID:** sr-ui-classname-support  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared UI extensible without forcing styling props
everywhere or creating style-override soup.

### Requirement

- UI primitives (`ui/primitives/**`) MUST accept `className?: string` when they
  render a DOM element.
- UI composites (`ui/composites/**`) SHOULD accept `className?: string` for the
  outer wrapper/root element when the composite renders a stable wrapper.
- If the repo uses class merging (Tailwind/CSS utility patterns), prefer one
  shared merge helper (for example `lib/cn.ts`) and reuse it consistently; do
  not invent per-component merge logic.
- Components that do not render DOM (pure logic, context providers, utility
  wrappers) MUST NOT accept `className` unless they explicitly forward it to a
  single DOM root.
- Feature sections (`features/*/sections/**`) MAY accept `className` only when:
  - the section is used in multiple page layouts requiring wrapper styling
    control, or
  - the section is explicitly designed to be composed as a layout block.
  Otherwise, styling should be handled inside the section or by composing
  wrappers in `pages/**`.
- Pages (`pages/**`) SHOULD NOT accept `className` props; pages are route
  orchestrators and styling is internal composition.

### Forbidden

- Adding many style props (`headerClassName`, `footerClassName`, `rowClassName`,
  etc.) by default.
  - Add slot-level class props only when there are multiple real call sites and
    the composite has stable, intentional slots.
- Forcing `className` on every component for consistency.
- Introducing a second styling extension pattern in the same repo (for example
  mixing `className`, `styles`, and `sx`) unless the repo already has an
  explicit multi-system policy.

### Notes

- If a feature section frequently needs external styling overrides, treat it as
  a signal to:
  - extract a reusable UI composite, or
  - introduce a dedicated wrapper/layout component in the composing layer.

---

## Rule: `aria-label` and Accessible Name Policy
**Rule ID:** sr-a11y-aria-label  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents noisy or incorrect ARIA usage while ensuring
interactive controls always have an accessible name.

### Requirement

- Any interactive control (button/link/input/custom widget) MUST have an
  accessible name, provided by one of:
  - visible text content, or
  - `<label>` + `for` association (or equivalent), or
  - `aria-labelledby`, or
  - `aria-label` as fallback when no visible label exists.
- Use `aria-label` only when there is no appropriate visible label (common
  case: icon-only buttons/links).
- Do not add `aria-label` redundantly when a clear visible label already
  exists.
- Decorative icons/elements MUST be marked appropriately (`aria-hidden="true"`
  or equivalent) when they do not convey meaning.
- UI primitives that render interactive elements SHOULD expose the minimal props
  needed to ensure accessible naming:
  - `aria-label`, `aria-labelledby`, and label/description wiring as
    pass-through attributes where relevant.
- UI composites SHOULD pass through accessibility props to the underlying
  interactive primitives and MUST NOT hardcode domain-specific labels.

### Forbidden

- Blanket-adding `aria-label` to every component or every element.
- Adding `aria-label` to non-interactive wrapper elements solely for
  accessibility.
- Overriding an existing correct accessible name with a worse `aria-label` (for
  example generic labels such as `Button`).
- Encoding domain semantics in shared UI via fixed ARIA labels; domain meaning
  belongs in feature-owned layers.

### Notes

- Prefer `aria-labelledby` when there is already visible on-screen text that
  should be used as the accessible name.
- If a control meaning depends on state (`Mute` vs `Unmute`), the accessible
  name should reflect the current action/state.

---

# DOM Rendering and Primitive Discipline

## Summary
Defines rendering boundaries, primitive-creation thresholds, and shared-UI
domain discipline as separate concerns.

---

## Rule: DOM Rendering and Primitive Discipline Index
**Rule ID:** sr-dom-rendering-and-primitives  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves backward-compatible entrypoint while delegating
enforcement to narrowly scoped rules.

### Requirement

- When this rule is in scope, follow all of:
  - `sr-dom-rendering-boundaries`,
  - `sr-primitive-creation-threshold`,
  - `sr-shared-ui-domain-discipline`.

### Forbidden

- Treating this index rule as sufficient without enforcing the referenced
  detailed rules.

---

## Rule: DOM Rendering Boundaries
**Rule ID:** sr-dom-rendering-boundaries  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents JSX/DOM leakage into logic/data layers.

### Requirement

- Only these layers may render JSX/DOM:
  - `ui/primitives/**`
  - `ui/composites/**`
  - `features/*/sections/**`
  - `pages/**`
  - `core/**` (layout composition only, such as app shell/providers)
- These layers must remain DOM-free:
  - `api/**`
  - `lib/**`
  - `store/**`
  - `hooks/**`
  - `config/**`
- Hooks must return state/functions only and must not render JSX.

### Forbidden

- Rendering JSX from `api/**`, `lib/**`, `store/**`, `hooks/**`, or `config/**`.

---

## Rule: Primitive Creation Threshold and Raw DOM Usage
**Rule ID:** sr-primitive-creation-threshold  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps raw DOM use pragmatic while preventing repeated semantic
reimplementation.

### Requirement

- Prefer existing reusable primitives (for example `Button`, `Input`, `Card`)
  before adding repeated raw semantic elements.
- Raw HTML is allowed when any is true:
  - element is structural/layout-only (`div`, `section`, `span`, etc.),
  - no suitable primitive exists,
  - usage is one-off and not expected to repeat,
  - usage is highly domain-specific and should not leak into `ui/**`.
- Create a primitive in `ui/primitives/**` when any is true:
  - the same semantic element pattern appears across 2+ features/domains,
  - a shared composite needs it as a building block,
  - 2+ near-identical implementations copy style/behavior,
  - accessibility/keyboard/focus/label wiring is repeatedly reimplemented,
  - it is a core UI building block (for example button/input/select/checkbox/
    radio/textarea/link/card/modal/tabs/badge/tooltip base),
  - repeated styling tokens/classes are used to enforce consistency.

### Forbidden

- Duplicating semantic elements already represented by existing primitives.
- Bypassing existing primitives with repeated ad-hoc raw semantic controls.

---

## Rule: Shared UI Domain Discipline
**Rule ID:** sr-shared-ui-domain-discipline  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared UI reusable and prevents domain/transport leakage.

### Requirement

- Components in `ui/**` may render valid HTML but must remain domain-agnostic.
- Shared UI must not import from `features/**`.
- Shared UI owns:
  - semantic correctness,
  - accessibility wiring,
  - basic visual state presentation (disabled/loading/selected).
- Shared UI does not own:
  - business logic,
  - domain rules,
  - feature semantics.
- When invalid placement is detected, refactoring should:
  1. move JSX into valid presentation layers,
  2. split logic from markup (`domain/lib` for logic, `sections/ui` for markup),
  3. prefer behavior-preserving extraction within active scope.

### Forbidden

- Hardcoding domain semantics in shared `ui/**`.
- Using shared UI as a transport or business-logic owner.
- Introducing new top-level UI homes while remediating domain leakage.

---

# Prop Count Caps

## Summary
Defines soft prop-surface caps and mandatory escalation actions to prevent prop
soup and abstraction creep.

---

## Rule: Prop Count Caps and Escalation Actions
**Rule ID:** sr-prop-count-caps  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents prop soup and abstraction creep by enforcing
responsibility boundaries and preferring composition/wrappers over flag
matrices.

### Requirement

- Soft prop caps by layer/type (not hard compile failures):
  - `ui/primitives/**`: max 10 component-defined props
    - excludes native passthrough props from
      `ComponentPropsWithoutRef<...>`-style extension.
  - `ui/composites/**`: max 12 props.
  - `features/*/components/**`: max 12 props.
  - `features/*/sections/**`: max 15 props.
  - `core/**` shells/layout: max 8 props.
  - `pages/**`: max 8 props (prefer near-zero; pages should not be generic
    reusable components).
- When exceeding a cap, choose at least one escalation action and record it in
  planning/refactor metadata:
  1. split by responsibility (extract subcomponents),
  2. replace flags with composition (`children`, slots, render props),
  3. introduce feature-owned wrapper to keep shared UI generic,
  4. group props only when compliant with `sr-prop-grouping-discipline`,
  5. demote from shared UI when domain divergence is the driver.
- Layer-specific escalation constraints:
  - `ui/composites/**` must not exceed cap via domain mode flags
    (`variant="tasks|projects"`, `mode/context` matrices); prefer feature
    wrapper or feature-local duplication.
  - `ui/primitives/**` should remain thin via native passthrough plus minimal
    ergonomic props.
  - `pages/**` should not accumulate prop surfaces; extract section/composite
    instead.

### Forbidden

- Exceeding a cap silently without documenting chosen escalation action.
- Violating `sr-prop-grouping-discipline` (for example domain models hidden in
  grouped objects passed into `ui/**`).
- Growing shared composites through large flag matrices or domain switches.
- Designing one-component-to-rule-them-all APIs that hide unrelated
  responsibilities behind props.

### Notes

- Prop count is a complexity proxy; responsibility boundaries are the core
  signal.
- If temporary cap exceedance is unavoidable, record follow-up refactor scope
  instead of allowing continuing prop-surface growth.

---

# Mega-File Triage and Extraction Plan

## Summary
Defines mandatory triage and extraction sequencing when touched files exceed
safe size/responsibility thresholds.

---

## Rule: Mega-File Triage and Extraction Plan Index
**Rule ID:** sr-mega-file-triage  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves stable entrypoint while delegating to focused triage,
extraction-sequencing, and validation-output rules.

### Requirement

- When this rule is in scope, enforce all of:
  - `sr-mega-file-trigger-safety`,
  - `sr-mega-file-extraction-order`,
  - `sr-mega-file-validation-output`.

### Forbidden

- Treating this index rule as sufficient without enforcing the referenced
  mega-file rules.

---

## Rule: Mega-File Trigger and Safety Baseline
**Rule ID:** sr-mega-file-trigger-safety  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic trigger conditions and behavior-preserving
triage defaults.

### Requirement

- Trigger mega-file triage when any touched file is:
  - over 600 LOC (hard stop threshold), or
  - over 400 LOC with clear multi-responsibility signals, or
  - explicitly flagged as an offender (for example a 1500 LOC component), or
  - below threshold but showing prior extraction pattern with obvious same-pattern
    leftovers.
- Freeze behavior and reduce risk surface:
  - treat work as refactor-only unless user explicitly requests behavior changes,
  - preserve output, props, and side effects by default,
  - plan incremental extraction steps, not a rewrite.
- Establish bounded target:
  - declare `anchor_component` (path + export),
  - declare `extraction_budget` (allowed file touches under caps),
  - declare `end_state_goal` as anchor `<= 250-400` LOC (or `<= 600` when
    explicitly timeboxed),
  - if caps block ideal target, deliver in-cap reduction and include
    `scope_expansion_needed[]`.
- Continue extraction when prior-pattern leftovers exist:
  - dropping below 400/600 is not a stop condition by itself,
  - stop when same-pattern leftovers are exhausted or caps are reached.

### Forbidden

- Treating line-count drop alone as stop condition when same-pattern leftovers
  remain and scope budget allows continued extraction.
- Ignoring declared behavior-preserving default in triage-only runs.

---

## Rule: Mega-File Extraction Ordering
**Rule ID:** sr-mega-file-extraction-order  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps decomposition predictable and low-risk.

### Requirement

- Execute extraction in this exact sequence:
  1. Step A, pure logic first:
     - extract constants, pure helpers, component-local types,
     - promote to `lib/**` only when reused by 2+ domains and pure,
     - promote to `features/<domain>/domain/**` only when domain behavior is
       encoded.
  2. Step B, presentational subcomponents:
     - extract clear JSX blocks (especially repeated blocks),
     - keep subcomponents local unless cross-feature reuse is clear,
     - use prefixed subcomponent naming (`ComponentNameRow`, not `Row`).
  3. Step C, hook/state extraction:
     - extract complex derived state/effect/event wiring to local hook files,
     - move to `features/<domain>/hooks/**` only when truly feature-level.
  4. Step D, ownership split last:
     - do not use mega-file triage as migration shortcut,
     - cross-home moves only under explicit migration scope after decomposition.

### Forbidden

- Reordering extraction steps to perform high-risk structural migration first.
- Using mega-file triage as justification for broad architecture moves.

---

## Rule: Mega-File Safety Checks and Output Contract
**Rule ID:** sr-mega-file-validation-output  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces post-step safety evidence and deterministic output
shape.

### Requirement

- After each extraction step, verify:
  - TypeScript still compiles (or would compile under existing config),
  - imports remain boundary-compliant,
  - anchor public API (props/exports) is unchanged unless explicitly requested,
  - no runtime behavior change unless requested,
  - tests are updated only when behavior changes and suite exists.
- Output when triggered must include:
  - phased A->D plan with file-touch list per phase,
  - declaration: `in_cap_minimal_reduction` (default) or
    `scope_expansion_needed`,
  - implementation preference: unified diff for mega anchor edits and full
    content for newly extracted files.
- Keep extraction anti-churn constraints explicit:
  - no `shared/common` dumping-ground creation,
  - no new domain logic in `ui/**`,
  - no fetching outside canonical endpoint layer,
  - no broad formatting-only churn,
  - no new mode/flag matrices to force reuse,
  - no new barrels where local area does not already use barrels.

### Forbidden

- Skipping required safety checks after extraction steps.
- Returning mega-file plan output without phased touches and plan declaration.
- Introducing anti-churn violations under mega-file triage scope.

---

# Prop Grouping Discipline

## Summary
Defines when grouping component props is valid versus when it becomes boundary
bypass or prop-surface concealment.

---

## Rule: Prop Grouping Discipline
**Rule ID:** sr-prop-grouping-discipline  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps prop grouping intentional and cohesive while preventing
config-bag anti-patterns that hide responsibility drift.

### Requirement

- Group props only when the grouped shape represents one cohesive concern (for
  example `pagination`, `sorting`, `filters`).
- Group names must be concern-specific and explicit; avoid generic umbrella
  names.
- Grouped props in `ui/**` must remain domain-agnostic and must not carry domain
  entities, domain IDs, or domain behavior flags.
- Prefer composition (`children`, slots, render props) or feature-owned wrappers
  when grouping would otherwise mix unrelated concerns.
- If grouping is used as an escalation action for cap exceedance, reference this
  rule from `sr-prop-count-caps` plan/refactor notes.

### Forbidden

- Generic junk-drawer groups such as `config`, `options`, or `settings` that
  mix unrelated concerns.
- Grouping unrelated data, callbacks, and mode switches solely to reduce visible
  top-level prop count.
- Using grouped objects to pass domain-specific models into shared `ui/**`
  components.
- Using prop grouping to bypass layer boundaries or hide shared-composite domain
  switches.

### Notes

- This rule defines grouping correctness; prop-surface thresholds and escalation
  triggers are defined in `sr-prop-count-caps`.

---

# i18n Text Extraction

## Summary
Defines required extraction behavior for user-facing UI text when a canonical
i18n folder already exists in the repository.

---

## Rule: i18n Extraction for User-Facing UI Text
**Rule ID:** sr-i18n-text-extraction  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hardcoded copy drift and keeps user-facing text
maintainable, localizable, and consistent.

### Requirement

- Trigger this rule when both are true:
  - a canonical i18n home exists (for example `i18n/**`, `src/i18n/**`, or
    gravity-equivalent localization home),
  - user-facing UI text literals are found in touched presentation files (for
    example `pages/**`, `features/*/sections/**`, `ui/**`).
- Extract user-facing UI text from touched files into the existing i18n home
  and reference it by translation key.
- Apply extraction to modified/new UI copy in scope; do not perform unrelated
  repository-wide localization sweeps unless explicitly requested.
- Preserve behavior and message meaning during extraction:
  - keep interpolation/variables equivalent,
  - keep state-conditional copy equivalent,
  - keep accessibility text (labels for user-facing controls) in i18n when
    localization is supported by existing repo patterns.
- Keep canonical ownership singular:
  - reuse existing i18n structure and conventions,
  - do not create a second localization home.
- Allow inline literals only when non-user-facing (for example internal debug
  logs, test-only labels/selectors, class names, protocol constants, or other
  machine-facing strings).

### Forbidden

- Leaving new or modified user-facing UI text literals inline in touched
  components when an i18n home exists.
- Introducing a second localization folder/pattern when a canonical one already
  exists.
- Mixing key-based and hardcoded user-facing variants of the same message in
  the same flow without explicit product requirement.

### Notes

- This rule governs extraction when localization infrastructure already exists;
  it does not mandate introducing i18n infrastructure into repositories that do
  not already have it.

---

# `*Like` and `Maybe<T>` Type Discipline

## Summary
Splits boundary flexibility and optionality semantics into separate rules while
keeping strict domain integrity requirements explicit.

---

## Rule: `*Like` and `Maybe<T>` Discipline Index
**Rule ID:** sr-type-like-maybe  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves backward-compatible entrypoint while delegating to
single-focus type rules.

### Requirement

- When this rule is in scope, follow all of:
  - `sr-type-like-boundary`,
  - `sr-type-maybe-semantics`,
  - `sr-domain-type-integrity`.

### Forbidden

- Applying this index rule without enforcing the referenced type-discipline
  rules.

---

## Rule: `*Like` Boundary Discipline
**Rule ID:** sr-type-like-boundary  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Restricts structural compatibility types to boundary layers.

### Requirement

- `*Like` types are allowed only when all are true:
  - they exist in boundary-oriented homes (`api/dto/**`,
    `features/<domain>/adapters/**`, input parsing/normalization layers),
  - they model external or pre-normalized input shape,
  - they are mapped immediately to canonical domain models,
  - they are not exported as canonical domain contracts.
- If a `*Like` type is introduced, all are required:
  - canonical mapped model exists,
  - mapper exists in same feature boundary,
  - mapping occurs before UI rendering or store persistence.

### Forbidden

- Using `*Like` inside `features/<domain>/domain/**`, `store/**`, or shared
  `ui/**`.
- Using `*Like` to avoid defining canonical domain models.
- Passing `*Like` deep into pages/sections without normalization.
- Naming canonical models as `SomethingLike`.

---

## Rule: `Maybe<T>` Semantics Discipline
**Rule ID:** sr-type-maybe-semantics  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces one explicit repository-wide optionality semantic.

### Requirement

- `Maybe<T>` is allowed only when all are true:
  - defined once in a canonical shared location (for example `src/lib/types.ts`),
  - semantics are exactly one of:
    - `type Maybe<T> = T | null`, or
    - `type Maybe<T> = T | undefined`,
  - repository uses one meaning consistently.
- Allowed contexts:
  - API response normalization,
  - feature-boundary pre-validation states,
  - explicit domain states where absence is meaningful.

### Forbidden

- Mixing `null` and `undefined` semantics arbitrarily.
- Using `Maybe<T>` to bypass validation.
- Defining multiple `Maybe` aliases in different modules.

---

## Rule: Domain Type Integrity
**Rule ID:** sr-domain-type-integrity  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps domain-layer contracts strict and canonical.

### Requirement

- In `features/<domain>/domain/**`:
  - types represent validated canonical models,
  - fields are required unless domain semantics explicitly model absence.
- `Maybe<T>` in domain models is allowed only when domain semantics require true
  optional state.
- Treat as architectural smell when:
  - `*Like` appears outside boundaries,
  - `Maybe<T>` appears broadly in `ui/**` or `store/**`,
  - canonical models overuse optional fields without domain justification.
- Deterministic defaults:
  - prefer canonical types with explicit mapping,
  - prefer required domain fields over optional wrappers by default.

### Forbidden

- Replacing canonical domain models with `*Like` types.
- Using `Maybe<T>` to keep post-validation required fields weak.
- Letting domain logic depend on structural compatibility types.

---

# Test Selectors and `aria-label` Usage

## Summary
Defines stable, user-centric test selector priorities while preventing
accessibility attributes from being used as test-only hooks.

---

## Rule: Test Selectors and `aria-label` Usage
**Rule ID:** sr-tests-aria-label-selectors  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keep tests user-centric and stable without abusing accessibility
attributes as test-only hooks.

### Requirement

- Scope:
  - This rule applies to test strategy and test artifacts across unit,
    integration, and end-to-end coverage when execution skills propose or modify
    tests/selectors.
- Selector priority order (use highest viable):
  1. role plus accessible name (preferred),
  2. visible label selectors (inputs/controls),
  3. `aria-label` / accessible-name selectors (conditional),
  4. `data-testid` (fallback for stability/ambiguity),
  5. CSS classes or DOM-structure selectors (last resort; discouraged).
- `aria-label` selectors are allowed only when all are true:
  - the element is meant to be accessible by name (for example icon-only button
    or unlabeled control),
  - the label is semantic and stable (for example `Close dialog`, `Open menu`,
    `Delete task`),
  - selector stability is acceptable for localization/copy volatility in current
    repository context,
  - query scope resolves to an unambiguous target.
- `data-testid` fallback:
  - when stable user-centric selectors are not viable due to localization churn,
    repeated controls, virtualization, unstable icon-only naming, or ambiguous
    accessible names, use dedicated `data-testid`,
  - `data-testid` must be semantic and deterministic (for example
    `task-delete-button`, `inbox-sync`, `pin-lock-submit`),
  - `data-testid` must not encode styling or DOM structure,
  - `data-testid` should be scoped to the owning feature/component boundary.
- Accessibility integrity:
  - do not add `aria-label` solely for testing,
  - add `aria-label` only when it improves real accessibility (for example
    unlabeled controls, icon-only buttons, custom inputs),
  - when visible label association exists, tests should prefer that association
    instead of redundant `aria-label`.
- Enforcement heuristics:
  - frequent test failures from copy tweaks are a selector-smell signal,
  - heavy `aria-label` string selection across tests indicates fragility,
  - added `aria-label` attributes with no accessibility value indicate misuse,
  - selecting by plain text when role/name query is available indicates missed
    user-centric selection.
- Deterministic defaults:
  - prefer role-based queries first,
  - when label stability is doubtful, prefer `data-testid` over `aria-label`.

### Forbidden

- Targeting `aria-label` when label text is product/marketing copy likely to
  change.
- Targeting user-facing `aria-label` values as primary hooks in localized (or
  localization-ready) surfaces without stability controls.
- Injecting `aria-label` only to satisfy tests.
- Relying on fragile ordering among similarly named elements when selector scope
  is ambiguous.
- Defaulting to CSS class/DOM-structure selectors when stable higher-priority
  selectors are available.

---

# No Duplicate UI Patterns (Composites)

## Summary
Prevents parallel implementations of the same reusable interaction pattern and
enforces reuse-first consolidation.

---

## Rule: No Duplicate UI Patterns (Composites)
**Rule ID:** sr-no-duplicate-ui-patterns  
**Priority:** MUST  
**Applies to:** react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevent parallel implementations of the same UI interaction
pattern that cause drift, inconsistent behavior, and refactor churn.

### Requirement

- Definition: a duplicate UI pattern exists when all are true:
  1. same interaction model (for example trigger -> overlay/popover/menu ->
     selectable actions -> close/dismiss),
  2. same structural UI shape (equivalent composition of primitives/composites),
  3. differences are mostly content/config (labels, disabled rules, callbacks,
     minor styling),
  4. shared abstraction is feasible without domain leakage (slots/children/render
     props, no domain mode flags).
- Reuse-first consolidation behavior:
  - reuse the existing composite as-is when viable,
  - if small gaps exist, update existing composite via slots/children/render
    props, content injection, or small generic props (within caps),
  - do not introduce or expand a second parallel copy for the same pattern.
- New composite allowed only when at least one is true:
  - fit is low (`fit < 6`) and forcing reuse would leak abstractions,
  - long-term behavior divergence is expected to be significant,
  - reuse would require domain mode flags or cross-feature coupling,
  - existing composite is clearly the wrong abstraction concern.
- Evidence requirement when choosing new:
  - record explicit `not_found` or wrong-fit evidence against existing
    candidate(s).
- Kebab/actions menu canonical guidance:
  - maintain one canonical reusable composite for this pattern
    (for example `KebabMenu`/`ActionsMenu`),
  - feature behavior is injected via item data/callbacks/optional slots,
  - avoid domain enum-mode flags in shared composite contracts,
  - converging repeated local popover-menu copies is required when interaction
    model plus shape match.
- Scope and migration safety defaults:
  - default mode avoids moves/renames,
  - consolidation first means reusing canonical composite in new/edited flows
    while leaving legacy copies unless explicit migration scope is requested,
  - migration requests must stay scoped and incremental.
- Enforcement heuristics:
  - repeated trigger (for example `...`) plus popover/dropdown plus action list,
  - repeated `stopPropagation` wrappers for same menu behavior,
  - repeated close-on-select logic,
  - repeated menu-item style tokens/strings,
  - repeated accessibility naming conventions for same control type.
- Deterministic default:
  - when uncertain, assume duplicate when interaction model and shape match,
  - choose reuse/update unless that would require domain leakage.

### Forbidden

- Creating or expanding a second composite implementation when duplicate
  conditions are met.
- Choosing new composite by default without candidate evidence review.
- Forcing reuse through domain mode flags such as `variant=\"tasks|projects\"`.
- Broad migration churn (moves/renames) without explicit migration request.

---

# Side Effects, Error Handling, JSX Density, Time Semantics, Hidden Controls

## Summary
Adds hard governance for browser side-effect boundaries, catch-block handling,
JSX logic density, time-derived state semantics, and hidden interactive control
accessibility behavior.

---

## Rule: Browser Side-Effects and Routing Boundary
**Rule ID:** sr-browser-side-effects-boundary  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hidden routing/app side-effects from leaking into
UI/feature components and keeps navigation/history ownership deterministic.

### Requirement

- Direct browser side-effect APIs must stay in explicit boundaries:
  - allowed homes:
    - `src/pages/**` (route orchestration),
    - `src/core/**` (app wiring/infrastructure),
    - `src/lib/**` (pure helpers only; no direct side effects),
    - `src/hooks/**` (generic cross-domain hooks only when documented).
- Feature UI components (`features/**/sections/**`, feature components, `ui/**`)
  must treat navigation/history/event dispatch as inputs or call approved
  boundary helpers.
- Side-effect API examples covered by this rule include:
  - `window.history.*`,
  - `window.location.*` (including hash),
  - `window.dispatchEvent`, `CustomEvent`,
  - imperative `document.*` operations (except ref-safe measurement and
    interaction support),
  - direct `localStorage`/`sessionStorage` unless canonical helper/hook policy
    explicitly allows boundary access.
- Allowed exceptions:
  - `ui/**` DOM interaction for accessibility/interaction only (focus
    management, layout measurement via refs, event propagation control),
  - feature components can request navigation via callback props from
    pages/sections or a single documented canonical navigation helper/hook.
- Deterministic default:
  - lift navigation/refresh side effects to `pages/**` or `core/**`,
  - otherwise use one documented boundary helper in exactly one canonical policy
    location.

### Forbidden

- `ui/**` directly calling `window.history`, `window.location`, or dispatching
  global events.
- Feature components mutating URL/history directly outside `pages/**`.
- Adding new global custom-event names without explicit architectural request
  and ownership documentation.

---

## Rule: Empty Catch and Swallowed Error Discipline
**Rule ID:** sr-no-empty-catch  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Silent failures destroy debuggability and make behavior
nondeterministic.

### Requirement

- `catch {}` and empty `catch (e) {}` blocks are not allowed.
- Every caught error must do one explicit outcome:
  1. handle/recover,
  2. log via repository logger abstraction (`lib/logger.ts` or canonical
     equivalent),
  3. rethrow,
  4. ignore only with a short safety rationale comment and only for truly
     non-impactful best-effort behavior.
- Swallowing is allowed only when both are true:
  - operation is best-effort and non-critical,
  - short comment explains safety rationale.
- Deterministic default:
  - when unsure, log (`warn` or `error` based on user impact) and continue with
    safe fallback.

### Forbidden

- Empty catch blocks.
- Swallowing errors in transport/endpoint layers (`api/**`) without
  normalization.
- Swallowing errors for business-critical flows (mutations, persistence, auth).

---

## Rule: JSX Logic Density and Handler Extraction
**Rule ID:** sr-jsx-logic-density  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents JSX from becoming an execution script and improves
readability/testability without premature performance optimization.

### Requirement

- JSX should remain declarative; readability takes precedence over referential
  purity ceremony.
- Allowed inline patterns:
  - inline arrow functions that delegate to named handlers,
  - single-expression inline calls with no hidden control flow.
- Extraction is required in touched code when any are true:
  - handler contains branching or multiple statements,
  - component JSX contains more than about four inline arrow handlers,
  - inline handler contains domain logic,
  - inline handler exceeds one screen line in practical readability terms,
  - inline handler contains async work or multi-step side effects.
- Deterministic default:
  - extract to a named `handleX` function for readability,
  - do not introduce `useCallback` unless referential stability is truly
    required by memoized children or equivalent constraints.

### Forbidden

- Multi-branch or async logic embedded directly inside JSX handlers.
- Repeating complex inline functions across sibling elements.
- Extracting handlers reflexively into `useCallback` without a real stability
  need.
- Async IIFEs inside JSX handlers.

---

## Rule: Time and "Now" Semantics in Derived State
**Rule ID:** sr-time-derived-state  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hidden time dependencies that create stale values,
flaky tests, and inconsistent behavior.

### Requirement

- Logic that depends on current time must use explicit semantics:
  - snapshotted now (captured once), or
  - live now (explicit tick/clock source).
- Allowed patterns:
  1. snapshot now once per open/session/action and use that stable value in
     derived computations,
  2. live now from existing `useNow()`/tick hook or parent-owned clock input.
- Deterministic default:
  - prefer snapshot-now for menus/transient interactions unless live updates are
    explicitly required.

### Forbidden

- Calling `new Date()` inside memoized logic without explicit snapshot/live
  ownership.
- Time-dependent behavior changing across renders without owned time source
  semantics.

---

## Rule: Hidden Interactive Controls and Accessibility Contract
**Rule ID:** sr-hidden-interactive-controls  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents invisible/focus-trap controls and accessibility
regressions from CSS hiding patterns.

### Requirement

- When interactive elements are visually hidden (`hidden`, `opacity-0`,
  `sr-only`, similar), focusability/clickability must be intentional:
  - if non-interactive while hidden, remove from interaction path (conditional
    render or remove tab focus and equivalent accessibility signaling),
  - if screen-reader-only, use proper `sr-only` patterns, not `hidden`.
- Hover-revealed controls are allowed only when keyboard users can reach them as
  intended or equivalent focus reveal patterns exist.
- Deterministic default:
  - prefer conditional rendering when control should not exist while hidden.

### Forbidden

- Hidden interactive controls left in DOM as active controls without explicit
  accessible reveal strategy.
- Controls hidden from users but still carrying active click/focus behavior.

---

# No Cross-Feature Dependencies

## Summary
Prevents direct feature-to-feature imports to preserve ownership boundaries and
avoid feature-graph coupling.

---

## Rule: No Cross-Feature Dependencies
**Rule ID:** sr-features-no-cross-deps  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserve clear ownership and prevent feature-graph coupling that
causes architectural drift and refactor explosions.

### Requirement

- Core rule:
  - `features/**` must not import from other `features/**` modules.
  - This includes:
    - UI components/sections from another feature,
    - hooks from another feature,
    - domain models/types from another feature,
    - feature-local utilities/adapters/state from another feature.
- Allowed alternatives when multiple features need shared capability:
  1. `ui/**` for shared UI primitives/composites only (no domain logic/types),
  2. `lib/**` for pure cross-domain utilities (no React imports, no domain
     knowledge),
  3. `api/**` as shared transport contract in canonical endpoint layer
     (`api/endpoints/**` or gravity-equivalent), with each feature mapping DTO
     to its own domain model,
  4. `core/**` for cross-cutting infrastructure/composition (auth/session,
     telemetry, providers, routing setup; not domain behavior).
- Exception mechanism (rare):
  - cross-feature import is allowed only when all are true:
    - an explicitly designated shared-domain module exists (for example
      `features/_shared/**` or `domains/**`),
    - that module is documented in exactly one canonical policy location (for
      example `ARCHITECTURE.md` or `src/config/agentOverrides.ts`),
    - exported contracts are intentionally domain-agnostic or multi-feature
      primitives,
    - usage is consistent with no parallel ad hoc cross-feature imports.
  - absent such designation, cross-feature imports remain forbidden.
- Enforcement heuristics:
  - import path pattern `features/<A>/**` importing `features/<B>/**` where
    `A != B`,
  - a feature section rendering another feature section/component directly,
  - a feature hook calling another feature hook directly,
  - a feature consuming another feature's domain types instead of mapping
    transport data locally.
- Deterministic default:
  - prefer `lib/**` if pure,
  - prefer `ui/**` if UI-only,
  - otherwise keep feature-specific implementations separate; duplication at
    section level is acceptable while reusing shared primitives/composites.
- Hard stop conditions:
  - stop and revise when a change would:
    - introduce new cross-feature import,
    - move domain ownership from one feature into another without explicit
      migration scope,
    - create a second shared dumping-ground inside `features/**`.

### Forbidden

- Direct imports from one feature into another feature without explicit shared
  domain designation.
- Cross-feature coupling through UI, hooks, domain types, adapters, or
  feature-local state modules.
- Creating parallel ad hoc shared areas under `features/**` to bypass ownership
  boundaries.

---

# Type Assertion Discipline (`as T`)

## Summary
Allows narrow, locally provable assertions while forbidding assertion-driven
type lies across boundaries and domain models.

---

## Rule: Type Assertion Discipline (`as T`)
**Rule ID:** sr-types-assertion-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Allow necessary inference help without enabling type lies that
bypass boundaries, validation, and domain integrity.

### Requirement

- Definitions:
  - type assertion: `expr as T` (excluding `as const` literal narrowing),
  - external data: DTO/JSON payloads, untyped third-party values, `unknown`
    inputs, storage reads, and runtime data not guaranteed by TypeScript.
- Default stance:
  - non-`const` assertions (`as T`) are allowed when they reflect runtime
    reality and respect layer boundaries,
  - assertions are allowed only when narrowing or expressing known runtime truth
    that TypeScript cannot infer,
  - assertions must not coerce incompatible shapes or bypass validation.
- Green / OK cases:
  - narrowing where TypeScript cannot track local truth but runtime checks and
    context establish it (for example event/ref narrowing),
  - framework/library interop where upstream types are broader than effective
    runtime shape,
  - `as const`-adjacent narrowing assistance that does not alter semantic
    runtime shape ownership.
- Yellow cases (allowed with discipline, require scrutiny):
  - asserting API payload shape without validation (prefer `unknown` plus
    parse/guard),
  - asserting union member without checking discriminator/guard first.
- Allowed usage (narrowing-safe and locally provable):
  - DOM/event/ref narrowing after guards/invariant checks,
  - library/framework interop where upstream types are broader and safer
    alternatives are impractical,
  - narrowing an already-validated value (schema parse, type guard result).
- Scope rule:
  - apply assertion to the smallest possible expression.
- Boundary rule for external data:
  - do not assert external data directly to semantic/domain types,
  - treat external input as `unknown` (or DTO type),
  - validate/narrow via runtime schema checks or explicit guards/assert helpers,
  - map validated values to canonical domain models in feature boundary,
  - canonical domain types must come from validation plus mapping, not raw
    assertion,
  - do not propagate asserted external shapes across feature/domain boundaries.
- Prefer these alternatives before assertion:
  1. proper narrowing (`in`, discriminants, type guards),
  2. helper functions with narrowing-aware return types,
  3. runtime validation at DTO/form/storage boundaries,
  4. DTO-to-domain mapping.
- Escalation/refactor smell triggers:
  - repeated assertions for same shape problem in a feature,
  - assertions on API payloads or `JSON.parse` outputs,
  - assertions skipping mapping and flowing into domain/sections/pages,
  - assertions used where discriminated unions should exist.
  - when triggered, fix path is guard/validation plus mapping or stronger type
    modeling.
- Relationship to double assertion:
  - `as unknown as T` remains governed by `sr-types-double-assertion` (if
    present in repository policy) as last-resort escape hatch,
  - before double assertion, apply this rule's alternatives and boundary
    constraints first.
- Deterministic default:
  - when uncertain, do not assert; use `unknown` plus narrowing or boundary
    validation plus mapping.

### Forbidden

- Forcing correctness through assertion in:
  - `features/<domain>/domain/**` (domain invariants belong in
    constructors/guards/mappers),
  - `ui/**` shared primitives/composites for data-model coercion,
  - `store/**` state initialization from asserted external shapes.
- Asserting to make a type error disappear without proving runtime truth.
- Asserting union members without prior discriminator/guard evidence.
- Direct `as T` coercion of external data into canonical domain or semantic
  types.
- Assertion-driven bypass of validation and mapping boundaries.
- Assertion sprawl that substitutes for proper union modeling, guards, or
  schema validation.

### Notes

- Narrowing-safe DOM/ref assertions in UI are valid when they follow local
  runtime checks and do not coerce data models.

---

# Double Type Assertion Discipline (`as unknown as T`)

## Summary
Constrains double assertions to rare, boundary-scoped escape hatches with
adjacent safety steps and no unsafe propagation.

---

## Rule: Double Type Assertion Discipline (`as unknown as T`)
**Rule ID:** sr-types-double-assertion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents silencing type errors and leaking unsafe shapes across
boundaries while allowing rare, justified boundary interop.

### Requirement

- Definition:
  - double assertion is any `X as unknown as T` pattern (including equivalent
    two-step `any` cast patterns).
- Default stance:
  - double assertions are forbidden by default,
  - allowed only as last-resort boundary escape hatch.
- Escape hatch is allowed only when all are true:
  1. boundary-only location:
     - `api/dto/**` validation/parsing seams,
     - `features/<domain>/adapters/**`,
     - third-party interop wrappers,
     - legacy typed holes with no immediate safe alternative.
  2. narrow scope:
     - cast is applied to smallest possible expression.
  3. adjacent safety step:
     - same function/file scope includes runtime validation, explicit
       guard/assert helper (`isT`/`assertIsT`), or documented trusted-source
       rationale when validation is infeasible.
  4. no propagation:
     - result is normalized/mapped into canonical type before crossing deeper
       layers (especially before UI rendering or store persistence).
- Preferred alternatives must be attempted first:
  1. type narrowing/guards,
  2. stronger type modeling (generics/overloads/discriminated unions),
  3. runtime validation at boundaries,
  4. DTO-to-domain mapping to canonical types.
  - double assertion is permitted only when alternatives are impractical for
    current scoped change.
- Escalation/refactor smell triggers:
  - multiple double assertions in same feature area,
  - cast coercing DTO directly to domain model without mapping,
  - cast result exported/propagated beyond boundary seam,
  - repeated same cast pattern across call sites.
  - when triggered, add follow-up to replace with guard/assert helper, schema
    validation, or explicit mapping.
- Enforcement heuristics:
  - cast enables field access without validation,
  - cast bypasses known DTO/domain mismatch,
  - cast exists only to satisfy TypeScript with no safety explanation.
- Deterministic default:
  - when uncertain, do not use double assertion; prefer `unknown` plus narrowing
    or explicit mapping.

### Forbidden

- Double assertions in:
  - `ui/**`,
  - `features/<domain>/domain/**`,
  - `pages/**`,
  - `store/**`.
- Using double assertion to suppress type errors without adjacent safety
  evidence.
- Using double assertion as replacement for validation/mapping at boundaries.
- Allowing double-asserted external shapes to propagate across layers.

---

# Deep Relative Import Alias Suggestion

## Summary
Requires an explicit human-facing recommendation to introduce `@/` alias when
deep relative imports are detected and no canonical alias exists.

---

## Rule: Deep Relative Imports Should Trigger `@/` Alias Suggestion
**Rule ID:** sr-import-alias-suggestion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Reduces brittle path traversal noise while keeping alias adoption
as an explicit, human-approved tooling decision.

### Requirement

- Trigger this rule when touched or reviewed code contains deep relative import
  paths (for example `../../../` or deeper).
- If a canonical root alias already exists (for example `@/` or
  gravity-equivalent), use existing repository convention and do not propose a
  second alias system.
- If no canonical alias exists, the agent must include an explicit suggestion to
  the human to introduce `@/` aliasing for maintainability/readability.
- If no canonical alias exists and the active skill supports clarification
  requests (for example `react-refactoring-progression`), the agent must ask the
  human before planning alias adoption scope:
  - provide options `A`/`B`/`C` (optional `D`),
  - include one recommended option with brief rationale,
  - pause alias-related planning until answer is received.
- Suggestion content must be practical and scoped:
  - note why deep traversal is a maintenance smell,
  - propose introducing one canonical alias (prefer `@/` unless repository
    convention indicates otherwise),
  - state that migration can be incremental (touched files first).
- Alias introduction itself remains opt-in:
  - do not apply alias config/import rewrites unless explicitly requested or
    approved by user scope.

### Forbidden

- Silently introducing alias config and import rewrites when user scope does not
  request tooling/path changes.
- Planning alias-adoption changes in clarification-capable flows without asking
  the human first.
- Introducing a second competing root alias pattern when one already exists.
- Continuing to add new deep relative traversals in touched code after alias is
  already established by repository convention.

### Notes

- Boundary rules still apply equally to aliased imports and raw relative imports
  (aliasing is path ergonomics, not boundary bypass).

---

# Umbrella Feature Split and Domain Extraction

## Summary
Prevents umbrella features from becoming mini feature roots with unclear
ownership, rising coupling, and internal parallel taxonomies.

---

## Rule: Umbrella Feature Split and Domain Extraction
**Rule ID:** sr-feature-split-domain-extraction  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevent feature folders from turning into umbrella owners that
hide multiple domains and destabilize placement/reuse boundaries.

### Requirement

- Definitions:
  - umbrella feature: a feature folder that contains multiple domain sub-areas
    and starts acting like a second `features` root,
  - extracted feature: a new `features/<domain>/` owner created to restore
    clear domain ownership.
- Split triggers (extraction is required when any applies):
  - internal domain partitioning resembles multiple first-class features,
  - duplicate layer taxonomies appear inside one feature (for example
    `api/`, `components/`, `hooks/`, `utils/`, `rules/`) while multiple domain
    sub-areas also exist,
  - ownership ambiguity is recurring and the feature becomes a dumping ground,
  - cross-domain coupling grows inside one feature (shared helpers/state/UI
    glue for unrelated sub-areas),
  - reviewability breaks down (changes routinely span unrelated sub-areas).
- Required extraction outcome when triggered:
  - extract each domain sub-area into first-class feature ownership with
    `features/<domain>/sections/**`, `components/**`, `hooks/**`,
    `domain/**` (plus `adapters/**` when needed),
  - reduce original umbrella feature to exactly one of:
    1. route/page orchestration (preferred, usually in `pages/**`), or
    2. thin feature shell with orchestration wiring only.
- Migration-safe extraction protocol:
  1. choose target feature owners first (one owner per sub-area),
  2. move domain logic and adapters before UI,
  3. move feature hooks next,
  4. move feature-owned UI next (sections, then leaf components),
  5. promote shared utilities correctly:
     - `ui/**` for reusable UI patterns,
     - `lib/**` for pure cross-domain helpers,
     - `api/**` remains canonical transport home,
  6. enforce no cross-feature imports after extraction.
- Deterministic default:
  - if uncertain whether a feature is umbrella-shaped, prefer extraction once
    multiple distinct domain sub-areas exist and shared glue is growing,
  - keep orchestration at `pages/**` (or a thin shell), not in a lingering
    umbrella owner.

### Forbidden

- Keeping two active owners for the same concern after split
  (half-umbrella/half-split).
- Creating feature-local transport homes when canonical API home exists (for
  example `features/<x>/api/**` alongside canonical `api/**`).
- Introducing `views/` inside features as a substitute for `sections/`.
- Splitting by technical layer taxonomy (MVC-style) instead of domain ownership.

---

# Feature Components Scope

## Summary
Defines what may live in `features/<domain>/components/**` so feature
components do not become a shadow shared-UI system.

---

## Rule: What May Live in `features/<domain>/components/`
**Rule ID:** sr-feature-components-scope  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents feature components from becoming a second shared UI home
or hiding domain/transport logic in presentation files.

### Requirement

- `features/<domain>/components/**` exists for feature-owned UI pieces that are
  not cross-domain reusable and are not route-level orchestration.
- Allowed component characteristics (all required):
  - domain-bound UI with domain terminology and feature-coupled behavior,
  - feature-scoped reuse (same feature only, not intended cross-feature),
  - UI-oriented behavior only (local UI state, minor presentation logic, event
    handlers),
  - leaf/support role (for example extracted from sections to reduce size or
    complexity).
- Structural constraints:
  - feature components may import:
    - `ui/**`,
    - same-feature hooks/domain utilities,
    - `lib/**`,
  - feature components must not import:
    - `pages/**`,
    - canonical endpoint modules directly,
    - other features unless explicitly allowed shared-domain policy exists.
- Deterministic placement matrix:
  - route-level orchestration -> `pages/**`,
  - domain-aware orchestration -> `features/<domain>/sections/**`,
  - feature-owned leaf UI -> `features/<domain>/components/**`,
  - cross-domain reusable UI -> `ui/primitives/**` or `ui/composites/**`,
  - pure logic -> `features/<domain>/domain/**` or `lib/**`.
- Hard guardrail:
  - if a component in `features/<domain>/components/**` is reused by 2+ domains,
    has no domain terminology, or becomes a mini shared composite, promote it
    to `ui/**`.

### Forbidden

- Transport logic in feature components:
  - `fetch`, axios, endpoint ownership, DTO mapping.
- Cross-domain shared UI maintained under feature components.
- Domain algorithms/business rules/complex transformation logic in component
  files (belongs in feature domain or feature hooks).
- Route orchestration concerns in feature components (belongs in pages/sections).
- Shared dumping-ground subfolders like `common/` or `shared/` under
  feature-components homes.

---

# No Feature-Local API Homes

## Summary
Prevents transport-layer fragmentation by enforcing one canonical API home.

---

## Rule: No `api/` Inside Features When Canonical API Home Exists
**Rule ID:** sr-no-feature-api-home  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves one-home-per-concern for transport ownership and
prevents endpoint drift into feature folders.

### Requirement

- If a canonical API home exists (for example `src/api/**`,
  `src/services/api/**`, or gravity-equivalent), features must not define local
  `api/` folders.
- All transport logic must stay in the canonical endpoint layer:
  - `fetch`,
  - axios/client wrappers,
  - endpoint functions.
- Features must consume transport through the canonical endpoint layer only.
- DTO-to-domain mapping remains feature-owned in
  `features/<domain>/domain/**` or `features/<domain>/adapters/**`.
- Bootstrap exception is valid only when both are true:
  - no canonical API home exists yet, and
  - architecture detection explicitly enters bootstrap mode.
- Even in bootstrap mode, create canonical API home directly; do not create
  feature-local transport homes.

### Forbidden

- `features/<domain>/api/**` when canonical API home exists.
- Direct HTTP calls inside `features/**` transport ownership.
- Returning domain-mapped types from `api/**` as canonical contracts.
- Creating secondary transport homes inside feature boundaries.

---

# No `views` Taxonomy in Features

## Summary
Prevents MVC-style drift and parallel presentation taxonomies inside feature
folders.

---

## Rule: No `views/` or `*View` in Features
**Rule ID:** sr-no-feature-views  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps presentation ownership deterministic across pages,
sections, and components without introducing duplicate view layers.

### Requirement

- `features/**` must not contain `views/` folders.
- Files inside `features/**` must not use `*View` naming.
- Route-pointed components belong in `pages/**`, not `features/**`.
- Domain-aware UI orchestration in features must use:
  - `sections/**` for orchestration-level UI,
  - `components/**` (or `widgets/**` only when explicitly standardized) for
    feature-owned leaf UI.
- If repository already uses `views/` as established gravity, follow migration
  rules for existing architecture rather than creating mixed taxonomies.
- Do not keep both `sections/` and `views/` in the same feature.
- Do not rename `sections/` to `views/` in greenfield architecture.

### Forbidden

- `features/<domain>/views/**` folders.
- `*View` file names inside `features/**`.
- Route-level feature containers named/organized as views.
- Parallel `sections/` + `views/` presentation homes within one feature.

---

# File Name Length Policy

## Summary
Defines deterministic file-name length limits to preserve readability,
discoverability, and tooling ergonomics.

---

## Rule: File Name Length Discipline
**Rule ID:** sr-filename-length  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Long file names reduce grepability, readability, and review
velocity, and often signal mixed responsibilities.

### Requirement

- File naming must stay concise and searchable:
  - keep semantic base name length at `<= 64` characters (excluding extension),
  - prefer concise descriptive names and established local terminology,
  - keep file name and primary export aligned when applicable.
- Suffix handling:
  - known suffixes such as `.test`, `.spec`, `.stories`, `.dto`, and
    framework-required route names do not justify oversized semantic base names.
- When a candidate name exceeds limit:
  - split responsibility rather than encoding multiple concerns in one name,
  - shorten vocabulary using established local terms (no ad hoc abbreviations),
  - keep role suffixes clear (`Page`, `Section`, `Row`, `Badge`, `use*`, etc.).
- Deterministic default:
  - if uncertain, choose the shortest name that remains unambiguous in the
    local feature/layer context.

### Forbidden

- Introducing new files with semantic base names longer than 64 characters.
- Using file names that concatenate multiple responsibilities to avoid
  extraction/splitting.
- Renaming purely for style if the current name is within limit and clear.

---

# Output Mode Resolution

## Summary
Defines strict precedence for `output_mode` selection so human-invoked skill
runs do not accidentally emit raw JSON.

---

## Rule: Output Mode Resolution and Display Safety
**Rule ID:** sr-output-mode-resolution  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents accidental machine-mode output to humans and enforces
deterministic mode selection.

### Requirement

- Resolve `output_mode` using strict precedence:
  1. if request explicitly sets `output_mode`, honor it,
  2. else if requester explicitly asks for machine-readable/raw JSON output
     (automation/integration intent), set `output_mode=agent`,
  3. else if a human explicitly asks to run/use the skill, set
     `output_mode=human`,
  4. else default to `output_mode=agent`.
- Ambiguity fallback:
  - when uncertain between human and agent, choose `output_mode=human`.
- Display contract remains strict:
  - if `output_mode=human`, display only `presentation.user_markdown`,
  - if `output_mode=agent`, display full JSON payload.
- A human-invoked skill run must not infer automation intent unless the human
  explicitly requests machine-readable output.

### Forbidden

- Selecting `output_mode=agent` by habit/default when a human explicitly
  requested skill usage and did not request machine-readable output.
- Inferring automation intent without explicit signal from the request context.
- Displaying raw JSON to a human when `output_mode=human`.

---

# Prop Drilling Discipline

## Summary
Defines thresholds and remediation order for prop-drilling debt without forcing
premature global-state escalation.

---

## Rule: Prop Drilling Discipline and Escalation
**Rule ID:** sr-props-drilling-discipline  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keep component trees readable and maintainable by limiting
pass-through wiring while preserving clear ownership boundaries.

### Requirement

- Definitions:
  - prop drilling: passing props through intermediate components that do not
    consume them, only to reach deeper descendants,
  - pass-through component: component forwarding props it does not consume.
- Treat prop drilling as architectural smell when any applies:
  1. depth threshold: same prop/group forwarded through 3+ layers where
     intermediates do not use it,
  2. volume threshold: component forwards 5+ unused props (excluding
     `className`, `children`, and standard DOM props),
  3. branch duplication: same prop set threaded across multiple sibling
     branches,
  4. churn threshold: drilled props frequently change and repeatedly force
     wiring updates across unrelated components,
  5. UI boundary leakage: domain data/actions drilled into shared `ui/**`
     causing domain awareness.
- Approved remediation ladder (in order):
  1. composition/slots first (`children`, render props, explicit slots),
  2. lift orchestration to `features/<domain>/sections/**`,
  3. feature-scoped context provider inside `features/<domain>/**` when many
     deep descendants need shared state/actions,
  4. global store only for truly global state with explicit policy
     justification.
- Feature-scoped context constraints:
  - provider stays feature-owned (not `ui/**` or global `store/**`),
  - context value shape must be intentional/stable (no everything-bag),
  - provider must not become cross-feature dependency.
- Deterministic default:
  - prefer composition first,
  - if many descendants in one feature need shared value, prefer
    feature-scoped context,
  - do not move to global store without explicit global justification.
- Escalation trigger:
  - if depth >= 3 and volume >= 5 in one subtree, treat as refactor-worthy
    issue in touched scope (while respecting scope-governor limits).

### Forbidden

- Prop-bag objects used mainly to hide drilling instead of reducing
  responsibilities.
- Moving state to global `store/**` as convenience fix without global-state
  justification.
- Making shared `ui/**` domain-aware (domain-mode flags or domain-shaped props)
  to bypass proper feature ownership.
- Introducing new `shared/` or `common/` dumping grounds for drilled values.

---

# Overview

## Summary

This document defines authoritative constraints for
`react-implementation-discipline`.

This skill operates under:

- `shared-rules` (mandatory baseline policy)

All rules here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rid-overview-scope  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep implementation output disciplined, reviewable, and aligned
with architecture and policy.

### Requirement

- Enforce plan fidelity: implementation must follow the approved revised plan.
- Allow direct execution in micro mode only when shared
  `sr-micro-change-bypass` conditions are fully satisfied.
- If file creation becomes necessary, execution must escalate from micro mode
  to standard mode before continuing.
- Enforce boundary and quality gates before output is finalized.
- Enforce minimal churn: avoid unrelated refactors and speculative cleanup.
- Inherit and enforce shared baseline constraints from `shared-rules`.
- Treat these by default as out of scope unless explicitly approved:
  - architecture migration
  - new dependencies
  - unrelated cleanup/refactor work
  - policy/spec document edits
- Require deterministic output states:
  - `accepted`
  - `blocked`
  - `dependency_error`
  - `validation_error`

### Forbidden

- Skipping required validation, boundary, or scope checks.
- Modifying architecture/specification policy artifacts unless explicitly requested.
- Defining local mandatory rules that conflict with `shared-rules`.
- Returning unqualified implementation output when mandatory checks fail.
- Using micro mode without explicit behavior-preserving evidence and bounded
  scope constraints.
- Continuing in micro mode after determining new file creation is required.

### Notes

- If required repository context is unavailable, fail closed.
- Always prefer bounded, reviewable changes over large structural drift.

---

# Implementation Process

## Summary

Defines orchestration flow for plan-driven implementation.

---

## Rule: Plan-Driven Implementation
**Rule ID:** rid-process  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensure deterministic execution that matches approved planning and
policy constraints.

### Requirement

- Treat this rule as workflow orchestration; detailed validation and guardrails
  are delegated to referenced rules.
- Validate required inputs before implementation:
  - standard mode requires `revised_plan`, `detection_result`, and repository
    context,
  - micro mode requires explicit behavior-preserving refactor intent, repository
    context, and compliance with `sr-micro-change-bypass`.
- Resolve output mode using `sr-output-mode-resolution`.
- Select execution mode:
  - default `standard`,
  - allow `micro` only when micro constraints are explicitly satisfied;
    escalate to `standard` if a new-file requirement appears.
- If required inputs are invalid, return `validation_error` and stop.
- If required repository context is unavailable, return `dependency_error` and
  stop, with actionable fallback context requirements.
- Run implementation sequence in order:
  1. enforce scope caps and out-of-scope behavior via `rid-scope-governor`,
  2. enforce access/write discipline via `rid-access-control`,
  3. apply ambiguity defaults via `rid-ambiguity-strategy`,
  4. enforce anti-chaotic guardrails via `rid-chaotic-change-guardrails`,
  5. enforce boundary/runtime/query policy via `rid-boundary-runtime-query`,
  6. enforce hard stop conditions via `rid-stop-conditions`,
  7. execute validation gates via `rid-validation-gates`,
  8. emit contract-compliant payload via `rid-output`.
- Before finalizing `implementation_package`, run downstream consult via
  `rid-refactoring-consult` and record consult metadata.
- Keep plan fidelity and minimal churn as mandatory behavior for both standard
  and micro runs.

### Forbidden

- Implementing without required upstream inputs.
- Entering micro mode when micro constraints are missing or uncertain.
- Continuing execution after missing required context.
- Returning accepted output when mandatory gates fail.
- Skipping referenced sub-rules and substituting ad-hoc policy.

### Notes

- This rule coordinates execution flow; detailed thresholds and contracts are
  owned by referenced rules.

---

# Output Contract

## Summary

Defines strict output envelopes for accepted, blocked, validation-error, and
dependency-error outcomes.

---

## Rule: Structured Implementation Output
**Rule ID:** rid-output  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensure implementation outcomes are machine-consumable,
review-ready, and policy-verifiable.

### Requirement

- Output machine payload must be JSON.
- Output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `output_mode`
  - `presentation`
  - `result_type`
  - `validation_status`
- `output_mode` must be `human` or `agent`.
- `presentation` must include:
  - `user_markdown` (prettified markdown summary of the payload)
- `validation_status` must report:
  - `is_valid`
  - `stage`
  - `quality_check_status`
  - `boundary_status`
  - `scope_deviation_status`
  - `final_state`
  - `errors`
  - optional `warnings`
- `validation_status.final_state` must be one of:
  - `accepted`
  - `blocked`
  - `validation_error`
  - `dependency_error`
- Supported `result_type` values:
  - `implementation_package`
  - `validation_error`
  - `dependency_error`
- `result_type` and `validation_status.final_state` must align:
  - `implementation_package` -> `accepted` or `blocked`
  - `validation_error` -> `validation_error`
  - `dependency_error` -> `dependency_error`
- `implementation_package` must include `output_package` with:
  - `changed_files`
  - optional `updated_patches`
  - optional `new_files`
  - `quality_checks`
  - `boundary_audit`
  - `scope_deviations`
  - `refactoring_consult`
  - optional `required_fixes` (required when `final_state=blocked`)
  - optional `recommended_follow_up_scope`
  - optional `notes`
- `output_package.refactoring_consult` must include:
  - `consulted_skill=react-refactoring-progression`
  - `mode=opportunistic`
  - consult `status`
  - consult `result_type`
  - concise `summary`
- Micro-mode outputs must still include boundary/quality evidence and keep
  implementation bounded to behavior-preserving in-place refactor scope.
- If `scope_expansion_needed` is present, include
  `output_package.recommended_follow_up_scope`.
- Each `scope_deviations[]` entry must include:
  - `path`
  - `type`
  - `reason`
- `validation_error` output must include `notes` and must not include
  `output_package`.
- `dependency_error` output must include:
  - `dependency_issue`
  - `fallback_context_bundle_requirements[]`
  - `notes`
  and must not include `output_package`.
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.

### Forbidden

- Returning unstructured prose.
- Displaying raw JSON to humans when `output_mode=human`.
- Omitting validation summary fields.
- Returning `blocked` without `required_fixes`.
- Returning error outputs with implementation payload.
- Omitting `output_package.refactoring_consult` in
  `implementation_package` results.

### Notes

- Keep notes concise (max 5 items where applicable).
- Prefer deterministic field population for downstream consumers.

---

# Validation Gates

## Summary

Defines mandatory implementation validation checks and execution order.

---

## Rule: Validation Gate Sequence
**Rule ID:** rid-validation-gates  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Catch high-risk defects early and keep completion criteria
consistent.

### Requirement

- Always execute this high-signal sequence before final output:
  1. Boundary audit
  2. Type/lint checks when tooling exists
  3. Loading/error/empty state review when relevant
  4. Query key/invalidation sanity when relevant
  5. Scope/minimal churn audit
  6. Existing test suite checks when present
- Required always:
  - boundary rules satisfied
  - no fetching outside canonical endpoint ownership
  - plan-followed minimal churn
- Required when tooling exists:
  - type/lint commands pass using repository-standard checks
- Required when test suite exists:
  - relevant tests updated or added for changed behavior
- Any failed mandatory gate must set `final_state=blocked`.

### Forbidden

- Declaring success when required gates were skipped.
- Treating failed mandatory gates as warnings-only output.

### Notes

- Keep validation deterministic and evidence-based.

---

# Scope Governor

## Summary

Defines hard execution caps and bounded scope expansion behavior.

---

## Rule: Scope and Churn Caps
**Rule ID:** rid-scope-governor  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent implementation drift and keep output reviewable.

### Requirement

- Enforce default hard caps unless explicitly overridden:
  - max files touched: `8`
  - max new files: `4`
  - max moved/renamed files: `0`
  - max new dependencies: `0`
  - max new top-level folders: `0`
- When caps are exceeded but minimum delivery is possible:
  - return the in-cap minimal output
  - include bounded `scope_expansion_needed[]` with `why` and `would_touch`
  - include concise `recommended_follow_up_scope[]`
- Out-of-scope requests without explicit approval must be excluded from
  implementation payload.

### Forbidden

- Expanding scope silently.
- Adding dependencies without explicit approval.
- Mixing migration moves with feature behavior without explicit request.

### Notes

- Favor smallest viable in-cap delivery first.

---

# Access and Write Control

## Summary

Defines repository-access requirements and fail-closed behavior when context is
missing.

---

## Rule: Context Access and Write Discipline
**Rule ID:** rid-access-control  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent unsafe assumptions and maintain controlled change output.

### Requirement

- Require repository read/search capability for convention and boundary checks.
- Minimum context capabilities:
  - list relevant tree
  - search patterns
  - read target files and config files
- If direct repository context is unavailable, return `dependency_error` with
  actionable `fallback_context_bundle_requirements`, including at least:
  - feature-relevant file tree
  - `package.json`
  - router/entry files when applicable
  - canonical API home information
  - sample primitive/composite/section/hook/endpoint modules
- Default write control behavior:
  - produce reviewable patch/new-file output
  - avoid direct structural writes outside approved plan
  - never auto-edit architecture docs or specification docs (`specs/**`, including `specs/**/master_spec.md`) unless requested

### Forbidden

- Producing accepted implementation output without required context evidence.
- Silent direct-write behavior that bypasses planned review controls.

### Notes

- Fail closed on missing context; do not guess structural conventions.

---

# Output Mode Selection

## Summary

Defines deterministic selection between snippet/diff updates and full-file output.

---

## Rule: Output Mode Selection
**Rule ID:** rid-output-mode-selection  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep implementation output reviewable while minimizing misapply risk.

### Requirement

- This rule governs patch/snippet representation only and is independent from
  root `output_mode` (`human|agent`) selection.
- For existing files, default to changed snippets or unified diffs.
- If `diff_preference` is provided, treat it as the initial mode bias:
  - `snippet_first` -> prefer snippets when safe.
  - `unified_diff` -> prefer unified diffs.
- Automatically prefer unified diff when:
  - edits are non-adjacent in one file
  - imports/exports and logic are changed together
  - snippet-only output risks incorrect application
- For new files, provide full file content.
- Do not return unrelated full files.
- If an existing file is very small and fully changed, full-file output is
  allowed.
- If a newly created file would exceed about 250 lines, prefer splitting
  responsibilities before finalizing output.

### Forbidden

- Returning entire existing files by default.
- Mixing unrelated file content into one output package.

### Notes

- Favor the smallest clear output that preserves apply correctness.

---

# UI Genericity

## Summary

Defines anti-leakage rules for primitives/composites during implementation.

---

## Rule: UI Genericity and Anti-Leakage
**Rule ID:** rid-ui-genericity  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent domain coupling and unstable abstractions in shared UI.

### Requirement

- When updating shared composites:
  - prefer slots/children/render composition
  - do not add domain-specific props or enums
  - do not import domain types
- When updating primitives:
  - small ergonomic props are allowed
  - do not introduce domain mode flags
- If reuse would require leaky abstraction via `variant`, `mode`, or `context`
  flags, prefer feature-section ownership or safe duplication.
- Keep domain behavior in feature sections/hooks, not in shared UI layers.
- Apply layout/shell ownership rules during implementation:
  - low-level minimal-structure building blocks stay in `ui/primitives/**`
  - reusable shell/layout patterns that compose primitives belong in
    `ui/composites/**`
  - domain-owned layout composition belongs in `features/<domain>/sections/**`
- Do not create new top-level `ui/layouts/**` or `ui/shells/**` homes during
  routine implementation.
- If composite layout categorization is required, keep it under existing
  composite home (`ui/composites/layouts/**` or `ui/composites/shells/**`) and
  preserve one-home-per-concern discipline.

### Forbidden

- Encoding domain terms or domain logic in shared `ui/**` components.
- Forcing multi-domain behavior through large flag matrices in composites.
- Placing reusable shell/layout patterns in `ui/primitives/**`.
- Placing domain-owned layout composition in shared `ui/composites/**` by
  default.

### Notes

- Optimize for long-term divergence safety over short-term over-generalization.

---

# Data Flow and Exports

## Summary

Defines execution order, data-flow boundaries, and export wiring discipline.

---

## Rule: Bottom-Up Flow and Minimal Export Wiring
**Rule ID:** rid-data-flow-exports  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep implementation predictable and avoid boundary leakage.

### Requirement

- Prefer bottom-up implementation order when applicable:
  1. DTO/type boundaries
  2. endpoint modules
  3. domain/adapters
  4. feature hooks
  5. UI primitives/composites
  6. feature sections
  7. page composition
- Enforce predictable data flow:
  - endpoint modules return transport DTO data
  - feature layer maps DTO to domain where needed
  - sections render domain-facing data
  - pages compose sections
- Do not fetch inside UI components when canonical endpoint flow exists.
- Wire exports minimally:
  - update nearest existing barrel only when the area already uses barrels
  - avoid introducing new barrel files unless local convention requires it

### Forbidden

- Bypassing endpoint ownership from UI/page layers.
- Creating broad barrel rewires unrelated to requested change.

### Notes

- Keep wiring changes local to reduce merge and review risk.

---

# Quick Validation

## Summary

Defines pre-output lightweight checks required for disciplined completion.

---

## Rule: Quick Validation Checklist
**Rule ID:** rid-quick-validation  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Catch common correctness issues before output is finalized.

### Requirement

- Before final output, confirm:
  - no circular imports introduced by touched files
  - no forbidden imports or boundary violations
  - changed code references valid existing types/contracts
  - query keys remain stable where server-state hooks are updated
  - loading/error/empty handling remains consistent with local patterns
- If repository tests exist and touched behavior requires updates, include
  relevant test adjustments.

### Forbidden

- Finalizing output without running these checks.
- Marking output accepted when these checks identify unresolved failures.

### Notes

- This rule complements (not replaces) formal lint/type/test commands.

---

# Ambiguity Strategy

## Summary

Defines deterministic behavior when local patterns conflict or are unclear.

---

## Rule: Ambiguity Resolution Strategy
**Rule ID:** rid-ambiguity-strategy  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keep delivery moving while minimizing structural mistakes.

### Requirement

- When multiple local patterns exist, use this order:
  1. `follow-existing`: mimic the area being modified
  2. `introduce-boundaries`: keep new module internally consistent
  3. `migrate-as-you-touch`: only when it reduces confusion without scope drift
- Prefer the lowest-churn compliant option when multiple choices are valid.
- Pause only for structural blockers:
  - no boundary-compliant implementation path exists
  - conflicting patterns prevent safe placement
  - scope cannot be reduced to a safe minimum
- For non-structural ambiguity, apply deterministic defaults and proceed.

### Forbidden

- Pausing for minor naming/style choices with safe defaults.
- Introducing broad migrations to resolve local ambiguity.

### Notes

- Interruptions should be rare and high-leverage.

---

# Chaotic Change Guardrails

## Summary

Defines explicit anti-patterns that must be avoided during implementation.

---

## Rule: Anti-Chaotic Change Guardrails
**Rule ID:** rid-chaotic-change-guardrails  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent architecture drift and uncontrolled maintenance debt.

### Requirement

- Do not introduce new `shared/` or `common/` dumping-ground abstractions.
- Do not move inline utility/domain logic into pages/sections when it belongs
  in domain/lib layers.
- Do not bypass canonical endpoint layers from hooks/UI.
- Do not combine structural migration with feature behavior in the same change
  unless explicitly requested.
- Keep feature changes local and migration-aware; avoid two-architecture
  parallelism.

### Forbidden

- Refactor-for-future changes without immediate feature value.
- Creating mega components with many mode/flag combinations.

### Notes

- If migration work is necessary, isolate it as explicit scope.

---

# Pause Defaults Protocol

## Summary

Defines deterministic default behavior and strict pause protocol for structural
ambiguity.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** rid-pause-defaults-protocol  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Avoid unnecessary interruptions while preventing structural debt.

### Requirement

- Apply deterministic defaults when safe:
  - ambiguous feature owner -> choose most specific domain
  - unclear UI pattern -> keep logic in feature section
  - unclear reuse/generalize -> prefer section-level duplication
  - unclear state ownership -> prefer local state first
  - unclear abstraction value -> keep implementation concrete
  - unclear naming -> match nearest neighbor naming
- Pause only when cost of guessing is structurally high:
  - no boundary-compliant path exists
  - conflicting patterns block safe placement
  - scope cannot be reduced to minimum safe delivery
- When pausing, follow clean protocol:
  1. state ambiguity precisely
  2. offer 2-3 concrete options
  3. recommend a default option
  4. stop and wait for confirmation
- Keep questions high-leverage and structural; avoid broad or stylistic
  questions when safe defaults exist.

### Forbidden

- Pausing for minor naming/styling choices.
- Asking vague architecture questions during implementation.
- Blocking delivery when a safe deterministic default exists.

### Notes

- Default pause mode is effectively balanced: pause only for structural blockers.

---

# Boundary Runtime Query

## Summary

Defines boundary-audit detail, runtime safety essentials, and query correctness
requirements.

---

## Rule: Boundary, Runtime, and Query Correctness
**Rule ID:** rid-boundary-runtime-query  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensure implementation output is safe at architecture and runtime
levels.

### Requirement

- Boundary audit must enforce all canonical restrictions, including alias paths
  when aliases are used.
- `ui/**` must not import `features/**`, `api/**`, `store/**`, `pages/**`.
- `api/**` must not import React/UI/features/pages/store.
- `features/**` must not import `pages/**`.
- `pages/**` must not import canonical endpoint layer directly.
- Do not fetch outside canonical endpoint layer.
- Prevent domain terms in shared UI component/file naming.
- Runtime safety essentials when server data is involved:
  - handle loading state
  - handle error state
  - handle empty state for collection/list views
  - avoid unhandled promise rejections
  - avoid fire-and-forget fetch in UI layers
- Query correctness when server-state caching exists:
  - stable query keys
  - correct invalidation/cache updates after mutations
  - avoid duplicating server-state in global store unless explicitly justified
  - keep retry behavior intentional (small capped retries for transient query
    failures; no automatic mutation retries unless explicitly required)

### Forbidden

- Accepting outputs with unresolved boundary violations.
- Accepting outputs that skip required runtime state handling.
- Duplicating server-state into store without explicit justification.

### Notes

- Record failures in `validation_status` and return `blocked` when mandatory.

---

# Stop Conditions

## Summary

Defines hard stop/revise conditions before output finalization.

---

## Rule: Stop and Revise Conditions
**Rule ID:** rid-stop-conditions  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevent knowingly non-compliant output from being emitted.

### Requirement

- Stop and revise plan/output if implementation would require:
  - domain knowledge inside shared `ui/**`
  - endpoint fetch outside canonical endpoint layer
  - leaky shared-composite generalization beyond safe thresholds
  - touched files exceeding 400 lines without extraction/split path
  - touched files exceeding 600 lines at all
- If blocked due to unresolved stop conditions, return `blocked` state with
  explicit required fixes.
- If stop condition is caused by missing mandatory context, return
  `dependency_error` instead of `blocked`.

### Forbidden

- Proceeding with known stop-condition violations.
- Hiding stop-condition violations as warnings-only output.

### Notes

- Stop conditions are hard gates, not advisory guidance.

---

# Naming and Discoverability

## Summary
Defines implementation naming governance as focused rules so ownership,
searchability, and layer boundaries remain explicit.

---

## Rule: Naming and Discoverability Contract Index
**Rule ID:** rid-naming-discoverability  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Preserves stable entrypoint while delegating to single-focus
naming rules.

### Requirement

- When this rule is in scope, enforce all of:
  - `rid-file-export-alignment`,
  - `rid-component-role-naming`,
  - `rid-naming-boundary-hygiene`,
  - `rid-hook-endpoint-type-naming`.

### Forbidden

- Treating this index rule as sufficient without enforcing the referenced naming
  rules.

---

## Rule: File and Export Naming Alignment
**Rule ID:** rid-file-export-alignment  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keeps files grep-friendly and ownership obvious.

### Requirement

- Each new React component file must export one primary component with matching
  name:
  - `UserProfileSection.tsx` -> `export function UserProfileSection()`.
- Prefer named exports for components, hooks, and utilities.
- Allow default exports only when:
  - framework behavior requires them, or
  - local area convention already uses them consistently.

### Forbidden

- Mismatched component file and primary export names without framework-required
  exception.
- Introducing default exports as a new convention in areas that are named-export
  oriented.

---

## Rule: Component Role Naming
**Rule ID:** rid-component-role-naming  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Makes layer responsibility explicit from component names.

### Requirement

- Route orchestration components use `*Page` (or framework-required route files).
- Domain-aware feature orchestration uses `*Section` (or `*Panel` for contained
  sub-regions).
- Domain-agnostic reusable UI patterns use one consistent composite term
  (default `*Shell`, with local-convention `*Layout`/`*Scaffold` only when
  already established).
- Async/error/loading wrappers use `*Boundary`.
- Form naming:
  - full form: `*Form`,
  - subsection: `*FormSection`,
  - reusable domain-agnostic wrapper: `*Field`.
- Dialog naming:
  - default `*Dialog` (or `*Modal` only when local convention already uses it),
  - destructive confirmation: `Confirm*Dialog`.
- `*List`/`*Table` names are for domain-agnostic reusable components; domain-
  aware list/table UI should remain feature-owned (`*Section`/`*Panel`).

### Forbidden

- Mixing naming dialects in the same area (for example arbitrary `*Shell` and
  `*Layout` mixing without local convention).
- Using suffixes that hide route/feature/shared ownership intent.

---

## Rule: Naming Boundary Hygiene
**Rule ID:** rid-naming-boundary-hygiene  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Prevents domain leakage and junk-drawer naming drift.

### Requirement

- Components in `ui/primitives/**` or `ui/composites/**` must not contain domain
  nouns (for example `TaskRow`, `ProjectFilters`, `InvoiceCard`).
- If domain nouns are required, ownership stays in `features/<domain>/**`.
- Reusable components must be named by responsibility (for example `FilterBar`,
  `DataStateBoundary`), not vague prefixes.
- Follow existing local naming convention when it already exists (for example
  `Screens` area naming), and keep one dialect per area.

### Forbidden

- Placing domain-named components under `ui/**`.
- Introducing junk-drawer names such as:
  - `Common*`, `Shared*`, `Utils*`, `Helper*`, `Wrapper*`, `Component*`,
    `Thing*`, `Base*`.
- Introducing a second naming dialect in one local area.

---

## Rule: Hook, Endpoint, and DTO Naming
**Rule ID:** rid-hook-endpoint-type-naming  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Keeps non-component artifacts predictable and discoverable.

### Requirement

- Hooks must use `useXxx` naming.
- Hook placement:
  - `features/<domain>/hooks/useXxx.ts` for feature-owned hooks,
  - `hooks/useXxx.ts` for generic cross-domain hooks only.
- API endpoint modules should be resource-oriented (for example
  `api/endpoints/projects.ts`).
- DTO types should use `*Dto` suffix.

### Forbidden

- Non-`useXxx` hook naming.
- Resource-agnostic endpoint module naming that obscures ownership.
- DTO naming that drifts from `*Dto` in established areas.

### Notes

- Naming should optimize ripgrep discoverability and quick ownership diagnosis.

---

# Downstream Refactoring Consult

## Summary

Defines mandatory end-of-execution consultation of
`react-refactoring-progression` in opportunistic mode.

---

## Rule: Mandatory Opportunistic Refactoring Consult
**Rule ID:** rid-refactoring-consult  
**Priority:** MUST  
**Applies to:** react-implementation-discipline  
**Rationale:** Ensures every implementation run gets a bounded, non-blocking
cleanup/refactor plan derived from the touched file set.

### Requirement

- For every `implementation_package` result, run a downstream consult to
  `react-refactoring-progression` in `opportunistic` mode before finalizing
  output.
- Pass the current touched file set as consult scope:
  - `output_package.changed_files[]`
  - plus any `output_package.new_files[].path` when present
- Treat consult output as planning-only and non-blocking:
  - it must not mutate already-produced implementation patches
  - consult failures must not convert a previously valid implementation outcome
    into `blocked`
- Always record consult result metadata in
  `output_package.refactoring_consult`.
- If refactoring skill/context is unavailable, record `status=unavailable` with
  reason and continue finalization.

### Forbidden

- Skipping consult for `implementation_package` outputs.
- Using consult findings to introduce out-of-scope implementation churn in the
  same execution response.
- Treating consult `validation_error` or `dependency_error` as hard blockers for
  implementation output final state.

### Notes

- Opportunistic consult findings are follow-up guidance for subsequent
  execution, not immediate patch payload.
