<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-25
-->

# React Refactoring Progression â€” Agent Rules

## Table of contents
- [Rule: Optional Extension Scope [rrp-overview-scope]](#rule-optional-extension-scope)
- [Rule: Tiered Planning Sequence [rrp-process]](#rule-tiered-planning-sequence)
- [Rule: Structured Refactor Output [rrp-output]](#rule-structured-refactor-output)
- [Rule: Behavior Preservation Enforcement [rrp-validation-gates]](#rule-behavior-preservation-enforcement)
- [Rule: Bounded Scope Execution [rrp-scope-governor]](#rule-bounded-scope-execution)
- [Rule: Anti-Pattern Findings [rrp-detection]](#rule-anti-pattern-findings)
- [Rule: Semantic Duplication Qualification [rrp-semantic-duplication]](#rule-semantic-duplication-qualification)
- [Rule: Interaction Boundaries [rrp-interactions]](#rule-interaction-boundaries)
- [Rule: Finalized Tier Model [rrp-progression-model]](#rule-finalized-tier-model)
- [Rule: Pattern Type Classification [rrp-dup-pattern-types]](#rule-pattern-type-classification)
- [Rule: Two-Signal Qualification Gate [rrp-dup-two-signals]](#rule-two-signal-qualification-gate)
- [Rule: Structural Evidence Quality [rrp-dup-evidence]](#rule-structural-evidence-quality)
- [Rule: Existing Home Alignment [rrp-dup-home-alignment]](#rule-existing-home-alignment)
- [Rule: Slots Over Prop Matrix [rrp-dup-slots-over-props]](#rule-slots-over-prop-matrix)
- [Rule: One-Level-Up Preference [rrp-dup-one-level-up]](#rule-one-level-up-preference)
- [Rule: Keep-Separate by Default Under High Risk [rrp-dup-keep-separate]](#rule-keep-separate-by-default-under-high-risk)
- [Rule: Locality Preference [rrp-dup-locality]](#rule-locality-preference)
- [Rule: Cognitive Load Guard [rrp-dup-cognitive-load]](#rule-cognitive-load-guard)
- [Rule: Refactor Radius Bound [rrp-dup-refactor-radius]](#rule-refactor-radius-bound)
- [Rule: Micro Extraction Before Mega Extraction [rrp-dup-micro-before-mega]](#rule-micro-extraction-before-mega-extraction)
- [Rule: Cluster Output Completeness [rrp-dup-output]](#rule-cluster-output-completeness)
- [Rule: Actionable Next Actions [rrp-dup-next-actions]](#rule-actionable-next-actions)
- [Rule: Keep-Separate Output Clarity [rrp-dup-keep-separate-output]](#rule-keep-separate-output-clarity)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-refactoring-progression` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- rrp-overview-scope
- rrp-process
- rrp-output
- rrp-validation-gates
- rrp-scope-governor
- rrp-detection
- rrp-semantic-duplication
- rrp-interactions
- rrp-progression-model
- rrp-dup-pattern-types
- rrp-dup-two-signals
- rrp-dup-evidence
- rrp-dup-home-alignment
- rrp-dup-slots-over-props
- rrp-dup-one-level-up
- rrp-dup-keep-separate
- rrp-dup-locality
- rrp-dup-cognitive-load
- rrp-dup-refactor-radius
- rrp-dup-micro-before-mega
- rrp-dup-output
- rrp-dup-next-actions
- rrp-dup-keep-separate-output

---

# Overview

## Summary

Defines the authoritative scope and boundaries for
`react-refactoring-progression`.

---

## Rule: Optional Extension Scope
**Rule ID:** rrp-overview-scope  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps this skill planning-only and aligned with the fixed
four-skill production pipeline.

### Requirement

- The skill must remain an optional extension and must not redefine the fixed
  production execution set.
- The default invocation path is an opportunistic consult at the end of
  `react-implementation-discipline` execution for both micro and standard
  modes.
- The skill must produce planning guidance only and must not emit
  implementation patches.
- The skill must consume upstream architecture, placement, reuse, and
  implementation context rather than recomputing those outcomes.
- The skill must keep recommendations behavior-preserving by default.
- The skill must inherit mandatory shared baseline constraints.
- The skill must remain optional until an explicit governance amendment
  reclassifies it.

### Forbidden

- Reclassifying this skill as a production execution skill inside feature
  output.
- Recomputing architecture gravity or overriding upstream placement/reuse
  decisions.
- Producing direct source-code patches or file-apply payloads.

### Notes

- This skill is a consult layer, not an implementation layer.

---

# Refactor Planning Process

## Summary

Defines deterministic, risk-ordered planning behavior.

---

## Rule: Tiered Planning Sequence
**Rule ID:** rrp-process  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures predictable and low-risk refactor planning.

### Requirement

- Validate required inputs before planning steps.
- Use canonical tier labels only: `A`, `B`, `C`, `D`.
- Order active plan steps from lower-risk to higher-risk tiers.
- Apply deterministic ordering with no additional custom ordering beyond:
  - tier order (`A -> B -> C -> D`)
  - risk order (low before high within the produced list)
- Escalate only when at least one condition is true:
  - a lower-tier improvement is blocked by compliance constraints
  - no meaningful lower-tier improvements remain
  - dedicated refactor mode is explicitly requested
- Every step must include:
  - `why_now`
  - at least one of `unblocks`, `reduces_future_cost`, `standard_alignment`
- Set `behavior_change=none` by default.
- If behavior-preserving guarantees cannot be met, set
  `behavior_change=requires_approval` and mark step as gated.
- In opportunistic mode, produce only Tier A/B active steps and prioritize:
  - dead code removal and import cleanup
  - naming clarity and local helper extraction
  - type tightening
  - non-structural boundary-conformance fixes
- In opportunistic mode, treat Tier C/D findings as non-blocking follow-up
  guidance only.
- In opportunistic mode, do not include:
  - layer changes
  - endpoint relocation
  - cross-home adjustments
  - architectural boundary introduction
- In dedicated mode, allow Tier C/D only under scope-governor and migration
  constraints.

### Forbidden

- Skipping low-risk tiers when safe lower-tier improvements are available.
- Returning unguided or rationale-free steps.
- Using mixed tier naming schemes (for example `0-4` plus `A-D`) in one output.
- Escalating for aesthetic cleanup, style-only churn, or speculative
  "refactor for future" rationale.

### Notes

- Tier C/D recommendations in opportunistic mode belong in follow-up findings,
  not active steps.

---

# Output Contract

## Summary

Defines strict result types and payload constraints.

---

## Rule: Structured Refactor Output
**Rule ID:** rrp-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps outputs machine-consumable and deterministic.

### Requirement

- Emit one JSON object with required envelope fields:
  - `schema_version`
  - `skill`
  - `version`
  - `result_type`
  - `validation_status`
- Restrict `result_type` to:
  - `refactor_plan`
  - `validation_error`
  - `dependency_error`
- Restrict `validation_status` to:
  - `accepted`
  - `blocked`
  - `validation_error`
  - `dependency_error`
- `refactor_plan` output must include:
  - `refactor_mode`
  - `plan.touch_budget`
  - `plan.steps[]`
- `refactor_plan` may include:
  - `plan.follow_up_findings[]` for non-blocking out-of-mode items
  - `plan.test_file_touches[]` for opportunistic test updates
- Opportunistic `refactor_plan` outputs must:
  - include only Tier A/B steps
  - include no more than 5 steps
  - keep Tier C/D items in `plan.follow_up_findings[]` only
- `validation_error` output must include notes and no `plan` payload.
- `dependency_error` output must include:
  - `dependency_issue`
  - `fallback_context_bundle_requirements[]` (min 5)
  - `notes[]`
  - no `plan` payload
- Include `scope_expansion_needed[]` when completeness exceeds caps but an in-cap
  plan is still returned.
- Represent Tier C/D opportunistic findings as follow-up metadata, not blocking
  step execution.
- If `plan.test_file_touches[]` is present, keep it directly relevant, bounded
  (default <=2 files), and dependency-neutral.

### Forbidden

- Emitting prose outside the JSON payload.
- Returning partial `refactor_plan` output when required context is missing.
- Emitting non-enum status strings.

### Notes

- All output examples must validate against the schema.

---

# Validation Gates

## Summary

Defines behavior-preservation and approval gate checks.

---

## Rule: Behavior Preservation Enforcement
**Rule ID:** rrp-validation-gates  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents accidental regressions during refactor planning.

### Requirement

- Validate behavior-preservation invariants for each active step.
- Backend contract invariants (hard):
  - no endpoint, method, param, header, or request/response shape changes
  - no transport-semantics changes
- UI/UX invariants (hard):
  - no major user-noticeable UI behavior changes
  - no new UX breakage
  - only tiny visual consistency adjustments are acceptable
- Behavioral invariants (hard):
  - no external component contract breakage unless strictly equivalent
  - no route path/navigation changes
  - no query-key or cache-semantics changes
  - no user-facing loading/error/empty behavior changes
- Record behavior-preservation checks in `plan.behavior_preservation[]` when
  produced.
- If project tests exist, planning should require preserving or extending
  relevant behavior coverage before high-risk refactor execution.
- Always require boundary-audit, lint/type correctness, and no new test/lint
  regressions in acceptance notes.
- If any step requires non-preserving behavior, mark it
  `behavior_change=requires_approval` and set final state to `blocked` unless
  explicit approval is already present.
- Ensure blocked plans include actionable notes describing required approvals or
  changes.

### Forbidden

- Treating non-preserving steps as accepted by default.
- Omitting preservation checks for steps with non-trivial scope.

### Notes

- `blocked` status is valid for refactor-plan outputs that require explicit
  approval before execution.

---

# Scope Governor

## Summary

Defines mode-specific scope limits and expansion handling.

---

## Rule: Bounded Scope Execution
**Rule ID:** rrp-scope-governor  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents uncontrolled refactor spread and hidden churn.

### Requirement

- Apply default scope caps unless explicitly overridden:
  - `max_files_touched=8`
  - `max_new_files=4`
  - `max_moved_or_renamed=0`
  - `max_new_dependencies=0`
  - `max_new_top_level_folders=0`
- Opportunistic mode must remain bounded to already touched implementation
  files, except mandatory folderization in the same concern home.
- Opportunistic mode may not expand the touched-file set for production code.
- Opportunistic mode must not include moves/renames, routing changes, or new
  dependencies.
- Opportunistic mode may include directly related test-file updates without
  counting them toward touched-file budget only when all hold:
  - no new dependencies are introduced
  - tests validate behavior directly related to touched code
  - no more than 2 test files are updated by default (or explicitly expanded
    via `scope_expansion_needed[]`)
- Dedicated mode move/rename actions are capped at 3 unless migration mode is
  explicitly enabled.
- Dedicated mode may include broader changes only within explicit cap policy and
  migration constraints.
- Folderization policy:
  - mandatory when touched component size exceeds approximately 400 lines
  - allowed around 250-300 lines only when the split clearly reduces
    responsibilities
  - "clearly reduces responsibilities" means at least one is true:
    - file has 2+ distinct responsibilities
    - file contains 3+ meaningful internal subcomponents that can separate
      cleanly
    - file has non-trivial component-scoped helper pile suitable for
      local `*.utils`/`*.types` extraction
    - split reduces the main file toward a single responsibility and materially
      improves readability
- When materially better completeness exceeds caps, emit bounded
  `scope_expansion_needed[]` with `why` and `would_touch` while still returning
  an in-cap plan.

### Forbidden

- Silent scope expansion beyond active caps.
- Introducing unrelated refactor work outside requested scope.

### Notes

- Scope cap enforcement is mandatory even when step quality appears high.

---

# Anti-Pattern Detection

## Summary

Defines anti-pattern detection requirements and output mapping.

---

## Rule: Anti-Pattern Findings
**Rule ID:** rrp-detection  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Turns known architecture drift signals into actionable planning
metadata.

### Requirement

- Detect and classify high-value anti-patterns, including:
  - implicit visibility ownership in shared presentational components
  - fetch/transport usage outside canonical endpoint ownership
  - domain leakage into shared UI abstractions
  - unjustified server-state mirroring in global store
- Anti-pattern tier defaults:
  - implicit visibility in shared presentational UI -> Tier A
  - fetch outside canonical endpoint layer -> Tier B (Tier C when widespread)
  - domain leakage into shared UI -> Tier B
  - server-state mirrored to global store without justification -> Tier B
    (Tier C when systemic)
- Detection heuristics must include:
  - implicit visibility:
    - component in `ui/primitives/**` or `ui/composites/**`
    - conditionally returns `null` based on external props
    - component is not an explicit boundary/guard wrapper
  - fetch outside endpoint layer:
    - transport logic exists outside canonical endpoint ownership
  - domain leakage:
    - domain-specific naming/types/flags in shared UI
  - server-state mirror:
    - cache-backed server data redundantly stored in global store with no
      explicit performance/offline rationale
- Emit findings with:
  - stable `finding_id`
  - `type`
  - assigned `tier`
  - `affected_files[]`
  - `recommended_step_id`
- Ensure out-of-mode findings are surfaced as non-blocking follow-up guidance.
- Detection focus should align with standards enforced by:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`

### Forbidden

- Emitting anti-pattern findings without traceable affected files.
- Promoting out-of-mode findings to blocking active-step status.
- Producing recommendations that are purely aesthetic or preference-driven.

### Notes

- Detection should prioritize standards alignment over style-only concerns.

---

# Semantic Duplication

## Summary

Defines qualification and scoring for structural duplication candidates.

---

## Rule: Semantic Duplication Qualification
**Rule ID:** rrp-semantic-duplication  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents unsafe abstraction and focuses on high-leverage reuse.

### Requirement

- A duplication cluster qualifies only when all are true:
  - responsibility equivalence
  - variation expressibility with <=2 small props/slots or feature-local
    extraction
  - abstraction safety (no domain logic in shared UI and no UI transport logic)
  - acceptable divergence risk
- A duplication cluster also requires at least two independent similarity
  signals.
- Required discovery coverage includes:
  - layout skeletons
  - loading/error/empty boundary trees
  - interaction state-machine patterns
  - config schemas (table/form structures)
  - hook orchestration flows
  - domain-parallel component structures
  - DTO-to-domain mapping pipelines
- Normalize superficial differences (names, literals, import path details)
  before evaluating structural similarity.
- Compare normalized structures on:
  - JSX tree shape
  - conditional decision-tree shape
  - hook usage flow
  - state-machine transitions
- For each cluster, emit:
  - `why_now`
  - at least one of `unblocks`, `reduces_future_cost`, `standard_alignment`
  - `recommended_target`
  - `abstraction_cost`
  - `leakage_risk`
  - `divergence_risk`
  - `refactor_radius`
  - `recommended_next_step`
  - `variation_points[]`
- Use one extraction target only per cluster:
  - `keep_separate`
  - `extract_ui_primitive`
  - `extract_ui_composite`
  - `extract_feature_section`
  - `extract_feature_hook`
  - `extract_lib_utility`
- Recommend `extract_ui_composite` only when variation can be represented with
  slots/children and no domain mode flags are needed.
- Prefer "one level up":
  - within-feature duplication -> feature-local extraction first
  - cross-feature duplication -> shared UI extraction only when leakage risk is
    low
- Reject shared UI extraction when domain-mode flags are required or divergence
  risk is high.
- Default heuristics:
  - if required new props exceed 2, avoid shared UI extraction
  - if divergence risk is high, prefer `keep_separate` or feature-local
    extraction
  - large-radius recommendations should be follow-up scope by default

### Forbidden

- Declaring duplication candidates with only one weak similarity signal.
- Recommending cross-domain shared abstraction when leakage risk is high.

### Notes

- Prefer feature-local extraction before cross-feature abstraction when both are
  viable.

---

# Skill Interactions and Invocation

## Summary

Defines required interaction boundaries with upstream/downstream skills.

---

## Rule: Interaction Boundaries
**Rule ID:** rrp-interactions  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents overlap and contradiction across the fixed skill model.

### Requirement

- The skill must not recompute architecture gravity.
- The skill must respect placement decisions, including canonical endpoint-layer
  ownership.
- The skill must not override reuse/update/new decisions from
  `react-reuse-update-new`.
- The skill must remain plan-only and not emit implementation patches.
- Default invocation path:
  - consulted by `react-implementation-discipline` at end of micro/standard
    execution
  - opportunistic mode is used for this default consult
- Dedicated mode is used only when refactor work is explicitly requested.

### Forbidden

- Overriding authoritative placement or reuse decisions inside refactor output.
- Running as an implementation executor.
- Promoting optional extension behavior into mandatory production flow without
  governance change.

### Notes

- This skill augments implementation quality but does not replace any production
  execution skill.

---

# Refactor Progression Model

## Summary

Defines the finalized tier model and mode-specific tier allowances.

---

## Rule: Finalized Tier Model
**Rule ID:** rrp-progression-model  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps tier semantics stable for reviewers and downstream
automation.

### Requirement

- Canonical tier model:
  - Tier A: Reuse alignment
  - Tier B: Implementation hygiene
  - Tier C: Placement corrections
  - Tier D: Architecture convergence
- Opportunistic mode:
  - allows Tier A and Tier B active steps only
  - Tier C/D findings must be follow-up only
- Dedicated mode:
  - allows Tier A/B by default
  - may include Tier C under scope-governor constraints
  - Tier D requires explicit migration mode and approval
- Escalation order must remain:
  - Tier A -> Tier B -> Tier C -> Tier D

### Forbidden

- Producing Tier C or Tier D active steps in opportunistic mode.
- Producing Tier D active steps without migration mode and explicit approval.

### Notes

- Tier labels are semantic execution bands, not implementation patch
  instructions.

---

# Semantic Duplicate Classification

## Summary

Defines deterministic classification and evidence standards for semantic
duplication clusters.

---

## Rule: Pattern Type Classification
**Rule ID:** rrp-dup-pattern-types  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures each duplication candidate maps to one clear extraction
strategy.

### Requirement

- Every semantic duplication cluster must declare exactly one primary
  `pattern_type`:
  - `layout_skeleton`
  - `data_state_boundary`
  - `interaction_state_machine`
  - `config_schema`
  - `hook_orchestration`
  - `domain_parallel_component`
  - `mapping_pipeline`
  - `permission_gating`
  - `other`
- If `pattern_type=other`, include a concise `type_explanation`.

### Forbidden

- Returning unlabeled duplication clusters.
- Assigning multiple primary pattern types to one cluster.
- Using `other` without an explanation.

---

## Rule: Two-Signal Qualification Gate
**Rule ID:** rrp-dup-two-signals  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Reduces false positives from cosmetic similarity.

### Requirement

- A cluster may qualify as a semantic duplication candidate only when at least
  two independent signals are present.
- Signals must represent structural or responsibility-level similarity and must
  not be identifier-only similarity.

### Forbidden

- Declaring a duplication candidate from a single weak signal.
- Treating naming similarity as a standalone qualification signal.

---

## Rule: Structural Evidence Quality
**Rule ID:** rrp-dup-evidence  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps recommendations actionable and auditable.

### Requirement

- Each cluster must include concise structural evidence that covers:
  - shared responsibility
  - structural similarity basis
  - variation surface
  - target-layer rationale
- Evidence must explain why the recommendation is safe for the proposed layer.

### Forbidden

- Evidence that only references cosmetic similarity.
- Raw code dumps instead of structural explanation.

---

# Semantic Duplicate Guardrails

## Summary

Defines anti-over-abstraction constraints for duplication recommendations.

---

## Rule: Existing Home Alignment
**Rule ID:** rrp-dup-home-alignment  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents introducing a second architecture home by accident.

### Requirement

- Recommendations must align with existing concern homes in the repository.
- If UI concern homes are already established (for example `src/components`),
  prefer that existing home unless migration scope is explicitly declared.

### Forbidden

- Recommending a new parallel home for the same concern without migration scope.

---

## Rule: Slots Over Prop Matrix
**Rule ID:** rrp-dup-slots-over-props  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Avoids prop explosion and domain flags in shared UI composites.

### Requirement

- Shared UI composite recommendations should express variation with
  slots/children/render composition.
- If recommendation needs more than 2 behavioral toggles or domain mode flags,
  reject shared composite extraction.

### Forbidden

- Proposing shared composite extraction that needs domain mode flags.
- Proposing composite APIs with large boolean/variant prop matrices.

---

## Rule: One-Level-Up Preference
**Rule ID:** rrp-dup-one-level-up  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps abstraction scope proportional to the duplication source.

### Requirement

- Within-feature duplication should be extracted one level up first
  (feature section or feature hook).
- Cross-feature extraction into shared UI is recommended only when cross-domain
  reuse is demonstrated and leakage risk is low.

### Forbidden

- Jumping directly to global shared extraction for local duplication.

---

## Rule: Keep-Separate by Default Under High Risk
**Rule ID:** rrp-dup-keep-separate  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Treats intentional duplication as valid when abstraction is
unsafe.

### Requirement

- If abstraction cost is high, leakage risk is high, or divergence risk is high,
  default recommendation must be `keep_separate` (or feature-local extraction).
- Include explicit rationale when `keep_separate` is selected.

### Forbidden

- Forcing unification when risk profile indicates separation is safer.

---

## Rule: Locality Preference
**Rule ID:** rrp-dup-locality  
**Priority:** SHOULD  
**Applies to:** react-refactoring-progression  
**Rationale:** Respects established repository sharing culture.

### Requirement

- If repository conventions favor feature-local sections, prefer local
  extraction unless a strong cross-feature reuse case exists.

### Forbidden

- Introducing cross-feature sharing strategy without strong evidence.

---

## Rule: Cognitive Load Guard
**Rule ID:** rrp-dup-cognitive-load  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** DRY does not justify harder-to-understand APIs.

### Requirement

- Reject recommendations that increase indirection or hide meaningful domain
  differences.
- Reject recommendations that require config-DSL style APIs to represent basic
  variations.

### Forbidden

- Recommending mega-config abstractions as default duplicate handling.

---

## Rule: Refactor Radius Bound
**Rule ID:** rrp-dup-refactor-radius  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents high-churn suggestions in bounded planning modes.

### Requirement

- Every duplication cluster must classify refactor radius as `local`, `medium`,
  or `large`.
- `large` radius recommendations must be marked as follow-up scope unless
  explicit expansion is already approved.

### Forbidden

- Presenting large-radius extraction as immediate in-cap opportunistic work.

---

## Rule: Micro Extraction Before Mega Extraction
**Rule ID:** rrp-dup-micro-before-mega  
**Priority:** SHOULD  
**Applies to:** react-refactoring-progression  
**Rationale:** Improves safety by extracting high-leverage subparts first.

### Requirement

- For complex duplicated components, prefer extracting repeated subparts
  (boundary/layout/helper) before recommending full component unification.

### Forbidden

- Recommending full merge-first abstraction when a smaller extraction addresses
  most duplication safely.

---

# Semantic Duplicate Output Requirements

## Summary

Defines required duplication-cluster output fields for actionable planning.

---

## Rule: Cluster Output Completeness
**Rule ID:** rrp-dup-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures clusters are actionable without implementation output.

### Requirement

- Every semantic duplication cluster must include:
  - `pattern_type`
  - `candidate_files[]`
  - `signals[]`
  - `evidence`
  - `recommended_target`
  - `abstraction_cost`
  - `leakage_risk`
  - `divergence_risk`
  - `refactor_radius`
  - `recommended_next_step`
  - `variation_points[]`
  - `candidate_api`
  - `non_goals[]`
- Cluster output must stay concise and structural; no patch text.

### Forbidden

- Returning semantic duplication clusters without extraction-target and risk
  metadata.
- Returning vague similarity claims without supporting evidence.

---

## Rule: Actionable Next Actions
**Rule ID:** rrp-dup-next-actions  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps output useful for downstream task planning.

### Requirement

- `recommended_next_step` must be one sentence with clear immediate action.
- `candidate_api` must describe expected abstraction interface shape in words
  (not code).
- `non_goals[]` must define what must not be abstracted in the proposed step.

### Forbidden

- Omitting non-goals for duplication recommendations.
- Returning code snippets as the "next action" or candidate API definition.

---

## Rule: Keep-Separate Output Clarity
**Rule ID:** rrp-dup-keep-separate-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Makes non-extraction decisions explicit and reviewable.

### Requirement

- When `recommended_target=keep_separate`, cluster output must include a
  concise `keep_separate_reason`.

### Forbidden

- Recommending `keep_separate` without rationale.
