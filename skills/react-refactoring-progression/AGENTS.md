<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-26
-->

# React Refactoring Progression — Agent Rules

## Table of contents
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: DOM Rendering Boundaries and Primitive Creation Discipline [sr-dom-rendering-and-primitives]](#rule-dom-rendering-boundaries-and-primitive-creation-discipline)
- [Rule: Prop Count Caps and Escalation Actions [sr-prop-count-caps]](#rule-prop-count-caps-and-escalation-actions)
- [Rule: Mega-File Triage and Extraction Plan [sr-mega-file-triage]](#rule-mega-file-triage-and-extraction-plan)
- [Rule: Prop Grouping Discipline [sr-prop-grouping-discipline]](#rule-prop-grouping-discipline)
- [Rule: i18n Extraction for User-Facing UI Text [sr-i18n-text-extraction]](#rule-i18n-extraction-for-user-facing-ui-text)
- [Rule: Optional Extension Scope [rrp-overview-scope]](#rule-optional-extension-scope)
- [Rule: Tiered Planning Sequence [rrp-process]](#rule-tiered-planning-sequence)
- [Rule: Structured Refactor Output [rrp-output]](#rule-structured-refactor-output)
- [Rule: Behavior Preservation Enforcement [rrp-validation-gates]](#rule-behavior-preservation-enforcement)
- [Rule: Bounded Scope Execution [rrp-scope-governor]](#rule-bounded-scope-execution)
- [Rule: Anti-Pattern Findings [rrp-detection]](#rule-anti-pattern-findings)
- [Rule: Semantic Duplication Qualification [rrp-semantic-duplication]](#rule-semantic-duplication-qualification)
- [Rule: Interaction Boundaries [rrp-interactions]](#rule-interaction-boundaries)
- [Rule: Finalized Tier Model [rrp-progression-model]](#rule-finalized-tier-model)
- [Rule: Pattern Type Classification [rrp-dup-pattern-types]](#rule-pattern-type-classification)
- [Rule: Two-Signal Qualification Gate [rrp-dup-two-signals]](#rule-two-signal-qualification-gate)
- [Rule: Structural Evidence Quality [rrp-dup-evidence]](#rule-structural-evidence-quality)
- [Rule: Existing Home Alignment [rrp-dup-home-alignment]](#rule-existing-home-alignment)
- [Rule: Slots Over Prop Matrix [rrp-dup-slots-over-props]](#rule-slots-over-prop-matrix)
- [Rule: One-Level-Up Preference [rrp-dup-one-level-up]](#rule-one-level-up-preference)
- [Rule: Keep-Separate by Default Under High Risk [rrp-dup-keep-separate]](#rule-keep-separate-by-default-under-high-risk)
- [Rule: Locality Preference [rrp-dup-locality]](#rule-locality-preference)
- [Rule: Cognitive Load Guard [rrp-dup-cognitive-load]](#rule-cognitive-load-guard)
- [Rule: Refactor Radius Bound [rrp-dup-refactor-radius]](#rule-refactor-radius-bound)
- [Rule: Micro Extraction Before Mega Extraction [rrp-dup-micro-before-mega]](#rule-micro-extraction-before-mega-extraction)
- [Rule: Cluster Output Completeness [rrp-dup-output]](#rule-cluster-output-completeness)
- [Rule: Actionable Next Actions [rrp-dup-next-actions]](#rule-actionable-next-actions)
- [Rule: Keep-Separate Output Clarity [rrp-dup-keep-separate-output]](#rule-keep-separate-output-clarity)
- [Rule: Refactor — `className` Hygiene and Correct Placement [rrf-ui-classname-hygiene]](#rule-refactor-classname-hygiene-and-correct-placement)
- [Rule: Refactor — `aria-label` Hygiene and Correct Placement [rrf-a11y-aria-label-hygiene]](#rule-refactor-aria-label-hygiene-and-correct-placement)
- [Rule: Refactor — Promote Feature Components to Shared UI Composites Safely [rrf-promote-feature-to-composite]](#rule-refactor-promote-feature-components-to-shared-ui-composites-safely)
- [Rule: Refactor — Naming Hygiene and Correct Placement [rrf-naming-hygiene]](#rule-refactor-naming-hygiene-and-correct-placement)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-refactoring-progression` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-layer-contracts
- sr-file-size-guidance
- sr-enforcement-heuristics
- sr-dom-rendering-and-primitives
- sr-prop-count-caps
- sr-mega-file-triage
- sr-prop-grouping-discipline
- sr-i18n-text-extraction
- rrp-overview-scope
- rrp-process
- rrp-output
- rrp-validation-gates
- rrp-scope-governor
- rrp-detection
- rrp-semantic-duplication
- rrp-interactions
- rrp-progression-model
- rrp-dup-pattern-types
- rrp-dup-two-signals
- rrp-dup-evidence
- rrp-dup-home-alignment
- rrp-dup-slots-over-props
- rrp-dup-one-level-up
- rrp-dup-keep-separate
- rrp-dup-locality
- rrp-dup-cognitive-load
- rrp-dup-refactor-radius
- rrp-dup-micro-before-mega
- rrp-dup-output
- rrp-dup-next-actions
- rrp-dup-keep-separate-output
- rrf-ui-classname-hygiene
- rrf-a11y-aria-label-hygiene
- rrf-promote-feature-to-composite
- rrf-naming-hygiene

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# DOM Rendering and Primitive Discipline

## Summary
Defines deterministic rendering ownership and primitive-creation thresholds to
prevent DOM leakage into logic/data layers and avoid abstraction drift.

---

## Rule: DOM Rendering Boundaries and Primitive Creation Discipline
**Rule ID:** sr-dom-rendering-and-primitives  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces deterministic rendering ownership, prevents DOM leakage
into non-presentation layers, and defines when to introduce reusable UI
primitives versus allowing raw HTML.

### Requirement

- Rendering layer boundaries:
  - only these layers may render JSX/DOM:
    - `ui/primitives/**`
    - `ui/composites/**`
    - `features/*/sections/**`
    - `pages/**`
    - `core/**` (layout composition only, such as app shell/providers)
  - these layers must remain DOM-free (no JSX rendering):
    - `api/**`
    - `lib/**`
    - `store/**`
    - `hooks/**`
    - `config/**`
  - hooks must return state/functions only and never JSX.
- Primitive usage vs raw DOM:
  - when reusable primitives exist (for example `Button`, `Input`, `Card`),
    `features/**/sections/**` and `pages/**` should use them.
  - repeated direct implementations of `<button>`, `<input>`, or `<a>` should
    not bypass existing primitives.
  - raw HTML is allowed when:
    - the element is structural/layout-only (`div`, `section`, `span`, etc.),
    - no suitable primitive exists,
    - usage is truly one-off and not expected to repeat, or
    - usage is highly domain-specific and would leak domain semantics into
      `ui/**`.
- Missing primitive creation threshold:
  - raw DOM may be used temporarily if no suitable primitive exists.
  - create a new primitive in `ui/primitives/**` when any applies:
    - same semantic element pattern appears across two or more
      features/domains,
    - a shared composite needs that element as a building block,
    - two or more near-identical implementations exist with copy-pasted style
      or behavior,
    - multiple call sites independently reimplement accessibility/keyboard/focus
      or label wiring,
    - the element is a core building block (for example button/input/select/
      checkbox/radio/textarea/link/card base/modal base/tabs base/badge/
      tooltip base),
    - styling tokens/classes are repeated to enforce visual consistency.
- Shared UI layer discipline:
  - components in `ui/**` may render valid HTML but must remain domain-agnostic.
  - shared UI must not hardcode domain-specific ARIA labels or domain text.
  - shared UI must not import from `features/**`.
  - shared UI owns semantic correctness, accessibility wiring, and basic visual
    state presentation.
  - shared UI does not own business logic, domain rules, or feature semantics.
- Refactoring enforcement:
  - when DOM appears in invalid layers, refactoring should evaluate:
    1. move JSX to nearest valid presentation layer,
    2. extract reusable primitive when duplication threshold is met,
    3. split logic from markup (`domain/lib` for logic, `sections/ui` for
       markup),
    4. remove duplicated semantic implementations,
    5. replace duplicated raw DOM with shared primitive.
  - refactoring must remain behavior-preserving and within scope-governor
    limits.
- Scope and migration constraints:
  - primitive creation must respect scope caps (default max new files: 4 unless
    explicitly expanded), add no new dependencies, and create no parallel homes.
  - primitive extraction must stay inside existing gravity home
    (`ui/primitives/**`).
  - if extraction exceeds caps, emit `scope_expansion_needed[]` and deliver a
    minimal in-cap safe result first.
- Architectural principle:
  - this rule governs responsibility boundaries, not HTML availability.
  - vanilla HTML is allowed in presentation layers.
  - prefer shared primitives when reuse thresholds are met.
  - never render DOM in logic/data layers.
  - never use raw DOM as a shortcut around established abstractions.

### Forbidden

- Rendering JSX from `hooks/**`, `lib/**`, `store/**`, or `api/**`.
- Duplicating semantic elements already represented by primitives.
- Hardcoding domain semantics inside `ui/**`.
- Creating a new top-level UI home during primitive extraction.
- Introducing new styling systems or UI libraries during primitive creation
  without explicit approval.
- Using primitive extraction as justification for broad migration.

### Notes

- Any JSX detected in DOM-free layers is a structural violation and should be
  treated as high-priority boundary remediation.

---

# Prop Count Caps

## Summary
Defines soft prop-surface caps and mandatory escalation actions to prevent prop
soup and abstraction creep.

---

## Rule: Prop Count Caps and Escalation Actions
**Rule ID:** sr-prop-count-caps  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents prop soup and abstraction creep by enforcing
responsibility boundaries and preferring composition/wrappers over flag
matrices.

### Requirement

- Soft prop caps by layer/type (not hard compile failures):
  - `ui/primitives/**`: max 10 component-defined props
    - excludes native passthrough props from
      `ComponentPropsWithoutRef<...>`-style extension.
  - `ui/composites/**`: max 12 props.
  - `features/*/components/**`: max 12 props.
  - `features/*/sections/**`: max 15 props.
  - `core/**` shells/layout: max 8 props.
  - `pages/**`: max 8 props (prefer near-zero; pages should not be generic
    reusable components).
- When exceeding a cap, choose at least one escalation action and record it in
  planning/refactor metadata:
  1. split by responsibility (extract subcomponents),
  2. replace flags with composition (`children`, slots, render props),
  3. introduce feature-owned wrapper to keep shared UI generic,
  4. group props only when compliant with `sr-prop-grouping-discipline`,
  5. demote from shared UI when domain divergence is the driver.
- Layer-specific escalation constraints:
  - `ui/composites/**` must not exceed cap via domain mode flags
    (`variant="tasks|projects"`, `mode/context` matrices); prefer feature
    wrapper or feature-local duplication.
  - `ui/primitives/**` should remain thin via native passthrough plus minimal
    ergonomic props.
  - `pages/**` should not accumulate prop surfaces; extract section/composite
    instead.

### Forbidden

- Exceeding a cap silently without documenting chosen escalation action.
- Violating `sr-prop-grouping-discipline` (for example domain models hidden in
  grouped objects passed into `ui/**`).
- Growing shared composites through large flag matrices or domain switches.
- Designing one-component-to-rule-them-all APIs that hide unrelated
  responsibilities behind props.

### Notes

- Prop count is a complexity proxy; responsibility boundaries are the core
  signal.
- If temporary cap exceedance is unavoidable, record follow-up refactor scope
  instead of allowing continuing prop-surface growth.

---

# Mega-File Triage and Extraction Plan

## Summary
Defines mandatory triage and extraction sequencing when touched files exceed
safe size/responsibility thresholds.

---

## Rule: Mega-File Triage and Extraction Plan
**Rule ID:** sr-mega-file-triage  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents unsafe edits and chaotic refactors when a file is far
beyond size/responsibility thresholds.

### Requirement

- Trigger this rule when any touched file is:
  - over 600 LOC (hard stop threshold), or
  - over 400 LOC with clear multi-responsibility signals, or
  - explicitly flagged as an offender (for example, a 1500 LOC component), or
  - below threshold but showing clear prior extraction pattern with obvious
    same-pattern leftovers.
- Freeze behavior and shrink the risk surface:
  - treat work as refactor-only unless the user explicitly requests behavior
    changes,
  - default to no functional changes and preserve output, props, and side
    effects,
  - plan extraction as safe incremental steps, not a rewrite.
- Establish a bounded extraction target:
  - declare `anchor_component` (path plus export),
  - declare `extraction_budget` (how many files may change under scope caps),
  - declare `end_state_goal` as anchor file <= 250-400 LOC (or <= 600 LOC if
    explicitly timeboxed) plus stable module boundaries,
  - if scope caps prevent ideal end state, deliver in-cap reduction and include
    `scope_expansion_needed[]`.
- Continue extraction when prior-pattern signals exist, even below thresholds:
  - if an anchor file shows prior extraction signs (for example colocated
    `*.utils.ts`, `*.types.ts`, `components/*`, `*.hooks.ts`, or equivalent
    pattern files) and remaining code matches the same extraction pattern,
    continue extracting those leftovers,
  - dropping below 400/600 LOC is not a stop condition by itself,
  - stop when same-pattern leftovers are exhausted or when scope caps are hit;
    when caps block completion, emit `scope_expansion_needed[]`.
- Execute extraction ordering in this exact sequence:
  1. Step A, non-React pure logic first:
     - extract constants, pure helpers, and component-local types first,
     - keep component-only helpers/types/constants local to the component
       module folder,
     - promote to `lib/**` only when reused by 2+ domains and pure,
     - promote to `features/<domain>/domain/**` only when domain behavior is
       encoded.
  2. Step B, local subcomponents second:
     - extract clear presentational JSX chunks (especially repeated blocks),
     - keep subcomponents component-local unless cross-feature reuse is clear,
     - prefer folderization such as:
       - `ComponentName/ComponentName.tsx` (anchor),
       - `ComponentName/components/ComponentNameHeader.tsx`,
       - `ComponentName/components/ComponentNameRow.tsx`,
     - subcomponents must be prefixed for grepability (`ComponentNameRow`, not
       `Row`).
  3. Step C, hook extraction third:
     - extract complex derived state/effect/event wiring to
       `ComponentName/ComponentName.hooks.ts` or `useComponentNameState.ts`,
     - move hooks to `features/<domain>/hooks/**` only when feature-level and
       not component-scoped.
  4. Step D, split feature ownership last:
     - do not use mega-file triage as a shortcut for architecture migration,
     - keep folderization in the same gravity home unless migration mode is
       explicitly enabled,
     - propose cross-layer/home moves only after decomposition and only under
       explicit migration scope.
- Safety checks are required after each extraction step:
  - TypeScript still compiles (or would compile under existing TS config),
  - imports remain boundary-compliant (no forbidden-layer imports),
  - anchor component public API (props/exports) is unchanged unless explicitly
    requested,
  - no runtime behavior change unless explicitly requested,
  - tests are updated only when behavior changes and a suite already exists
    (extraction-only does not require new tests).
- Output contract when triggered must include:
  - phased A->D plan with file-touch list per phase,
  - explicit plan declaration: `in_cap_minimal_reduction` (default) or
    `scope_expansion_needed`,
  - implementation preference: unified diff for mega anchor-file edits and full
    content for newly extracted files.
- Practical default phased template:
  1. folderize anchor and extract constants/utils/types,
  2. extract obvious presentational subcomponents,
  3. extract state/effect logic into local hooks,
  4. optionally promote reused helpers to `lib/**` or `features/**` only when
     reuse criteria is satisfied.

### Forbidden

- Creating new `shared/common` dumping-ground directories.
- Adding new domain logic to `ui/**`.
- Introducing data fetching outside the canonical endpoint layer.
- Performing bulk formatting churn on the entire anchor file during extraction.
- Adding new flags/modes to force reuse, especially in shared composites.
- Introducing new barrels where the local area does not already use barrels.
- Stopping extraction only because line count dropped below thresholds while
  clear same-pattern leftovers remain and scope budget still allows extraction.

---

# Prop Grouping Discipline

## Summary
Defines when grouping component props is valid versus when it becomes boundary
bypass or prop-surface concealment.

---

## Rule: Prop Grouping Discipline
**Rule ID:** sr-prop-grouping-discipline  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps prop grouping intentional and cohesive while preventing
config-bag anti-patterns that hide responsibility drift.

### Requirement

- Group props only when the grouped shape represents one cohesive concern (for
  example `pagination`, `sorting`, `filters`).
- Group names must be concern-specific and explicit; avoid generic umbrella
  names.
- Grouped props in `ui/**` must remain domain-agnostic and must not carry domain
  entities, domain IDs, or domain behavior flags.
- Prefer composition (`children`, slots, render props) or feature-owned wrappers
  when grouping would otherwise mix unrelated concerns.
- If grouping is used as an escalation action for cap exceedance, reference this
  rule from `sr-prop-count-caps` plan/refactor notes.

### Forbidden

- Generic junk-drawer groups such as `config`, `options`, or `settings` that
  mix unrelated concerns.
- Grouping unrelated data, callbacks, and mode switches solely to reduce visible
  top-level prop count.
- Using grouped objects to pass domain-specific models into shared `ui/**`
  components.
- Using prop grouping to bypass layer boundaries or hide shared-composite domain
  switches.

### Notes

- This rule defines grouping correctness; prop-surface thresholds and escalation
  triggers are defined in `sr-prop-count-caps`.

---

# i18n Text Extraction

## Summary
Defines required extraction behavior for user-facing UI text when a canonical
i18n folder already exists in the repository.

---

## Rule: i18n Extraction for User-Facing UI Text
**Rule ID:** sr-i18n-text-extraction  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hardcoded copy drift and keeps user-facing text
maintainable, localizable, and consistent.

### Requirement

- Trigger this rule when both are true:
  - a canonical i18n home exists (for example `i18n/**`, `src/i18n/**`, or
    gravity-equivalent localization home),
  - user-facing UI text literals are found in touched presentation files (for
    example `pages/**`, `features/*/sections/**`, `ui/**`).
- Extract user-facing UI text from touched files into the existing i18n home
  and reference it by translation key.
- Apply extraction to modified/new UI copy in scope; do not perform unrelated
  repository-wide localization sweeps unless explicitly requested.
- Preserve behavior and message meaning during extraction:
  - keep interpolation/variables equivalent,
  - keep state-conditional copy equivalent,
  - keep accessibility text (labels for user-facing controls) in i18n when
    localization is supported by existing repo patterns.
- Keep canonical ownership singular:
  - reuse existing i18n structure and conventions,
  - do not create a second localization home.
- Allow inline literals only when non-user-facing (for example internal debug
  logs, test-only labels/selectors, class names, protocol constants, or other
  machine-facing strings).

### Forbidden

- Leaving new or modified user-facing UI text literals inline in touched
  components when an i18n home exists.
- Introducing a second localization folder/pattern when a canonical one already
  exists.
- Mixing key-based and hardcoded user-facing variants of the same message in
  the same flow without explicit product requirement.

### Notes

- This rule governs extraction when localization infrastructure already exists;
  it does not mandate introducing i18n infrastructure into repositories that do
  not already have it.

---

# Overview

## Summary

Defines the authoritative scope and boundaries for
`react-refactoring-progression`.

---

## Rule: Optional Extension Scope
**Rule ID:** rrp-overview-scope  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps this skill planning-only and aligned with the fixed
four-skill production pipeline.

### Requirement

- The skill must remain an optional extension and must not redefine the fixed
  production execution set.
- The default invocation path is an opportunistic consult at the end of
  `react-implementation-discipline` execution for both micro and standard
  modes.
- The skill must produce planning guidance only and must not emit
  implementation patches.
- The skill must consume upstream architecture, placement, reuse, and
  implementation context rather than recomputing those outcomes.
- The skill must keep recommendations behavior-preserving by default.
- The skill must inherit mandatory shared baseline constraints.
- The skill must remain optional until an explicit governance amendment
  reclassifies it.

### Forbidden

- Reclassifying this skill as a production execution skill inside feature
  output.
- Recomputing architecture gravity or overriding upstream placement/reuse
  decisions.
- Producing direct source-code patches or file-apply payloads.

### Notes

- This skill is a consult layer, not an implementation layer.

---

# Refactor Planning Process

## Summary

Defines deterministic, risk-ordered planning behavior.

---

## Rule: Tiered Planning Sequence
**Rule ID:** rrp-process  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures predictable and low-risk refactor planning.

### Requirement

- Validate required inputs before planning steps.
- Resolve effective output mode before planning output:
  - accept optional `output_mode` (`human|agent`)
  - default to `human` when a human explicitly instructs this skill to run
  - default to `agent` otherwise
- Use canonical tier labels only: `A`, `B`, `C`, `D`.
- Order active plan steps from lower-risk to higher-risk tiers.
- Apply deterministic ordering with no additional custom ordering beyond:
  - tier order (`A -> B -> C -> D`)
  - risk order (low before high within the produced list)
- Escalate only when at least one condition is true:
  - a lower-tier improvement is blocked by compliance constraints
  - no meaningful lower-tier improvements remain
  - dedicated refactor mode is explicitly requested
- Every step must include:
  - `why_now`
  - at least one of `unblocks`, `reduces_future_cost`, `standard_alignment`
- Set `behavior_change=none` by default.
- If behavior-preserving guarantees cannot be met, set
  `behavior_change=requires_approval` and mark step as gated.
- In opportunistic mode, produce only Tier A/B active steps and prioritize:
  - dead code removal and import cleanup
  - naming clarity and local helper extraction
  - type tightening
  - non-structural boundary-conformance fixes
- In opportunistic mode, treat Tier C/D findings as non-blocking follow-up
  guidance only.
- In opportunistic mode, do not include:
  - layer changes
  - endpoint relocation
  - cross-home adjustments
  - architectural boundary introduction
- In dedicated mode, allow Tier C/D only under scope-governor and migration
  constraints.

### Forbidden

- Skipping low-risk tiers when safe lower-tier improvements are available.
- Returning unguided or rationale-free steps.
- Using mixed tier naming schemes (for example `0-4` plus `A-D`) in one output.
- Escalating for aesthetic cleanup, style-only churn, or speculative
  "refactor for future" rationale.

### Notes

- Tier C/D recommendations in opportunistic mode belong in follow-up findings,
  not active steps.

---

# Output Contract

## Summary

Defines strict result types and payload constraints.

---

## Rule: Structured Refactor Output
**Rule ID:** rrp-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps outputs machine-consumable and deterministic.

### Requirement

- Emit one JSON object with required envelope fields:
  - `schema_version`
  - `skill`
  - `version`
  - `output_mode`
  - `presentation`
  - `result_type`
  - `validation_status`
- `output_mode` must be `human` or `agent`.
- `presentation` must include:
  - `user_markdown` (prettified markdown summary of the payload)
- Restrict `result_type` to:
  - `refactor_plan`
  - `validation_error`
  - `dependency_error`
- Restrict `validation_status` to:
  - `accepted`
  - `blocked`
  - `validation_error`
  - `dependency_error`
- `refactor_plan` output must include:
  - `refactor_mode`
  - `plan.touch_budget`
  - `plan.steps[]`
- `refactor_plan` may include:
  - `plan.follow_up_findings[]` for non-blocking out-of-mode items
  - `plan.test_file_touches[]` for opportunistic test updates
- Opportunistic `refactor_plan` outputs must:
  - include only Tier A/B steps
  - include no more than 5 steps
  - keep Tier C/D items in `plan.follow_up_findings[]` only
- `validation_error` output must include notes and no `plan` payload.
- `dependency_error` output must include:
  - `dependency_issue`
  - `fallback_context_bundle_requirements[]` (min 5)
  - `notes[]`
  - no `plan` payload
- Include `scope_expansion_needed[]` when completeness exceeds caps but an in-cap
  plan is still returned.
- Represent Tier C/D opportunistic findings as follow-up metadata, not blocking
  step execution.
- If `plan.test_file_touches[]` is present, keep it directly relevant, bounded
  (default <=2 files), and dependency-neutral.
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.

### Forbidden

- Emitting prose outside the JSON payload when `output_mode=agent`.
- Displaying raw JSON to humans when `output_mode=human`.
- Returning partial `refactor_plan` output when required context is missing.
- Emitting non-enum status strings.

### Notes

- All output examples must validate against the schema.

---

# Validation Gates

## Summary

Defines behavior-preservation and approval gate checks.

---

## Rule: Behavior Preservation Enforcement
**Rule ID:** rrp-validation-gates  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents accidental regressions during refactor planning.

### Requirement

- Validate behavior-preservation invariants for each active step.
- Backend contract invariants (hard):
  - no endpoint, method, param, header, or request/response shape changes
  - no transport-semantics changes
- UI/UX invariants (hard):
  - no major user-noticeable UI behavior changes
  - no new UX breakage
  - only tiny visual consistency adjustments are acceptable
- Behavioral invariants (hard):
  - no external component contract breakage unless strictly equivalent
  - no route path/navigation changes
  - no query-key or cache-semantics changes
  - no user-facing loading/error/empty behavior changes
- Record behavior-preservation checks in `plan.behavior_preservation[]` when
  produced.
- If project tests exist, planning should require preserving or extending
  relevant behavior coverage before high-risk refactor execution.
- Always require boundary-audit, lint/type correctness, and no new test/lint
  regressions in acceptance notes.
- If any step requires non-preserving behavior, mark it
  `behavior_change=requires_approval` and set final state to `blocked` unless
  explicit approval is already present.
- Ensure blocked plans include actionable notes describing required approvals or
  changes.

### Forbidden

- Treating non-preserving steps as accepted by default.
- Omitting preservation checks for steps with non-trivial scope.

### Notes

- `blocked` status is valid for refactor-plan outputs that require explicit
  approval before execution.

---

# Scope Governor

## Summary

Defines mode-specific scope limits and expansion handling.

---

## Rule: Bounded Scope Execution
**Rule ID:** rrp-scope-governor  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents uncontrolled refactor spread and hidden churn.

### Requirement

- Apply default scope caps unless explicitly overridden:
  - `max_files_touched=8`
  - `max_new_files=4`
  - `max_moved_or_renamed=0`
  - `max_new_dependencies=0`
  - `max_new_top_level_folders=0`
- Opportunistic mode must remain bounded to already touched implementation
  files, except mandatory folderization in the same concern home.
- Opportunistic mode may not expand the touched-file set for production code.
- Opportunistic mode must not include moves/renames, routing changes, or new
  dependencies.
- Opportunistic mode may include directly related test-file updates without
  counting them toward touched-file budget only when all hold:
  - no new dependencies are introduced
  - tests validate behavior directly related to touched code
  - no more than 2 test files are updated by default (or explicitly expanded
    via `scope_expansion_needed[]`)
- Dedicated mode move/rename actions are capped at 3 unless migration mode is
  explicitly enabled.
- Dedicated mode may include broader changes only within explicit cap policy and
  migration constraints.
- Folderization policy:
  - mandatory when touched component size exceeds approximately 400 lines
  - allowed around 250-300 lines only when the split clearly reduces
    responsibilities
  - "clearly reduces responsibilities" means at least one is true:
    - file has 2+ distinct responsibilities
    - file contains 3+ meaningful internal subcomponents that can separate
      cleanly
    - file has non-trivial component-scoped helper pile suitable for
      local `*.utils`/`*.types` extraction
    - split reduces the main file toward a single responsibility and materially
      improves readability
- When materially better completeness exceeds caps, emit bounded
  `scope_expansion_needed[]` with `why` and `would_touch` while still returning
  an in-cap plan.

### Forbidden

- Silent scope expansion beyond active caps.
- Introducing unrelated refactor work outside requested scope.

### Notes

- Scope cap enforcement is mandatory even when step quality appears high.

---

# Anti-Pattern Detection

## Summary

Defines anti-pattern detection requirements and output mapping.

---

## Rule: Anti-Pattern Findings
**Rule ID:** rrp-detection  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Turns known architecture drift signals into actionable planning
metadata.

### Requirement

- Detect and classify high-value anti-patterns, including:
  - implicit visibility ownership in shared presentational components
  - fetch/transport usage outside canonical endpoint ownership
  - domain leakage into shared UI abstractions
  - unjustified server-state mirroring in global store
- Anti-pattern tier defaults:
  - implicit visibility in shared presentational UI -> Tier A
  - fetch outside canonical endpoint layer -> Tier B (Tier C when widespread)
  - domain leakage into shared UI -> Tier B
  - server-state mirrored to global store without justification -> Tier B
    (Tier C when systemic)
- Detection heuristics must include:
  - implicit visibility:
    - component in `ui/primitives/**` or `ui/composites/**`
    - conditionally returns `null` based on external props
    - component is not an explicit boundary/guard wrapper
  - fetch outside endpoint layer:
    - transport logic exists outside canonical endpoint ownership
  - domain leakage:
    - domain-specific naming/types/flags in shared UI
  - server-state mirror:
    - cache-backed server data redundantly stored in global store with no
      explicit performance/offline rationale
- Emit findings with:
  - stable `finding_id`
  - `type`
  - assigned `tier`
  - `affected_files[]`
  - `recommended_step_id`
- Ensure out-of-mode findings are surfaced as non-blocking follow-up guidance.
- Detection focus should align with standards enforced by:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`

### Forbidden

- Emitting anti-pattern findings without traceable affected files.
- Promoting out-of-mode findings to blocking active-step status.
- Producing recommendations that are purely aesthetic or preference-driven.

### Notes

- Detection should prioritize standards alignment over style-only concerns.

---

# Semantic Duplication

## Summary

Defines qualification and scoring for structural duplication candidates.

---

## Rule: Semantic Duplication Qualification
**Rule ID:** rrp-semantic-duplication  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents unsafe abstraction and focuses on high-leverage reuse.

### Requirement

- A duplication cluster qualifies only when all are true:
  - responsibility equivalence
  - variation expressibility with <=2 small props/slots or feature-local
    extraction
  - abstraction safety (no domain logic in shared UI and no UI transport logic)
  - acceptable divergence risk
- A duplication cluster also requires at least two independent similarity
  signals.
- Required discovery coverage includes:
  - layout skeletons
  - loading/error/empty boundary trees
  - interaction state-machine patterns
  - config schemas (table/form structures)
  - hook orchestration flows
  - domain-parallel component structures
  - DTO-to-domain mapping pipelines
- Normalize superficial differences (names, literals, import path details)
  before evaluating structural similarity.
- Compare normalized structures on:
  - JSX tree shape
  - conditional decision-tree shape
  - hook usage flow
  - state-machine transitions
- For each cluster, emit:
  - `why_now`
  - at least one of `unblocks`, `reduces_future_cost`, `standard_alignment`
  - `recommended_target`
  - `abstraction_cost`
  - `leakage_risk`
  - `divergence_risk`
  - `refactor_radius`
  - `recommended_next_step`
  - `variation_points[]`
- Use one extraction target only per cluster:
  - `keep_separate`
  - `extract_ui_primitive`
  - `extract_ui_composite`
  - `extract_feature_section`
  - `extract_feature_hook`
  - `extract_lib_utility`
- Recommend `extract_ui_composite` only when variation can be represented with
  slots/children and no domain mode flags are needed.
- Prefer "one level up":
  - within-feature duplication -> feature-local extraction first
  - cross-feature duplication -> shared UI extraction only when leakage risk is
    low
- Reject shared UI extraction when domain-mode flags are required or divergence
  risk is high.
- Default heuristics:
  - if required new props exceed 2, avoid shared UI extraction
  - if divergence risk is high, prefer `keep_separate` or feature-local
    extraction
  - large-radius recommendations should be follow-up scope by default

### Forbidden

- Declaring duplication candidates with only one weak similarity signal.
- Recommending cross-domain shared abstraction when leakage risk is high.

### Notes

- Prefer feature-local extraction before cross-feature abstraction when both are
  viable.

---

# Skill Interactions and Invocation

## Summary

Defines required interaction boundaries with upstream/downstream skills.

---

## Rule: Interaction Boundaries
**Rule ID:** rrp-interactions  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents overlap and contradiction across the fixed skill model.

### Requirement

- The skill must not recompute architecture gravity.
- The skill must respect placement decisions, including canonical endpoint-layer
  ownership.
- The skill must not override reuse/update/new decisions from
  `react-reuse-update-new`.
- The skill must remain plan-only and not emit implementation patches.
- Default invocation path:
  - consulted by `react-implementation-discipline` at end of micro/standard
    execution
  - opportunistic mode is used for this default consult
- Dedicated mode is used only when refactor work is explicitly requested.

### Forbidden

- Overriding authoritative placement or reuse decisions inside refactor output.
- Running as an implementation executor.
- Promoting optional extension behavior into mandatory production flow without
  governance change.

### Notes

- This skill augments implementation quality but does not replace any production
  execution skill.

---

# Refactor Progression Model

## Summary

Defines the finalized tier model and mode-specific tier allowances.

---

## Rule: Finalized Tier Model
**Rule ID:** rrp-progression-model  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps tier semantics stable for reviewers and downstream
automation.

### Requirement

- Canonical tier model:
  - Tier A: Reuse alignment
  - Tier B: Implementation hygiene
  - Tier C: Placement corrections
  - Tier D: Architecture convergence
- Opportunistic mode:
  - allows Tier A and Tier B active steps only
  - Tier C/D findings must be follow-up only
- Dedicated mode:
  - allows Tier A/B by default
  - may include Tier C under scope-governor constraints
  - Tier D requires explicit migration mode and approval
- Escalation order must remain:
  - Tier A -> Tier B -> Tier C -> Tier D

### Forbidden

- Producing Tier C or Tier D active steps in opportunistic mode.
- Producing Tier D active steps without migration mode and explicit approval.

### Notes

- Tier labels are semantic execution bands, not implementation patch
  instructions.

---

# Semantic Duplicate Classification

## Summary

Defines deterministic classification and evidence standards for semantic
duplication clusters.

---

## Rule: Pattern Type Classification
**Rule ID:** rrp-dup-pattern-types  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures each duplication candidate maps to one clear extraction
strategy.

### Requirement

- Every semantic duplication cluster must declare exactly one primary
  `pattern_type`:
  - `layout_skeleton`
  - `data_state_boundary`
  - `interaction_state_machine`
  - `config_schema`
  - `hook_orchestration`
  - `domain_parallel_component`
  - `mapping_pipeline`
  - `permission_gating`
  - `other`
- If `pattern_type=other`, include a concise `type_explanation`.

### Forbidden

- Returning unlabeled duplication clusters.
- Assigning multiple primary pattern types to one cluster.
- Using `other` without an explanation.

---

## Rule: Two-Signal Qualification Gate
**Rule ID:** rrp-dup-two-signals  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Reduces false positives from cosmetic similarity.

### Requirement

- A cluster may qualify as a semantic duplication candidate only when at least
  two independent signals are present.
- Signals must represent structural or responsibility-level similarity and must
  not be identifier-only similarity.

### Forbidden

- Declaring a duplication candidate from a single weak signal.
- Treating naming similarity as a standalone qualification signal.

---

## Rule: Structural Evidence Quality
**Rule ID:** rrp-dup-evidence  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps recommendations actionable and auditable.

### Requirement

- Each cluster must include concise structural evidence that covers:
  - shared responsibility
  - structural similarity basis
  - variation surface
  - target-layer rationale
- Evidence must explain why the recommendation is safe for the proposed layer.

### Forbidden

- Evidence that only references cosmetic similarity.
- Raw code dumps instead of structural explanation.

---

# Semantic Duplicate Guardrails

## Summary

Defines anti-over-abstraction constraints for duplication recommendations.

---

## Rule: Existing Home Alignment
**Rule ID:** rrp-dup-home-alignment  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents introducing a second architecture home by accident.

### Requirement

- Recommendations must align with existing concern homes in the repository.
- If UI concern homes are already established (for example `src/components`),
  prefer that existing home unless migration scope is explicitly declared.

### Forbidden

- Recommending a new parallel home for the same concern without migration scope.

---

## Rule: Slots Over Prop Matrix
**Rule ID:** rrp-dup-slots-over-props  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Avoids prop explosion and domain flags in shared UI composites.

### Requirement

- Shared UI composite recommendations should express variation with
  slots/children/render composition.
- If recommendation needs more than 2 behavioral toggles or domain mode flags,
  reject shared composite extraction.

### Forbidden

- Proposing shared composite extraction that needs domain mode flags.
- Proposing composite APIs with large boolean/variant prop matrices.

---

## Rule: One-Level-Up Preference
**Rule ID:** rrp-dup-one-level-up  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps abstraction scope proportional to the duplication source.

### Requirement

- Within-feature duplication should be extracted one level up first
  (feature section or feature hook).
- Cross-feature extraction into shared UI is recommended only when cross-domain
  reuse is demonstrated and leakage risk is low.

### Forbidden

- Jumping directly to global shared extraction for local duplication.

---

## Rule: Keep-Separate by Default Under High Risk
**Rule ID:** rrp-dup-keep-separate  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Treats intentional duplication as valid when abstraction is
unsafe.

### Requirement

- If abstraction cost is high, leakage risk is high, or divergence risk is high,
  default recommendation must be `keep_separate` (or feature-local extraction).
- Include explicit rationale when `keep_separate` is selected.

### Forbidden

- Forcing unification when risk profile indicates separation is safer.

---

## Rule: Locality Preference
**Rule ID:** rrp-dup-locality  
**Priority:** SHOULD  
**Applies to:** react-refactoring-progression  
**Rationale:** Respects established repository sharing culture.

### Requirement

- If repository conventions favor feature-local sections, prefer local
  extraction unless a strong cross-feature reuse case exists.

### Forbidden

- Introducing cross-feature sharing strategy without strong evidence.

---

## Rule: Cognitive Load Guard
**Rule ID:** rrp-dup-cognitive-load  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** DRY does not justify harder-to-understand APIs.

### Requirement

- Reject recommendations that increase indirection or hide meaningful domain
  differences.
- Reject recommendations that require config-DSL style APIs to represent basic
  variations.

### Forbidden

- Recommending mega-config abstractions as default duplicate handling.

---

## Rule: Refactor Radius Bound
**Rule ID:** rrp-dup-refactor-radius  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents high-churn suggestions in bounded planning modes.

### Requirement

- Every duplication cluster must classify refactor radius as `local`, `medium`,
  or `large`.
- `large` radius recommendations must be marked as follow-up scope unless
  explicit expansion is already approved.

### Forbidden

- Presenting large-radius extraction as immediate in-cap opportunistic work.

---

## Rule: Micro Extraction Before Mega Extraction
**Rule ID:** rrp-dup-micro-before-mega  
**Priority:** SHOULD  
**Applies to:** react-refactoring-progression  
**Rationale:** Improves safety by extracting high-leverage subparts first.

### Requirement

- For complex duplicated components, prefer extracting repeated subparts
  (boundary/layout/helper) before recommending full component unification.

### Forbidden

- Recommending full merge-first abstraction when a smaller extraction addresses
  most duplication safely.

---

# Semantic Duplicate Output Requirements

## Summary

Defines required duplication-cluster output fields for actionable planning.

---

## Rule: Cluster Output Completeness
**Rule ID:** rrp-dup-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures clusters are actionable without implementation output.

### Requirement

- Every semantic duplication cluster must include:
  - `pattern_type`
  - `candidate_files[]`
  - `signals[]`
  - `evidence`
  - `recommended_target`
  - `abstraction_cost`
  - `leakage_risk`
  - `divergence_risk`
  - `refactor_radius`
  - `recommended_next_step`
  - `variation_points[]`
  - `candidate_api`
  - `non_goals[]`
- Cluster output must stay concise and structural; no patch text.

### Forbidden

- Returning semantic duplication clusters without extraction-target and risk
  metadata.
- Returning vague similarity claims without supporting evidence.

---

## Rule: Actionable Next Actions
**Rule ID:** rrp-dup-next-actions  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps output useful for downstream task planning.

### Requirement

- `recommended_next_step` must be one sentence with clear immediate action.
- `candidate_api` must describe expected abstraction interface shape in words
  (not code).
- `non_goals[]` must define what must not be abstracted in the proposed step.

### Forbidden

- Omitting non-goals for duplication recommendations.
- Returning code snippets as the "next action" or candidate API definition.

---

## Rule: Keep-Separate Output Clarity
**Rule ID:** rrp-dup-keep-separate-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Makes non-extraction decisions explicit and reviewable.

### Requirement

- When `recommended_target=keep_separate`, cluster output must include a
  concise `keep_separate_reason`.

### Forbidden

- Recommending `keep_separate` without rationale.

---

# UI and Accessibility Hygiene

## Summary

Defines deterministic hygiene checks for `className` and `aria-label` in
refactor planning without expanding architecture scope.

---

## Rule: Refactor — `className` Hygiene and Correct Placement
**Rule ID:** rrf-ui-classname-hygiene  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Remove style-prop drift without creating new architecture or
prop soup.

### Requirement

- Detect `className` as incorrect/suspect when any is true:
  - non-DOM modules accept `className` but do not render a DOM root:
    - `hooks/**`, `features/*/hooks/**`
    - `features/*/domain/**`, `lib/**`
    - `api/**`
    - `config/**`
  - a component accepts `className` but does not pass it to a stable root
    element (unused prop or inconsistent inner-child application).
  - a feature section/page repeatedly uses `className` as a layout escape
    hatch.
  - a composite accumulates slot-style prop explosion (`headerClassName`,
    `rowClassName`, `cellClassName`, etc.) without multiple real call sites
    needing them.
  - `className` is used to encode domain state (for example `taskCompleted`,
    `projectArchived`) instead of being derived internally from domain
    props/state.
- Evaluate smallest compliant action in this order:
  1. remove unused `className` props (and update callers)
  2. forward `className` correctly to one stable DOM root (preferred for
     `ui/primitives/**` and most `ui/composites/**`)
  3. replace deep external styling needs with composition (wrapper in composing
     layer)
  4. extract reusable UI wrapper/composite when multiple call sites style the
     same structural pattern
  5. consolidate style extension by reusing canonical repo merge helper
     (for example `lib/cn.ts`) when present
  6. stop/block when fixing needs structural expansion (new top-level folders,
     cross-home moves, new dependencies, or second styling system) and return
     scoped expansion request.

### Forbidden

- Adding `className` for consistency to components that should not be style
  extensible.
- Introducing new styling prop patterns (`sx`, `styles`, etc.) in repos already
  using `className`.
- Adding many slot-level class props in composites without clear multi-call-site
  evidence.

### Notes

- Prefer remove/forward over introducing new APIs.
- Repeated external styling overrides on feature sections signal boundary smell;
  consider extracting a composite or composing wrappers at page level.

---

## Rule: Refactor — `aria-label` Hygiene and Correct Placement
**Rule ID:** rrf-a11y-aria-label-hygiene  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevent ARIA misuse while ensuring every control has a correct
accessible name.

### Requirement

- Detect `aria-label` as incorrect/suspect when any is true:
  - added to non-interactive wrappers (`div`, `section`, `span`) without real
    accessible-name requirement.
  - added to interactive element that already has a good visible label.
  - accepted by container components that do not own the interactive element.
  - added in shared UI with hardcoded domain semantics.
  - generic/wrong naming (`Button`, `Click`, `Icon`) or labels that do not
    reflect current state/action.
  - used where `<label>`/`aria-labelledby` should be used because visible text
    already exists.
  - added where native semantics already provide correct naming/role and ARIA
    makes it worse.
- Evaluate smallest compliant action in this order:
  1. remove redundant/incorrect `aria-label` when correct accessible name
     already exists
  2. move accessible-name ownership to correct layer:
     - feature sections/pages define domain labels
     - shared primitives/composites accept+forward ARIA props
  3. replace with better mechanism:
     - use `<label>`/`aria-labelledby` for labeled inputs
     - use `aria-label` for icon-only controls
  4. fix wording to specific, state-correct labels
  5. add missing accessible name for icon-only/custom controls via primitive
     pass-through or visible label
  6. stop/block when fixes need structural scope expansion and return scoped
     expansion request.

### Forbidden

- Blanket adding `aria-label` across UI.
- Hardcoding domain-specific accessible names in shared `ui/**`.
- Leaving interactive controls without any accessible name.
- Adding ARIA that conflicts with native semantics (wrong role/name
  combinations).

### Notes

- For icon-only controls, `aria-label` is usually correct.
- Prefer `aria-labelledby` when visible text exists and should name the
  control.
- When label meaning depends on state, ensure accessible name updates with
  current state.

---

# Feature-to-Composite Promotion

## Summary

Defines deterministic safeguards for promoting feature-owned components into
shared UI composites during refactor planning.

---

## Rule: Refactor — Promote Feature Components to Shared UI Composites Safely
**Rule ID:** rrf-promote-feature-to-composite  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Enables promote-to-shared-composite refactors without domain
leakage, parallel homes, or churn-heavy migration.

### Requirement

- Promotion from feature-owned component to `ui/composites/**` is allowed only
  when all eligibility checks pass:
  1. cross-domain reuse evidence exists (2+ domains/features or clearly
     imminent in current scoped plan),
  2. component is a UI pattern and can be described without domain terms,
  3. domain dependencies are removable with small changes,
  4. API remains clean without domain mode flags (use slots/children/render
     props for variability),
  5. promotion does not create a new concern home and uses existing
     authoritative UI composite home.
- Promotion action order must be:
  1. split responsibilities so feature remains owner of domain meaning
     (domain mapping/rules/copy/hooks),
  2. extract domain-agnostic composite in `ui/composites/**` with generic name,
     minimal UI-only state, and root `className` support,
  3. add thin feature adapter wrapper when domain wiring remains needed,
  4. replace call sites incrementally inside approved scope only.
- Naming and placement requirements:
  - shared composite names must be domain-agnostic and pattern-based,
  - composite must live in existing `ui/composites/**` home (or
    gravity-equivalent),
  - extracted helpers stay local unless reused by 2+ domains and pure; then
    promote to `lib/**`.
- Validation gates before accept:
  1. boundary audit:
     - `ui/**` imports only allowed shared layers (`ui/**`, generic `hooks/**`,
       `lib/**`),
     - no `features/**`/`api/**`/`store/**` import leakage into shared UI.
  2. behavior preservation:
     - visible UI behavior, interaction, keyboard/focus, and state/routing
       strategy remain unchanged.
  3. scope audit:
     - remain within caps unless approved expansion,
     - no new dependencies,
     - no new top-level folders.
  4. naming audit:
     - no domain terms in shared composite names/exports.
- Deterministic defaults:
  - if promotion certainty is low, default to feature-local duplication with
    primitive reuse.
  - if sharing requires more than 2 new props or any domain mode flags, default
    to no promotion.
  - if only shell/layout pattern is reusable, extract shell only and keep
    feature-owned content injection.
- If any gate fails, output must be `blocked` with explicit `required_fixes`.

### Forbidden

- Promoting when disqualifiers exist:
  - component imports from `features/**`, `api/**`, `store/**`, or `pages/**`,
  - component encodes domain meaning in naming/props/hardcoded copy,
  - generalization requires domain flags, large prop matrices, or
    config-object abstraction,
  - expected divergence remains high across domains,
  - move requires broad cross-concern migration or unapproved scope-cap
    expansion.
- Using promotion as a pretext for broad unrelated migrations.

### Notes

- Shared composite ownership is presentation concern only; feature layers retain
  domain semantics and domain behavior ownership.

---

# Naming Hygiene

## Summary

Defines deterministic naming-hygiene checks for refactor plans so component/file
naming remains searchable, layer-aligned, and domain-safe.

---

## Rule: Refactor — Naming Hygiene and Correct Placement
**Rule ID:** rrf-naming-hygiene  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents naming drift and misplaced ownership during refactors by
aligning with established naming contracts.

### Requirement

- Treat naming as incorrect/suspect when any is true:
  - component primary export name does not match defining file name (except
    framework-required defaults),
  - domain-named components are placed under `ui/**`,
  - suffix/name does not match responsibility:
    - route orchestrators missing `*Page` convention (or framework route
      equivalent),
    - domain-aware orchestration not using section/panel conventions,
    - reusable UI patterns using domain nouns instead of role/pattern names,
  - hooks not using `use*` naming,
  - DTO naming/contracts violating `*.dto.ts` or `*Dto` conventions in areas
    where they apply,
  - mixed naming dialect in one area (for example unstable mixing of
    `*Shell`/`*Layout`/`*Scaffold` without local convention),
  - junk-drawer naming that hides responsibility (`Common*`, `Shared*`,
    `Utils*`, `Helper*`, `Wrapper*`, `Thing*`, etc.).
- For suspect naming, refactor should evaluate smallest compliant action in this
  order:
  1. rename file/export to match one-file one-primary-export contract,
  2. rename component to responsibility-aligned, domain-agnostic pattern name
     when in `ui/**`,
  3. relocate ownership to correct layer when domain naming reveals domain
     behavior ownership,
  4. keep local convention where explicit gravity/local standard exists instead
     of introducing a second dialect,
  5. stop/block and return scoped expansion request when correction requires
     broad migration or scope-cap breach.
- Any accepted naming refactor must preserve behavior and remain within current
  scope-governor limits.
- Refactor naming decisions must be consistent with:
  - `rid-naming-discoverability` from
    `react-implementation-discipline/rules/150_naming_discoverability.md`
  - `sr-ownership-naming` from `shared/rules/40_ownership_naming.md`.

### Forbidden

- Renaming for style preference only when no ownership/discoverability issue
  exists.
- Introducing new naming vocabularies in a local area with clear existing
  convention.
- Keeping domain semantics in shared UI names to avoid moving ownership.
- Performing churn-heavy rename waves outside approved scope.

### Notes

- Naming corrections should optimize ripgrep discoverability and ownership
  clarity first; cosmetic consistency is secondary.
