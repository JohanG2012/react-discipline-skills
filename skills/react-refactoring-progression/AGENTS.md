<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-27
-->

# React Refactoring Progression — Agent Rules

## Table of contents
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: DOM Rendering and Primitive Discipline Index [sr-dom-rendering-and-primitives]](#rule-dom-rendering-and-primitive-discipline-index)
- [Rule: DOM Rendering Boundaries [sr-dom-rendering-boundaries]](#rule-dom-rendering-boundaries)
- [Rule: Primitive Creation Threshold and Raw DOM Usage [sr-primitive-creation-threshold]](#rule-primitive-creation-threshold-and-raw-dom-usage)
- [Rule: Shared UI Domain Discipline [sr-shared-ui-domain-discipline]](#rule-shared-ui-domain-discipline)
- [Rule: Prop Count Caps and Escalation Actions [sr-prop-count-caps]](#rule-prop-count-caps-and-escalation-actions)
- [Rule: Mega-File Triage and Extraction Plan Index [sr-mega-file-triage]](#rule-mega-file-triage-and-extraction-plan-index)
- [Rule: Mega-File Trigger and Safety Baseline [sr-mega-file-trigger-safety]](#rule-mega-file-trigger-and-safety-baseline)
- [Rule: Mega-File Extraction Ordering [sr-mega-file-extraction-order]](#rule-mega-file-extraction-ordering)
- [Rule: Mega-File Safety Checks and Output Contract [sr-mega-file-validation-output]](#rule-mega-file-safety-checks-and-output-contract)
- [Rule: Prop Grouping Discipline [sr-prop-grouping-discipline]](#rule-prop-grouping-discipline)
- [Rule: i18n Extraction for User-Facing UI Text [sr-i18n-text-extraction]](#rule-i18n-extraction-for-user-facing-ui-text)
- [Rule: `*Like` and `Maybe<T>` Discipline Index [sr-type-like-maybe]](#rule-like-and-maybet-discipline-index)
- [Rule: `*Like` Boundary Discipline [sr-type-like-boundary]](#rule-like-boundary-discipline)
- [Rule: `Maybe<T>` Semantics Discipline [sr-type-maybe-semantics]](#rule-maybet-semantics-discipline)
- [Rule: Domain Type Integrity [sr-domain-type-integrity]](#rule-domain-type-integrity)
- [Rule: Test Selectors and `aria-label` Usage [sr-tests-aria-label-selectors]](#rule-test-selectors-and-aria-label-usage)
- [Rule: No Duplicate UI Patterns (Composites) [sr-no-duplicate-ui-patterns]](#rule-no-duplicate-ui-patterns-composites)
- [Rule: Browser Side-Effects and Routing Boundary [sr-browser-side-effects-boundary]](#rule-browser-side-effects-and-routing-boundary)
- [Rule: Empty Catch and Swallowed Error Discipline [sr-no-empty-catch]](#rule-empty-catch-and-swallowed-error-discipline)
- [Rule: JSX Logic Density and Handler Extraction [sr-jsx-logic-density]](#rule-jsx-logic-density-and-handler-extraction)
- [Rule: Time and "Now" Semantics in Derived State [sr-time-derived-state]](#rule-time-and-now-semantics-in-derived-state)
- [Rule: Hidden Interactive Controls and Accessibility Contract [sr-hidden-interactive-controls]](#rule-hidden-interactive-controls-and-accessibility-contract)
- [Rule: No Cross-Feature Dependencies [sr-features-no-cross-deps]](#rule-no-cross-feature-dependencies)
- [Rule: Type Assertion Discipline (`as T`) [sr-types-assertion-discipline]](#rule-type-assertion-discipline-as-t)
- [Rule: Double Type Assertion Discipline (`as unknown as T`) [sr-types-double-assertion]](#rule-double-type-assertion-discipline-as-unknown-as-t)
- [Rule: Deep Relative Imports Should Trigger `@/` Alias Suggestion [sr-import-alias-suggestion]](#rule-deep-relative-imports-should-trigger-alias-suggestion)
- [Rule: Umbrella Feature Split and Domain Extraction [sr-feature-split-domain-extraction]](#rule-umbrella-feature-split-and-domain-extraction)
- [Rule: What May Live in `features/<domain>/components/` [sr-feature-components-scope]](#rule-what-may-live-in-featuresdomaincomponents)
- [Rule: No `api/` Inside Features When Canonical API Home Exists [sr-no-feature-api-home]](#rule-no-api-inside-features-when-canonical-api-home-exists)
- [Rule: No `views/` or `*View` in Features [sr-no-feature-views]](#rule-no-views-or-view-in-features)
- [Rule: File Name Length Discipline [sr-filename-length]](#rule-file-name-length-discipline)
- [Rule: Output Mode Resolution and Display Safety [sr-output-mode-resolution]](#rule-output-mode-resolution-and-display-safety)
- [Rule: Prop Drilling Discipline and Escalation [sr-props-drilling-discipline]](#rule-prop-drilling-discipline-and-escalation)
- [Rule: Optional Extension Scope [rrp-overview-scope]](#rule-optional-extension-scope)
- [Rule: Tiered Planning Sequence [rrp-process]](#rule-tiered-planning-sequence)
- [Rule: Structured Refactor Output [rrp-output]](#rule-structured-refactor-output)
- [Rule: Behavior Preservation Enforcement [rrp-validation-gates]](#rule-behavior-preservation-enforcement)
- [Rule: Bounded Scope Execution [rrp-scope-governor]](#rule-bounded-scope-execution)
- [Rule: Anti-Pattern Findings [rrp-detection]](#rule-anti-pattern-findings)
- [Rule: Script-Assisted Detection Candidates [rrp-detection-assist-scripts]](#rule-script-assisted-detection-candidates)
- [Rule: Semantic Duplication Qualification [rrp-semantic-duplication]](#rule-semantic-duplication-qualification)
- [Rule: Interaction Boundaries [rrp-interactions]](#rule-interaction-boundaries)
- [Rule: Finalized Tier Model [rrp-progression-model]](#rule-finalized-tier-model)
- [Rule: Pattern Type Classification [rrp-dup-pattern-types]](#rule-pattern-type-classification)
- [Rule: Two-Signal Qualification Gate [rrp-dup-two-signals]](#rule-two-signal-qualification-gate)
- [Rule: Structural Evidence Quality [rrp-dup-evidence]](#rule-structural-evidence-quality)
- [Rule: Existing Home Alignment [rrp-dup-home-alignment]](#rule-existing-home-alignment)
- [Rule: Slots Over Prop Matrix [rrp-dup-slots-over-props]](#rule-slots-over-prop-matrix)
- [Rule: One-Level-Up Preference [rrp-dup-one-level-up]](#rule-one-level-up-preference)
- [Rule: Keep-Separate by Default Under High Risk [rrp-dup-keep-separate]](#rule-keep-separate-by-default-under-high-risk)
- [Rule: Locality Preference [rrp-dup-locality]](#rule-locality-preference)
- [Rule: Cognitive Load Guard [rrp-dup-cognitive-load]](#rule-cognitive-load-guard)
- [Rule: Refactor Radius Bound [rrp-dup-refactor-radius]](#rule-refactor-radius-bound)
- [Rule: Micro Extraction Before Mega Extraction [rrp-dup-micro-before-mega]](#rule-micro-extraction-before-mega-extraction)
- [Rule: Cluster Output Completeness [rrp-dup-output]](#rule-cluster-output-completeness)
- [Rule: Actionable Next Actions [rrp-dup-next-actions]](#rule-actionable-next-actions)
- [Rule: Keep-Separate Output Clarity [rrp-dup-keep-separate-output]](#rule-keep-separate-output-clarity)
- [Rule: Refactor — `className` Hygiene and Correct Placement [rrp-ui-classname-hygiene]](#rule-refactor-classname-hygiene-and-correct-placement)
- [Rule: Refactor — `aria-label` Hygiene and Correct Placement [rrp-a11y-aria-label-hygiene]](#rule-refactor-aria-label-hygiene-and-correct-placement)
- [Rule: Refactor — Promote Feature Components to Shared UI Composites Safely [rrp-promote-feature-to-composite]](#rule-refactor-promote-feature-components-to-shared-ui-composites-safely)
- [Rule: Refactor — Naming Hygiene and Correct Placement [rrp-naming-hygiene]](#rule-refactor-naming-hygiene-and-correct-placement)
- [Rule: Implementation-First Test Suggestion Priority [rrp-test-suggestion-priority]](#rule-implementation-first-test-suggestion-priority)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-refactoring-progression` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-layer-contracts
- sr-file-size-guidance
- sr-enforcement-heuristics
- sr-dom-rendering-and-primitives
- sr-dom-rendering-boundaries
- sr-primitive-creation-threshold
- sr-shared-ui-domain-discipline
- sr-prop-count-caps
- sr-mega-file-triage
- sr-mega-file-trigger-safety
- sr-mega-file-extraction-order
- sr-mega-file-validation-output
- sr-prop-grouping-discipline
- sr-i18n-text-extraction
- sr-type-like-maybe
- sr-type-like-boundary
- sr-type-maybe-semantics
- sr-domain-type-integrity
- sr-tests-aria-label-selectors
- sr-no-duplicate-ui-patterns
- sr-browser-side-effects-boundary
- sr-no-empty-catch
- sr-jsx-logic-density
- sr-time-derived-state
- sr-hidden-interactive-controls
- sr-features-no-cross-deps
- sr-types-assertion-discipline
- sr-types-double-assertion
- sr-import-alias-suggestion
- sr-feature-split-domain-extraction
- sr-feature-components-scope
- sr-no-feature-api-home
- sr-no-feature-views
- sr-filename-length
- sr-output-mode-resolution
- sr-props-drilling-discipline
- rrp-overview-scope
- rrp-process
- rrp-output
- rrp-validation-gates
- rrp-scope-governor
- rrp-detection
- rrp-detection-assist-scripts
- rrp-semantic-duplication
- rrp-interactions
- rrp-progression-model
- rrp-dup-pattern-types
- rrp-dup-two-signals
- rrp-dup-evidence
- rrp-dup-home-alignment
- rrp-dup-slots-over-props
- rrp-dup-one-level-up
- rrp-dup-keep-separate
- rrp-dup-locality
- rrp-dup-cognitive-load
- rrp-dup-refactor-radius
- rrp-dup-micro-before-mega
- rrp-dup-output
- rrp-dup-next-actions
- rrp-dup-keep-separate-output
- rrp-ui-classname-hygiene
- rrp-a11y-aria-label-hygiene
- rrp-promote-feature-to-composite
- rrp-naming-hygiene
- rrp-test-suggestion-priority

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# DOM Rendering and Primitive Discipline

## Summary
Defines rendering boundaries, primitive-creation thresholds, and shared-UI
domain discipline as separate concerns.

---

## Rule: DOM Rendering and Primitive Discipline Index
**Rule ID:** sr-dom-rendering-and-primitives  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves backward-compatible entrypoint while delegating
enforcement to narrowly scoped rules.

### Requirement

- When this rule is in scope, follow all of:
  - `sr-dom-rendering-boundaries`,
  - `sr-primitive-creation-threshold`,
  - `sr-shared-ui-domain-discipline`.

### Forbidden

- Treating this index rule as sufficient without enforcing the referenced
  detailed rules.

---

## Rule: DOM Rendering Boundaries
**Rule ID:** sr-dom-rendering-boundaries  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents JSX/DOM leakage into logic/data layers.

### Requirement

- Only these layers may render JSX/DOM:
  - `ui/primitives/**`
  - `ui/composites/**`
  - `features/*/sections/**`
  - `pages/**`
  - `core/**` (layout composition only, such as app shell/providers)
- These layers must remain DOM-free:
  - `api/**`
  - `lib/**`
  - `store/**`
  - `hooks/**`
  - `config/**`
- Hooks must return state/functions only and must not render JSX.

### Forbidden

- Rendering JSX from `api/**`, `lib/**`, `store/**`, `hooks/**`, or `config/**`.

---

## Rule: Primitive Creation Threshold and Raw DOM Usage
**Rule ID:** sr-primitive-creation-threshold  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps raw DOM use pragmatic while preventing repeated semantic
reimplementation.

### Requirement

- Prefer existing reusable primitives (for example `Button`, `Input`, `Card`)
  before adding repeated raw semantic elements.
- Raw HTML is allowed when any is true:
  - element is structural/layout-only (`div`, `section`, `span`, etc.),
  - no suitable primitive exists,
  - usage is one-off and not expected to repeat,
  - usage is highly domain-specific and should not leak into `ui/**`.
- Create a primitive in `ui/primitives/**` when any is true:
  - the same semantic element pattern appears across 2+ features/domains,
  - a shared composite needs it as a building block,
  - 2+ near-identical implementations copy style/behavior,
  - accessibility/keyboard/focus/label wiring is repeatedly reimplemented,
  - it is a core UI building block (for example button/input/select/checkbox/
    radio/textarea/link/card/modal/tabs/badge/tooltip base),
  - repeated styling tokens/classes are used to enforce consistency.

### Forbidden

- Duplicating semantic elements already represented by existing primitives.
- Bypassing existing primitives with repeated ad-hoc raw semantic controls.

---

## Rule: Shared UI Domain Discipline
**Rule ID:** sr-shared-ui-domain-discipline  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared UI reusable and prevents domain/transport leakage.

### Requirement

- Components in `ui/**` may render valid HTML but must remain domain-agnostic.
- Shared UI must not import from `features/**`.
- Shared UI owns:
  - semantic correctness,
  - accessibility wiring,
  - basic visual state presentation (disabled/loading/selected).
- Shared UI does not own:
  - business logic,
  - domain rules,
  - feature semantics.
- When invalid placement is detected, refactoring should:
  1. move JSX into valid presentation layers,
  2. split logic from markup (`domain/lib` for logic, `sections/ui` for markup),
  3. prefer behavior-preserving extraction within active scope.

### Forbidden

- Hardcoding domain semantics in shared `ui/**`.
- Using shared UI as a transport or business-logic owner.
- Introducing new top-level UI homes while remediating domain leakage.

---

# Prop Count Caps

## Summary
Defines soft prop-surface caps and mandatory escalation actions to prevent prop
soup and abstraction creep.

---

## Rule: Prop Count Caps and Escalation Actions
**Rule ID:** sr-prop-count-caps  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents prop soup and abstraction creep by enforcing
responsibility boundaries and preferring composition/wrappers over flag
matrices.

### Requirement

- Soft prop caps by layer/type (not hard compile failures):
  - `ui/primitives/**`: max 10 component-defined props
    - excludes native passthrough props from
      `ComponentPropsWithoutRef<...>`-style extension.
  - `ui/composites/**`: max 12 props.
  - `features/*/components/**`: max 12 props.
  - `features/*/sections/**`: max 15 props.
  - `core/**` shells/layout: max 8 props.
  - `pages/**`: max 8 props (prefer near-zero; pages should not be generic
    reusable components).
- When exceeding a cap, choose at least one escalation action and record it in
  planning/refactor metadata:
  1. split by responsibility (extract subcomponents),
  2. replace flags with composition (`children`, slots, render props),
  3. introduce feature-owned wrapper to keep shared UI generic,
  4. group props only when compliant with `sr-prop-grouping-discipline`,
  5. demote from shared UI when domain divergence is the driver.
- Layer-specific escalation constraints:
  - `ui/composites/**` must not exceed cap via domain mode flags
    (`variant="tasks|projects"`, `mode/context` matrices); prefer feature
    wrapper or feature-local duplication.
  - `ui/primitives/**` should remain thin via native passthrough plus minimal
    ergonomic props.
  - `pages/**` should not accumulate prop surfaces; extract section/composite
    instead.

### Forbidden

- Exceeding a cap silently without documenting chosen escalation action.
- Violating `sr-prop-grouping-discipline` (for example domain models hidden in
  grouped objects passed into `ui/**`).
- Growing shared composites through large flag matrices or domain switches.
- Designing one-component-to-rule-them-all APIs that hide unrelated
  responsibilities behind props.

### Notes

- Prop count is a complexity proxy; responsibility boundaries are the core
  signal.
- If temporary cap exceedance is unavoidable, record follow-up refactor scope
  instead of allowing continuing prop-surface growth.

---

# Mega-File Triage and Extraction Plan

## Summary
Defines mandatory triage and extraction sequencing when touched files exceed
safe size/responsibility thresholds.

---

## Rule: Mega-File Triage and Extraction Plan Index
**Rule ID:** sr-mega-file-triage  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves stable entrypoint while delegating to focused triage,
extraction-sequencing, and validation-output rules.

### Requirement

- When this rule is in scope, enforce all of:
  - `sr-mega-file-trigger-safety`,
  - `sr-mega-file-extraction-order`,
  - `sr-mega-file-validation-output`.

### Forbidden

- Treating this index rule as sufficient without enforcing the referenced
  mega-file rules.

---

## Rule: Mega-File Trigger and Safety Baseline
**Rule ID:** sr-mega-file-trigger-safety  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic trigger conditions and behavior-preserving
triage defaults.

### Requirement

- Trigger mega-file triage when any touched file is:
  - over 600 LOC (hard stop threshold), or
  - over 400 LOC with clear multi-responsibility signals, or
  - explicitly flagged as an offender (for example a 1500 LOC component), or
  - below threshold but showing prior extraction pattern with obvious same-pattern
    leftovers.
- Freeze behavior and reduce risk surface:
  - treat work as refactor-only unless user explicitly requests behavior changes,
  - preserve output, props, and side effects by default,
  - plan incremental extraction steps, not a rewrite.
- Establish bounded target:
  - declare `anchor_component` (path + export),
  - declare `extraction_budget` (allowed file touches under caps),
  - declare `end_state_goal` as anchor `<= 250-400` LOC (or `<= 600` when
    explicitly timeboxed),
  - if caps block ideal target, deliver in-cap reduction and include
    `scope_expansion_needed[]`.
- Continue extraction when prior-pattern leftovers exist:
  - dropping below 400/600 is not a stop condition by itself,
  - stop when same-pattern leftovers are exhausted or caps are reached.

### Forbidden

- Treating line-count drop alone as stop condition when same-pattern leftovers
  remain and scope budget allows continued extraction.
- Ignoring declared behavior-preserving default in triage-only runs.

---

## Rule: Mega-File Extraction Ordering
**Rule ID:** sr-mega-file-extraction-order  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps decomposition predictable and low-risk.

### Requirement

- Execute extraction in this exact sequence:
  1. Step A, pure logic first:
     - extract constants, pure helpers, component-local types,
     - promote to `lib/**` only when reused by 2+ domains and pure,
     - promote to `features/<domain>/domain/**` only when domain behavior is
       encoded.
  2. Step B, presentational subcomponents:
     - extract clear JSX blocks (especially repeated blocks),
     - keep subcomponents local unless cross-feature reuse is clear,
     - use prefixed subcomponent naming (`ComponentNameRow`, not `Row`).
  3. Step C, hook/state extraction:
     - extract complex derived state/effect/event wiring to local hook files,
     - move to `features/<domain>/hooks/**` only when truly feature-level.
  4. Step D, ownership split last:
     - do not use mega-file triage as migration shortcut,
     - cross-home moves only under explicit migration scope after decomposition.

### Forbidden

- Reordering extraction steps to perform high-risk structural migration first.
- Using mega-file triage as justification for broad architecture moves.

---

## Rule: Mega-File Safety Checks and Output Contract
**Rule ID:** sr-mega-file-validation-output  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces post-step safety evidence and deterministic output
shape.

### Requirement

- After each extraction step, verify:
  - TypeScript still compiles (or would compile under existing config),
  - imports remain boundary-compliant,
  - anchor public API (props/exports) is unchanged unless explicitly requested,
  - no runtime behavior change unless requested,
  - tests are updated only when behavior changes and suite exists.
- Output when triggered must include:
  - phased A->D plan with file-touch list per phase,
  - declaration: `in_cap_minimal_reduction` (default) or
    `scope_expansion_needed`,
  - implementation preference: unified diff for mega anchor edits and full
    content for newly extracted files.
- Keep extraction anti-churn constraints explicit:
  - no `shared/common` dumping-ground creation,
  - no new domain logic in `ui/**`,
  - no fetching outside canonical endpoint layer,
  - no broad formatting-only churn,
  - no new mode/flag matrices to force reuse,
  - no new barrels where local area does not already use barrels.

### Forbidden

- Skipping required safety checks after extraction steps.
- Returning mega-file plan output without phased touches and plan declaration.
- Introducing anti-churn violations under mega-file triage scope.

---

# Prop Grouping Discipline

## Summary
Defines when grouping component props is valid versus when it becomes boundary
bypass or prop-surface concealment.

---

## Rule: Prop Grouping Discipline
**Rule ID:** sr-prop-grouping-discipline  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps prop grouping intentional and cohesive while preventing
config-bag anti-patterns that hide responsibility drift.

### Requirement

- Group props only when the grouped shape represents one cohesive concern (for
  example `pagination`, `sorting`, `filters`).
- Group names must be concern-specific and explicit; avoid generic umbrella
  names.
- Grouped props in `ui/**` must remain domain-agnostic and must not carry domain
  entities, domain IDs, or domain behavior flags.
- Prefer composition (`children`, slots, render props) or feature-owned wrappers
  when grouping would otherwise mix unrelated concerns.
- If grouping is used as an escalation action for cap exceedance, reference this
  rule from `sr-prop-count-caps` plan/refactor notes.

### Forbidden

- Generic junk-drawer groups such as `config`, `options`, or `settings` that
  mix unrelated concerns.
- Grouping unrelated data, callbacks, and mode switches solely to reduce visible
  top-level prop count.
- Using grouped objects to pass domain-specific models into shared `ui/**`
  components.
- Using prop grouping to bypass layer boundaries or hide shared-composite domain
  switches.

### Notes

- This rule defines grouping correctness; prop-surface thresholds and escalation
  triggers are defined in `sr-prop-count-caps`.

---

# i18n Text Extraction

## Summary
Defines required extraction behavior for user-facing UI text when a canonical
i18n folder already exists in the repository.

---

## Rule: i18n Extraction for User-Facing UI Text
**Rule ID:** sr-i18n-text-extraction  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hardcoded copy drift and keeps user-facing text
maintainable, localizable, and consistent.

### Requirement

- Trigger this rule when both are true:
  - a canonical i18n home exists (for example `i18n/**`, `src/i18n/**`, or
    gravity-equivalent localization home),
  - user-facing UI text literals are found in touched presentation files (for
    example `pages/**`, `features/*/sections/**`, `ui/**`).
- Extract user-facing UI text from touched files into the existing i18n home
  and reference it by translation key.
- Apply extraction to modified/new UI copy in scope; do not perform unrelated
  repository-wide localization sweeps unless explicitly requested.
- Preserve behavior and message meaning during extraction:
  - keep interpolation/variables equivalent,
  - keep state-conditional copy equivalent,
  - keep accessibility text (labels for user-facing controls) in i18n when
    localization is supported by existing repo patterns.
- Keep canonical ownership singular:
  - reuse existing i18n structure and conventions,
  - do not create a second localization home.
- Allow inline literals only when non-user-facing (for example internal debug
  logs, test-only labels/selectors, class names, protocol constants, or other
  machine-facing strings).

### Forbidden

- Leaving new or modified user-facing UI text literals inline in touched
  components when an i18n home exists.
- Introducing a second localization folder/pattern when a canonical one already
  exists.
- Mixing key-based and hardcoded user-facing variants of the same message in
  the same flow without explicit product requirement.

### Notes

- This rule governs extraction when localization infrastructure already exists;
  it does not mandate introducing i18n infrastructure into repositories that do
  not already have it.

---

# `*Like` and `Maybe<T>` Type Discipline

## Summary
Splits boundary flexibility and optionality semantics into separate rules while
keeping strict domain integrity requirements explicit.

---

## Rule: `*Like` and `Maybe<T>` Discipline Index
**Rule ID:** sr-type-like-maybe  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves backward-compatible entrypoint while delegating to
single-focus type rules.

### Requirement

- When this rule is in scope, follow all of:
  - `sr-type-like-boundary`,
  - `sr-type-maybe-semantics`,
  - `sr-domain-type-integrity`.

### Forbidden

- Applying this index rule without enforcing the referenced type-discipline
  rules.

---

## Rule: `*Like` Boundary Discipline
**Rule ID:** sr-type-like-boundary  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Restricts structural compatibility types to boundary layers.

### Requirement

- `*Like` types are allowed only when all are true:
  - they exist in boundary-oriented homes (`api/dto/**`,
    `features/<domain>/adapters/**`, input parsing/normalization layers),
  - they model external or pre-normalized input shape,
  - they are mapped immediately to canonical domain models,
  - they are not exported as canonical domain contracts.
- If a `*Like` type is introduced, all are required:
  - canonical mapped model exists,
  - mapper exists in same feature boundary,
  - mapping occurs before UI rendering or store persistence.

### Forbidden

- Using `*Like` inside `features/<domain>/domain/**`, `store/**`, or shared
  `ui/**`.
- Using `*Like` to avoid defining canonical domain models.
- Passing `*Like` deep into pages/sections without normalization.
- Naming canonical models as `SomethingLike`.

---

## Rule: `Maybe<T>` Semantics Discipline
**Rule ID:** sr-type-maybe-semantics  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces one explicit repository-wide optionality semantic.

### Requirement

- `Maybe<T>` is allowed only when all are true:
  - defined once in a canonical shared location (for example `src/lib/types.ts`),
  - semantics are exactly one of:
    - `type Maybe<T> = T | null`, or
    - `type Maybe<T> = T | undefined`,
  - repository uses one meaning consistently.
- Allowed contexts:
  - API response normalization,
  - feature-boundary pre-validation states,
  - explicit domain states where absence is meaningful.

### Forbidden

- Mixing `null` and `undefined` semantics arbitrarily.
- Using `Maybe<T>` to bypass validation.
- Defining multiple `Maybe` aliases in different modules.

---

## Rule: Domain Type Integrity
**Rule ID:** sr-domain-type-integrity  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps domain-layer contracts strict and canonical.

### Requirement

- In `features/<domain>/domain/**`:
  - types represent validated canonical models,
  - fields are required unless domain semantics explicitly model absence.
- `Maybe<T>` in domain models is allowed only when domain semantics require true
  optional state.
- Treat as architectural smell when:
  - `*Like` appears outside boundaries,
  - `Maybe<T>` appears broadly in `ui/**` or `store/**`,
  - canonical models overuse optional fields without domain justification.
- Deterministic defaults:
  - prefer canonical types with explicit mapping,
  - prefer required domain fields over optional wrappers by default.

### Forbidden

- Replacing canonical domain models with `*Like` types.
- Using `Maybe<T>` to keep post-validation required fields weak.
- Letting domain logic depend on structural compatibility types.

---

# Test Selectors and `aria-label` Usage

## Summary
Defines stable, user-centric test selector priorities while preventing
accessibility attributes from being used as test-only hooks.

---

## Rule: Test Selectors and `aria-label` Usage
**Rule ID:** sr-tests-aria-label-selectors  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keep tests user-centric and stable without abusing accessibility
attributes as test-only hooks.

### Requirement

- Scope:
  - This rule applies to test strategy and test artifacts across unit,
    integration, and end-to-end coverage when execution skills propose or modify
    tests/selectors.
- Selector priority order (use highest viable):
  1. role plus accessible name (preferred),
  2. visible label selectors (inputs/controls),
  3. `aria-label` / accessible-name selectors (conditional),
  4. `data-testid` (fallback for stability/ambiguity),
  5. CSS classes or DOM-structure selectors (last resort; discouraged).
- `aria-label` selectors are allowed only when all are true:
  - the element is meant to be accessible by name (for example icon-only button
    or unlabeled control),
  - the label is semantic and stable (for example `Close dialog`, `Open menu`,
    `Delete task`),
  - selector stability is acceptable for localization/copy volatility in current
    repository context,
  - query scope resolves to an unambiguous target.
- `data-testid` fallback:
  - when stable user-centric selectors are not viable due to localization churn,
    repeated controls, virtualization, unstable icon-only naming, or ambiguous
    accessible names, use dedicated `data-testid`,
  - `data-testid` must be semantic and deterministic (for example
    `task-delete-button`, `inbox-sync`, `pin-lock-submit`),
  - `data-testid` must not encode styling or DOM structure,
  - `data-testid` should be scoped to the owning feature/component boundary.
- Accessibility integrity:
  - do not add `aria-label` solely for testing,
  - add `aria-label` only when it improves real accessibility (for example
    unlabeled controls, icon-only buttons, custom inputs),
  - when visible label association exists, tests should prefer that association
    instead of redundant `aria-label`.
- Enforcement heuristics:
  - frequent test failures from copy tweaks are a selector-smell signal,
  - heavy `aria-label` string selection across tests indicates fragility,
  - added `aria-label` attributes with no accessibility value indicate misuse,
  - selecting by plain text when role/name query is available indicates missed
    user-centric selection.
- Deterministic defaults:
  - prefer role-based queries first,
  - when label stability is doubtful, prefer `data-testid` over `aria-label`.

### Forbidden

- Targeting `aria-label` when label text is product/marketing copy likely to
  change.
- Targeting user-facing `aria-label` values as primary hooks in localized (or
  localization-ready) surfaces without stability controls.
- Injecting `aria-label` only to satisfy tests.
- Relying on fragile ordering among similarly named elements when selector scope
  is ambiguous.
- Defaulting to CSS class/DOM-structure selectors when stable higher-priority
  selectors are available.

---

# No Duplicate UI Patterns (Composites)

## Summary
Prevents parallel implementations of the same reusable interaction pattern and
enforces reuse-first consolidation.

---

## Rule: No Duplicate UI Patterns (Composites)
**Rule ID:** sr-no-duplicate-ui-patterns  
**Priority:** MUST  
**Applies to:** react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevent parallel implementations of the same UI interaction
pattern that cause drift, inconsistent behavior, and refactor churn.

### Requirement

- Definition: a duplicate UI pattern exists when all are true:
  1. same interaction model (for example trigger -> overlay/popover/menu ->
     selectable actions -> close/dismiss),
  2. same structural UI shape (equivalent composition of primitives/composites),
  3. differences are mostly content/config (labels, disabled rules, callbacks,
     minor styling),
  4. shared abstraction is feasible without domain leakage (slots/children/render
     props, no domain mode flags).
- Reuse-first consolidation behavior:
  - reuse the existing composite as-is when viable,
  - if small gaps exist, update existing composite via slots/children/render
    props, content injection, or small generic props (within caps),
  - do not introduce or expand a second parallel copy for the same pattern.
- New composite allowed only when at least one is true:
  - fit is low (`fit < 6`) and forcing reuse would leak abstractions,
  - long-term behavior divergence is expected to be significant,
  - reuse would require domain mode flags or cross-feature coupling,
  - existing composite is clearly the wrong abstraction concern.
- Evidence requirement when choosing new:
  - record explicit `not_found` or wrong-fit evidence against existing
    candidate(s).
- Kebab/actions menu canonical guidance:
  - maintain one canonical reusable composite for this pattern
    (for example `KebabMenu`/`ActionsMenu`),
  - feature behavior is injected via item data/callbacks/optional slots,
  - avoid domain enum-mode flags in shared composite contracts,
  - converging repeated local popover-menu copies is required when interaction
    model plus shape match.
- Scope and migration safety defaults:
  - default mode avoids moves/renames,
  - consolidation first means reusing canonical composite in new/edited flows
    while leaving legacy copies unless explicit migration scope is requested,
  - migration requests must stay scoped and incremental.
- Enforcement heuristics:
  - repeated trigger (for example `...`) plus popover/dropdown plus action list,
  - repeated `stopPropagation` wrappers for same menu behavior,
  - repeated close-on-select logic,
  - repeated menu-item style tokens/strings,
  - repeated accessibility naming conventions for same control type.
- Deterministic default:
  - when uncertain, assume duplicate when interaction model and shape match,
  - choose reuse/update unless that would require domain leakage.

### Forbidden

- Creating or expanding a second composite implementation when duplicate
  conditions are met.
- Choosing new composite by default without candidate evidence review.
- Forcing reuse through domain mode flags such as `variant=\"tasks|projects\"`.
- Broad migration churn (moves/renames) without explicit migration request.

---

# Side Effects, Error Handling, JSX Density, Time Semantics, Hidden Controls

## Summary
Adds hard governance for browser side-effect boundaries, catch-block handling,
JSX logic density, time-derived state semantics, and hidden interactive control
accessibility behavior.

---

## Rule: Browser Side-Effects and Routing Boundary
**Rule ID:** sr-browser-side-effects-boundary  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hidden routing/app side-effects from leaking into
UI/feature components and keeps navigation/history ownership deterministic.

### Requirement

- Direct browser side-effect APIs must stay in explicit boundaries:
  - allowed homes:
    - `src/pages/**` (route orchestration),
    - `src/core/**` (app wiring/infrastructure),
    - `src/lib/**` (pure helpers only; no direct side effects),
    - `src/hooks/**` (generic cross-domain hooks only when documented).
- Feature UI components (`features/**/sections/**`, feature components, `ui/**`)
  must treat navigation/history/event dispatch as inputs or call approved
  boundary helpers.
- Side-effect API examples covered by this rule include:
  - `window.history.*`,
  - `window.location.*` (including hash),
  - `window.dispatchEvent`, `CustomEvent`,
  - imperative `document.*` operations (except ref-safe measurement and
    interaction support),
  - direct `localStorage`/`sessionStorage` unless canonical helper/hook policy
    explicitly allows boundary access.
- Allowed exceptions:
  - `ui/**` DOM interaction for accessibility/interaction only (focus
    management, layout measurement via refs, event propagation control),
  - feature components can request navigation via callback props from
    pages/sections or a single documented canonical navigation helper/hook.
- Deterministic default:
  - lift navigation/refresh side effects to `pages/**` or `core/**`,
  - otherwise use one documented boundary helper in exactly one canonical policy
    location.

### Forbidden

- `ui/**` directly calling `window.history`, `window.location`, or dispatching
  global events.
- Feature components mutating URL/history directly outside `pages/**`.
- Adding new global custom-event names without explicit architectural request
  and ownership documentation.

---

## Rule: Empty Catch and Swallowed Error Discipline
**Rule ID:** sr-no-empty-catch  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Silent failures destroy debuggability and make behavior
nondeterministic.

### Requirement

- `catch {}` and empty `catch (e) {}` blocks are not allowed.
- Every caught error must do one explicit outcome:
  1. handle/recover,
  2. log via repository logger abstraction (`lib/logger.ts` or canonical
     equivalent),
  3. rethrow,
  4. ignore only with a short safety rationale comment and only for truly
     non-impactful best-effort behavior.
- Swallowing is allowed only when both are true:
  - operation is best-effort and non-critical,
  - short comment explains safety rationale.
- Deterministic default:
  - when unsure, log (`warn` or `error` based on user impact) and continue with
    safe fallback.

### Forbidden

- Empty catch blocks.
- Swallowing errors in transport/endpoint layers (`api/**`) without
  normalization.
- Swallowing errors for business-critical flows (mutations, persistence, auth).

---

## Rule: JSX Logic Density and Handler Extraction
**Rule ID:** sr-jsx-logic-density  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents JSX from becoming an execution script and improves
readability/testability without premature performance optimization.

### Requirement

- JSX should remain declarative; readability takes precedence over referential
  purity ceremony.
- Allowed inline patterns:
  - inline arrow functions that delegate to named handlers,
  - single-expression inline calls with no hidden control flow.
- Extraction is required in touched code when any are true:
  - handler contains branching or multiple statements,
  - component JSX contains more than about four inline arrow handlers,
  - inline handler contains domain logic,
  - inline handler exceeds one screen line in practical readability terms,
  - inline handler contains async work or multi-step side effects.
- Deterministic default:
  - extract to a named `handleX` function for readability,
  - do not introduce `useCallback` unless referential stability is truly
    required by memoized children or equivalent constraints.

### Forbidden

- Multi-branch or async logic embedded directly inside JSX handlers.
- Repeating complex inline functions across sibling elements.
- Extracting handlers reflexively into `useCallback` without a real stability
  need.
- Async IIFEs inside JSX handlers.

---

## Rule: Time and "Now" Semantics in Derived State
**Rule ID:** sr-time-derived-state  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hidden time dependencies that create stale values,
flaky tests, and inconsistent behavior.

### Requirement

- Logic that depends on current time must use explicit semantics:
  - snapshotted now (captured once), or
  - live now (explicit tick/clock source).
- Allowed patterns:
  1. snapshot now once per open/session/action and use that stable value in
     derived computations,
  2. live now from existing `useNow()`/tick hook or parent-owned clock input.
- Deterministic default:
  - prefer snapshot-now for menus/transient interactions unless live updates are
    explicitly required.

### Forbidden

- Calling `new Date()` inside memoized logic without explicit snapshot/live
  ownership.
- Time-dependent behavior changing across renders without owned time source
  semantics.

---

## Rule: Hidden Interactive Controls and Accessibility Contract
**Rule ID:** sr-hidden-interactive-controls  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents invisible/focus-trap controls and accessibility
regressions from CSS hiding patterns.

### Requirement

- When interactive elements are visually hidden (`hidden`, `opacity-0`,
  `sr-only`, similar), focusability/clickability must be intentional:
  - if non-interactive while hidden, remove from interaction path (conditional
    render or remove tab focus and equivalent accessibility signaling),
  - if screen-reader-only, use proper `sr-only` patterns, not `hidden`.
- Hover-revealed controls are allowed only when keyboard users can reach them as
  intended or equivalent focus reveal patterns exist.
- Deterministic default:
  - prefer conditional rendering when control should not exist while hidden.

### Forbidden

- Hidden interactive controls left in DOM as active controls without explicit
  accessible reveal strategy.
- Controls hidden from users but still carrying active click/focus behavior.

---

# No Cross-Feature Dependencies

## Summary
Prevents direct feature-to-feature imports to preserve ownership boundaries and
avoid feature-graph coupling.

---

## Rule: No Cross-Feature Dependencies
**Rule ID:** sr-features-no-cross-deps  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserve clear ownership and prevent feature-graph coupling that
causes architectural drift and refactor explosions.

### Requirement

- Core rule:
  - `features/**` must not import from other `features/**` modules.
  - This includes:
    - UI components/sections from another feature,
    - hooks from another feature,
    - domain models/types from another feature,
    - feature-local utilities/adapters/state from another feature.
- Allowed alternatives when multiple features need shared capability:
  1. `ui/**` for shared UI primitives/composites only (no domain logic/types),
  2. `lib/**` for pure cross-domain utilities (no React imports, no domain
     knowledge),
  3. `api/**` as shared transport contract in canonical endpoint layer
     (`api/endpoints/**` or gravity-equivalent), with each feature mapping DTO
     to its own domain model,
  4. `core/**` for cross-cutting infrastructure/composition (auth/session,
     telemetry, providers, routing setup; not domain behavior).
- Exception mechanism (rare):
  - cross-feature import is allowed only when all are true:
    - an explicitly designated shared-domain module exists (for example
      `features/_shared/**` or `domains/**`),
    - that module is documented in exactly one canonical policy location (for
      example `ARCHITECTURE.md` or `src/config/agentOverrides.ts`),
    - exported contracts are intentionally domain-agnostic or multi-feature
      primitives,
    - usage is consistent with no parallel ad hoc cross-feature imports.
  - absent such designation, cross-feature imports remain forbidden.
- Enforcement heuristics:
  - import path pattern `features/<A>/**` importing `features/<B>/**` where
    `A != B`,
  - a feature section rendering another feature section/component directly,
  - a feature hook calling another feature hook directly,
  - a feature consuming another feature's domain types instead of mapping
    transport data locally.
- Deterministic default:
  - prefer `lib/**` if pure,
  - prefer `ui/**` if UI-only,
  - otherwise keep feature-specific implementations separate; duplication at
    section level is acceptable while reusing shared primitives/composites.
- Hard stop conditions:
  - stop and revise when a change would:
    - introduce new cross-feature import,
    - move domain ownership from one feature into another without explicit
      migration scope,
    - create a second shared dumping-ground inside `features/**`.

### Forbidden

- Direct imports from one feature into another feature without explicit shared
  domain designation.
- Cross-feature coupling through UI, hooks, domain types, adapters, or
  feature-local state modules.
- Creating parallel ad hoc shared areas under `features/**` to bypass ownership
  boundaries.

---

# Type Assertion Discipline (`as T`)

## Summary
Allows narrow, locally provable assertions while forbidding assertion-driven
type lies across boundaries and domain models.

---

## Rule: Type Assertion Discipline (`as T`)
**Rule ID:** sr-types-assertion-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Allow necessary inference help without enabling type lies that
bypass boundaries, validation, and domain integrity.

### Requirement

- Definitions:
  - type assertion: `expr as T` (excluding `as const` literal narrowing),
  - external data: DTO/JSON payloads, untyped third-party values, `unknown`
    inputs, storage reads, and runtime data not guaranteed by TypeScript.
- Default stance:
  - non-`const` assertions (`as T`) are allowed when they reflect runtime
    reality and respect layer boundaries,
  - assertions are allowed only when narrowing or expressing known runtime truth
    that TypeScript cannot infer,
  - assertions must not coerce incompatible shapes or bypass validation.
- Green / OK cases:
  - narrowing where TypeScript cannot track local truth but runtime checks and
    context establish it (for example event/ref narrowing),
  - framework/library interop where upstream types are broader than effective
    runtime shape,
  - `as const`-adjacent narrowing assistance that does not alter semantic
    runtime shape ownership.
- Yellow cases (allowed with discipline, require scrutiny):
  - asserting API payload shape without validation (prefer `unknown` plus
    parse/guard),
  - asserting union member without checking discriminator/guard first.
- Allowed usage (narrowing-safe and locally provable):
  - DOM/event/ref narrowing after guards/invariant checks,
  - library/framework interop where upstream types are broader and safer
    alternatives are impractical,
  - narrowing an already-validated value (schema parse, type guard result).
- Scope rule:
  - apply assertion to the smallest possible expression.
- Boundary rule for external data:
  - do not assert external data directly to semantic/domain types,
  - treat external input as `unknown` (or DTO type),
  - validate/narrow via runtime schema checks or explicit guards/assert helpers,
  - map validated values to canonical domain models in feature boundary,
  - canonical domain types must come from validation plus mapping, not raw
    assertion,
  - do not propagate asserted external shapes across feature/domain boundaries.
- Prefer these alternatives before assertion:
  1. proper narrowing (`in`, discriminants, type guards),
  2. helper functions with narrowing-aware return types,
  3. runtime validation at DTO/form/storage boundaries,
  4. DTO-to-domain mapping.
- Escalation/refactor smell triggers:
  - repeated assertions for same shape problem in a feature,
  - assertions on API payloads or `JSON.parse` outputs,
  - assertions skipping mapping and flowing into domain/sections/pages,
  - assertions used where discriminated unions should exist.
  - when triggered, fix path is guard/validation plus mapping or stronger type
    modeling.
- Relationship to double assertion:
  - `as unknown as T` remains governed by `sr-types-double-assertion` (if
    present in repository policy) as last-resort escape hatch,
  - before double assertion, apply this rule's alternatives and boundary
    constraints first.
- Deterministic default:
  - when uncertain, do not assert; use `unknown` plus narrowing or boundary
    validation plus mapping.

### Forbidden

- Forcing correctness through assertion in:
  - `features/<domain>/domain/**` (domain invariants belong in
    constructors/guards/mappers),
  - `ui/**` shared primitives/composites for data-model coercion,
  - `store/**` state initialization from asserted external shapes.
- Asserting to make a type error disappear without proving runtime truth.
- Asserting union members without prior discriminator/guard evidence.
- Direct `as T` coercion of external data into canonical domain or semantic
  types.
- Assertion-driven bypass of validation and mapping boundaries.
- Assertion sprawl that substitutes for proper union modeling, guards, or
  schema validation.

### Notes

- Narrowing-safe DOM/ref assertions in UI are valid when they follow local
  runtime checks and do not coerce data models.

---

# Double Type Assertion Discipline (`as unknown as T`)

## Summary
Constrains double assertions to rare, boundary-scoped escape hatches with
adjacent safety steps and no unsafe propagation.

---

## Rule: Double Type Assertion Discipline (`as unknown as T`)
**Rule ID:** sr-types-double-assertion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents silencing type errors and leaking unsafe shapes across
boundaries while allowing rare, justified boundary interop.

### Requirement

- Definition:
  - double assertion is any `X as unknown as T` pattern (including equivalent
    two-step `any` cast patterns).
- Default stance:
  - double assertions are forbidden by default,
  - allowed only as last-resort boundary escape hatch.
- Escape hatch is allowed only when all are true:
  1. boundary-only location:
     - `api/dto/**` validation/parsing seams,
     - `features/<domain>/adapters/**`,
     - third-party interop wrappers,
     - legacy typed holes with no immediate safe alternative.
  2. narrow scope:
     - cast is applied to smallest possible expression.
  3. adjacent safety step:
     - same function/file scope includes runtime validation, explicit
       guard/assert helper (`isT`/`assertIsT`), or documented trusted-source
       rationale when validation is infeasible.
  4. no propagation:
     - result is normalized/mapped into canonical type before crossing deeper
       layers (especially before UI rendering or store persistence).
- Preferred alternatives must be attempted first:
  1. type narrowing/guards,
  2. stronger type modeling (generics/overloads/discriminated unions),
  3. runtime validation at boundaries,
  4. DTO-to-domain mapping to canonical types.
  - double assertion is permitted only when alternatives are impractical for
    current scoped change.
- Escalation/refactor smell triggers:
  - multiple double assertions in same feature area,
  - cast coercing DTO directly to domain model without mapping,
  - cast result exported/propagated beyond boundary seam,
  - repeated same cast pattern across call sites.
  - when triggered, add follow-up to replace with guard/assert helper, schema
    validation, or explicit mapping.
- Enforcement heuristics:
  - cast enables field access without validation,
  - cast bypasses known DTO/domain mismatch,
  - cast exists only to satisfy TypeScript with no safety explanation.
- Deterministic default:
  - when uncertain, do not use double assertion; prefer `unknown` plus narrowing
    or explicit mapping.

### Forbidden

- Double assertions in:
  - `ui/**`,
  - `features/<domain>/domain/**`,
  - `pages/**`,
  - `store/**`.
- Using double assertion to suppress type errors without adjacent safety
  evidence.
- Using double assertion as replacement for validation/mapping at boundaries.
- Allowing double-asserted external shapes to propagate across layers.

---

# Deep Relative Import Alias Suggestion

## Summary
Requires an explicit human-facing recommendation to introduce `@/` alias when
deep relative imports are detected and no canonical alias exists.

---

## Rule: Deep Relative Imports Should Trigger `@/` Alias Suggestion
**Rule ID:** sr-import-alias-suggestion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Reduces brittle path traversal noise while keeping alias adoption
as an explicit, human-approved tooling decision.

### Requirement

- Trigger this rule when touched or reviewed code contains deep relative import
  paths (for example `../../../` or deeper).
- If a canonical root alias already exists (for example `@/` or
  gravity-equivalent), use existing repository convention and do not propose a
  second alias system.
- If no canonical alias exists, the agent must include an explicit suggestion to
  the human to introduce `@/` aliasing for maintainability/readability.
- If no canonical alias exists and the active skill supports clarification
  requests (for example `react-refactoring-progression`), the agent must ask the
  human before planning alias adoption scope:
  - provide options `A`/`B`/`C` (optional `D`),
  - include one recommended option with brief rationale,
  - pause alias-related planning until answer is received.
- Suggestion content must be practical and scoped:
  - note why deep traversal is a maintenance smell,
  - propose introducing one canonical alias (prefer `@/` unless repository
    convention indicates otherwise),
  - state that migration can be incremental (touched files first).
- Alias introduction itself remains opt-in:
  - do not apply alias config/import rewrites unless explicitly requested or
    approved by user scope.

### Forbidden

- Silently introducing alias config and import rewrites when user scope does not
  request tooling/path changes.
- Planning alias-adoption changes in clarification-capable flows without asking
  the human first.
- Introducing a second competing root alias pattern when one already exists.
- Continuing to add new deep relative traversals in touched code after alias is
  already established by repository convention.

### Notes

- Boundary rules still apply equally to aliased imports and raw relative imports
  (aliasing is path ergonomics, not boundary bypass).

---

# Umbrella Feature Split and Domain Extraction

## Summary
Prevents umbrella features from becoming mini feature roots with unclear
ownership, rising coupling, and internal parallel taxonomies.

---

## Rule: Umbrella Feature Split and Domain Extraction
**Rule ID:** sr-feature-split-domain-extraction  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevent feature folders from turning into umbrella owners that
hide multiple domains and destabilize placement/reuse boundaries.

### Requirement

- Definitions:
  - umbrella feature: a feature folder that contains multiple domain sub-areas
    and starts acting like a second `features` root,
  - extracted feature: a new `features/<domain>/` owner created to restore
    clear domain ownership.
- Split triggers (extraction is required when any applies):
  - internal domain partitioning resembles multiple first-class features,
  - duplicate layer taxonomies appear inside one feature (for example
    `api/`, `components/`, `hooks/`, `utils/`, `rules/`) while multiple domain
    sub-areas also exist,
  - ownership ambiguity is recurring and the feature becomes a dumping ground,
  - cross-domain coupling grows inside one feature (shared helpers/state/UI
    glue for unrelated sub-areas),
  - reviewability breaks down (changes routinely span unrelated sub-areas).
- Required extraction outcome when triggered:
  - extract each domain sub-area into first-class feature ownership with
    `features/<domain>/sections/**`, `components/**`, `hooks/**`,
    `domain/**` (plus `adapters/**` when needed),
  - reduce original umbrella feature to exactly one of:
    1. route/page orchestration (preferred, usually in `pages/**`), or
    2. thin feature shell with orchestration wiring only.
- Migration-safe extraction protocol:
  1. choose target feature owners first (one owner per sub-area),
  2. move domain logic and adapters before UI,
  3. move feature hooks next,
  4. move feature-owned UI next (sections, then leaf components),
  5. promote shared utilities correctly:
     - `ui/**` for reusable UI patterns,
     - `lib/**` for pure cross-domain helpers,
     - `api/**` remains canonical transport home,
  6. enforce no cross-feature imports after extraction.
- Deterministic default:
  - if uncertain whether a feature is umbrella-shaped, prefer extraction once
    multiple distinct domain sub-areas exist and shared glue is growing,
  - keep orchestration at `pages/**` (or a thin shell), not in a lingering
    umbrella owner.

### Forbidden

- Keeping two active owners for the same concern after split
  (half-umbrella/half-split).
- Creating feature-local transport homes when canonical API home exists (for
  example `features/<x>/api/**` alongside canonical `api/**`).
- Introducing `views/` inside features as a substitute for `sections/`.
- Splitting by technical layer taxonomy (MVC-style) instead of domain ownership.

---

# Feature Components Scope

## Summary
Defines what may live in `features/<domain>/components/**` so feature
components do not become a shadow shared-UI system.

---

## Rule: What May Live in `features/<domain>/components/`
**Rule ID:** sr-feature-components-scope  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents feature components from becoming a second shared UI home
or hiding domain/transport logic in presentation files.

### Requirement

- `features/<domain>/components/**` exists for feature-owned UI pieces that are
  not cross-domain reusable and are not route-level orchestration.
- Allowed component characteristics (all required):
  - domain-bound UI with domain terminology and feature-coupled behavior,
  - feature-scoped reuse (same feature only, not intended cross-feature),
  - UI-oriented behavior only (local UI state, minor presentation logic, event
    handlers),
  - leaf/support role (for example extracted from sections to reduce size or
    complexity).
- Structural constraints:
  - feature components may import:
    - `ui/**`,
    - same-feature hooks/domain utilities,
    - `lib/**`,
  - feature components must not import:
    - `pages/**`,
    - canonical endpoint modules directly,
    - other features unless explicitly allowed shared-domain policy exists.
- Deterministic placement matrix:
  - route-level orchestration -> `pages/**`,
  - domain-aware orchestration -> `features/<domain>/sections/**`,
  - feature-owned leaf UI -> `features/<domain>/components/**`,
  - cross-domain reusable UI -> `ui/primitives/**` or `ui/composites/**`,
  - pure logic -> `features/<domain>/domain/**` or `lib/**`.
- Hard guardrail:
  - if a component in `features/<domain>/components/**` is reused by 2+ domains,
    has no domain terminology, or becomes a mini shared composite, promote it
    to `ui/**`.

### Forbidden

- Transport logic in feature components:
  - `fetch`, axios, endpoint ownership, DTO mapping.
- Cross-domain shared UI maintained under feature components.
- Domain algorithms/business rules/complex transformation logic in component
  files (belongs in feature domain or feature hooks).
- Route orchestration concerns in feature components (belongs in pages/sections).
- Shared dumping-ground subfolders like `common/` or `shared/` under
  feature-components homes.

---

# No Feature-Local API Homes

## Summary
Prevents transport-layer fragmentation by enforcing one canonical API home.

---

## Rule: No `api/` Inside Features When Canonical API Home Exists
**Rule ID:** sr-no-feature-api-home  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Preserves one-home-per-concern for transport ownership and
prevents endpoint drift into feature folders.

### Requirement

- If a canonical API home exists (for example `src/api/**`,
  `src/services/api/**`, or gravity-equivalent), features must not define local
  `api/` folders.
- All transport logic must stay in the canonical endpoint layer:
  - `fetch`,
  - axios/client wrappers,
  - endpoint functions.
- Features must consume transport through the canonical endpoint layer only.
- DTO-to-domain mapping remains feature-owned in
  `features/<domain>/domain/**` or `features/<domain>/adapters/**`.
- Bootstrap exception is valid only when both are true:
  - no canonical API home exists yet, and
  - architecture detection explicitly enters bootstrap mode.
- Even in bootstrap mode, create canonical API home directly; do not create
  feature-local transport homes.

### Forbidden

- `features/<domain>/api/**` when canonical API home exists.
- Direct HTTP calls inside `features/**` transport ownership.
- Returning domain-mapped types from `api/**` as canonical contracts.
- Creating secondary transport homes inside feature boundaries.

---

# No `views` Taxonomy in Features

## Summary
Prevents MVC-style drift and parallel presentation taxonomies inside feature
folders.

---

## Rule: No `views/` or `*View` in Features
**Rule ID:** sr-no-feature-views  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps presentation ownership deterministic across pages,
sections, and components without introducing duplicate view layers.

### Requirement

- `features/**` must not contain `views/` folders.
- Files inside `features/**` must not use `*View` naming.
- Route-pointed components belong in `pages/**`, not `features/**`.
- Domain-aware UI orchestration in features must use:
  - `sections/**` for orchestration-level UI,
  - `components/**` (or `widgets/**` only when explicitly standardized) for
    feature-owned leaf UI.
- If repository already uses `views/` as established gravity, follow migration
  rules for existing architecture rather than creating mixed taxonomies.
- Do not keep both `sections/` and `views/` in the same feature.
- Do not rename `sections/` to `views/` in greenfield architecture.

### Forbidden

- `features/<domain>/views/**` folders.
- `*View` file names inside `features/**`.
- Route-level feature containers named/organized as views.
- Parallel `sections/` + `views/` presentation homes within one feature.

---

# File Name Length Policy

## Summary
Defines deterministic file-name length limits to preserve readability,
discoverability, and tooling ergonomics.

---

## Rule: File Name Length Discipline
**Rule ID:** sr-filename-length  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Long file names reduce grepability, readability, and review
velocity, and often signal mixed responsibilities.

### Requirement

- File naming must stay concise and searchable:
  - keep semantic base name length at `<= 64` characters (excluding extension),
  - prefer concise descriptive names and established local terminology,
  - keep file name and primary export aligned when applicable.
- Suffix handling:
  - known suffixes such as `.test`, `.spec`, `.stories`, `.dto`, and
    framework-required route names do not justify oversized semantic base names.
- When a candidate name exceeds limit:
  - split responsibility rather than encoding multiple concerns in one name,
  - shorten vocabulary using established local terms (no ad hoc abbreviations),
  - keep role suffixes clear (`Page`, `Section`, `Row`, `Badge`, `use*`, etc.).
- Deterministic default:
  - if uncertain, choose the shortest name that remains unambiguous in the
    local feature/layer context.

### Forbidden

- Introducing new files with semantic base names longer than 64 characters.
- Using file names that concatenate multiple responsibilities to avoid
  extraction/splitting.
- Renaming purely for style if the current name is within limit and clear.

---

# Output Mode Resolution

## Summary
Defines strict precedence for `output_mode` selection so human-invoked skill
runs do not accidentally emit raw JSON.

---

## Rule: Output Mode Resolution and Display Safety
**Rule ID:** sr-output-mode-resolution  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents accidental machine-mode output to humans and enforces
deterministic mode selection.

### Requirement

- Resolve `output_mode` using strict precedence:
  1. if request explicitly sets `output_mode`, honor it,
  2. else if requester explicitly asks for machine-readable/raw JSON output
     (automation/integration intent), set `output_mode=agent`,
  3. else if a human explicitly asks to run/use the skill, set
     `output_mode=human`,
  4. else default to `output_mode=agent`.
- Ambiguity fallback:
  - when uncertain between human and agent, choose `output_mode=human`.
- Display contract remains strict:
  - if `output_mode=human`, display only `presentation.user_markdown`,
  - if `output_mode=agent`, display full JSON payload.
- A human-invoked skill run must not infer automation intent unless the human
  explicitly requests machine-readable output.

### Forbidden

- Selecting `output_mode=agent` by habit/default when a human explicitly
  requested skill usage and did not request machine-readable output.
- Inferring automation intent without explicit signal from the request context.
- Displaying raw JSON to a human when `output_mode=human`.

---

# Prop Drilling Discipline

## Summary
Defines thresholds and remediation order for prop-drilling debt without forcing
premature global-state escalation.

---

## Rule: Prop Drilling Discipline and Escalation
**Rule ID:** sr-props-drilling-discipline  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keep component trees readable and maintainable by limiting
pass-through wiring while preserving clear ownership boundaries.

### Requirement

- Definitions:
  - prop drilling: passing props through intermediate components that do not
    consume them, only to reach deeper descendants,
  - pass-through component: component forwarding props it does not consume.
- Treat prop drilling as architectural smell when any applies:
  1. depth threshold: same prop/group forwarded through 3+ layers where
     intermediates do not use it,
  2. volume threshold: component forwards 5+ unused props (excluding
     `className`, `children`, and standard DOM props),
  3. branch duplication: same prop set threaded across multiple sibling
     branches,
  4. churn threshold: drilled props frequently change and repeatedly force
     wiring updates across unrelated components,
  5. UI boundary leakage: domain data/actions drilled into shared `ui/**`
     causing domain awareness.
- Approved remediation ladder (in order):
  1. composition/slots first (`children`, render props, explicit slots),
  2. lift orchestration to `features/<domain>/sections/**`,
  3. feature-scoped context provider inside `features/<domain>/**` when many
     deep descendants need shared state/actions,
  4. global store only for truly global state with explicit policy
     justification.
- Feature-scoped context constraints:
  - provider stays feature-owned (not `ui/**` or global `store/**`),
  - context value shape must be intentional/stable (no everything-bag),
  - provider must not become cross-feature dependency.
- Deterministic default:
  - prefer composition first,
  - if many descendants in one feature need shared value, prefer
    feature-scoped context,
  - do not move to global store without explicit global justification.
- Escalation trigger:
  - if depth >= 3 and volume >= 5 in one subtree, treat as refactor-worthy
    issue in touched scope (while respecting scope-governor limits).

### Forbidden

- Prop-bag objects used mainly to hide drilling instead of reducing
  responsibilities.
- Moving state to global `store/**` as convenience fix without global-state
  justification.
- Making shared `ui/**` domain-aware (domain-mode flags or domain-shaped props)
  to bypass proper feature ownership.
- Introducing new `shared/` or `common/` dumping grounds for drilled values.

---

# Overview

## Summary

Defines the authoritative scope and boundaries for
`react-refactoring-progression`.

---

## Rule: Optional Extension Scope
**Rule ID:** rrp-overview-scope  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps this skill planning-only and aligned with the fixed
four-skill production pipeline.

### Requirement

- The skill must remain an optional extension and must not redefine the fixed
  production execution set.
- The default invocation path is an opportunistic consult at the end of
  `react-implementation-discipline` execution for both micro and standard
  modes.
- The skill must produce planning guidance only and must not emit
  implementation patches.
- The skill must consume upstream architecture, placement, reuse, and
  implementation context rather than recomputing those outcomes.
- The skill must keep recommendations behavior-preserving by default.
- The skill must inherit mandatory shared baseline constraints.
- The skill must remain optional until an explicit governance amendment
  reclassifies it.

### Forbidden

- Reclassifying this skill as a production execution skill inside feature
  output.
- Recomputing architecture gravity or overriding upstream placement/reuse
  decisions.
- Producing direct source-code patches or file-apply payloads.

### Notes

- This skill is a consult layer, not an implementation layer.

---

# Refactor Planning Process

## Summary

Defines deterministic, risk-ordered planning behavior.

---

## Rule: Tiered Planning Sequence
**Rule ID:** rrp-process  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures predictable and low-risk refactor planning.

### Requirement

- Validate required inputs before planning steps.
- Resolve effective output mode before planning output:
  - accept optional `output_mode` (`human|agent`)
  - resolve with strict precedence:
    1. explicit `output_mode` in request
    2. explicit machine-readable/raw JSON request -> `agent`
    3. human explicitly instructs this skill -> `human`
    4. otherwise -> `agent`
  - when uncertain between `human` and `agent`, choose `human`
- Clarification loop support:
  - when a high-impact ambiguity blocks deterministic plan quality, emit
    `clarification_request` and pause planning,
  - ask at most 4 questions in one request,
  - each question must provide `A`/`B`/`C` options (optional `D` when needed),
  - ask only questions that materially affect scope, safety, boundary ownership,
    or acceptance outcomes,
  - when `clarification_answers` are provided on resume, continue planning and
    produce a final `refactor_plan`/error result (not another duplicate
    clarification for already-answered items).
- Use canonical tier labels only: `A`, `B`, `C`, `D`.
- Order active plan steps from lower-risk to higher-risk tiers.
- Apply deterministic ordering with no additional custom ordering beyond:
  - tier order (`A -> B -> C -> D`)
  - risk order (low before high within the produced list)
- Escalate only when at least one condition is true:
  - a lower-tier improvement is blocked by compliance constraints
  - no meaningful lower-tier improvements remain
  - dedicated refactor mode is explicitly requested
- Every step must include:
  - `why_now`
  - at least one of `unblocks`, `reduces_future_cost`, `standard_alignment`
- Set `behavior_change=none` by default.
- If behavior-preserving guarantees cannot be met, set
  `behavior_change=requires_approval` and mark step as gated.
- In opportunistic mode, produce only Tier A/B active steps and prioritize:
  - dead code removal and import cleanup
  - naming clarity and local helper extraction
  - type tightening
  - non-structural boundary-conformance fixes
- Prioritize implementation-focused improvements over test-only improvements.
- Test updates should be proposed in active steps only when they are required to
  preserve, validate, or safely land implementation-focused improvements.
- Test-only improvements may be suggested only when no meaningful
  implementation-focused improvements remain in current scope.
- In opportunistic mode, treat Tier C/D findings as non-blocking follow-up
  guidance only.
- In opportunistic mode, do not include:
  - layer changes
  - endpoint relocation
  - cross-home adjustments
  - architectural boundary introduction
- In dedicated mode, allow Tier C/D only under scope-governor and migration
  constraints.

### Forbidden

- Skipping low-risk tiers when safe lower-tier improvements are available.
- Returning unguided or rationale-free steps.
- Using mixed tier naming schemes (for example `0-4` plus `A-D`) in one output.
- Escalating for aesthetic cleanup, style-only churn, or speculative
  "refactor for future" rationale.
- Asking low-value stylistic clarification questions that do not change planning
  decisions.

### Notes

- Tier C/D recommendations in opportunistic mode belong in follow-up findings,
  not active steps.

---

# Output Contract

## Summary

Defines strict result types and payload constraints.

---

## Rule: Structured Refactor Output
**Rule ID:** rrp-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps outputs machine-consumable and deterministic.

### Requirement

- Emit one JSON object with required envelope fields:
  - `schema_version`
  - `skill`
  - `version`
  - `output_mode`
  - `presentation`
  - `result_type`
  - `validation_status`
- `output_mode` must be `human` or `agent`.
- `presentation` must include:
  - `user_markdown` (prettified markdown summary of the payload)
- Restrict `result_type` to:
  - `refactor_plan`
  - `clarification_request`
  - `validation_error`
  - `dependency_error`
- Restrict `validation_status` to:
  - `accepted`
  - `blocked`
  - `needs_clarification`
  - `validation_error`
  - `dependency_error`
- `refactor_plan` output must include:
  - `refactor_mode`
  - `plan.touch_budget`
  - `plan.steps[]`
- `refactor_plan` may include:
  - `plan.follow_up_findings[]` for non-blocking out-of-mode items
  - `plan.test_file_touches[]` for opportunistic test updates
- Opportunistic `refactor_plan` outputs must:
  - include only Tier A/B steps
  - include no more than 5 steps
  - keep Tier C/D items in `plan.follow_up_findings[]` only
- `validation_error` output must include notes and no `plan` payload.
- `clarification_request` output must include:
  - `clarification_questions[]` (1-4 items)
  - each item includes:
    - `question_id`
    - `question`
    - `options[]` with keys `A`/`B`/`C` (optional `D`)
    - `recommended_option`
  - no `plan` payload
- `dependency_error` output must include:
  - `dependency_issue`
  - `fallback_context_bundle_requirements[]` (min 5)
  - `notes[]`
  - no `plan` payload
- Include `scope_expansion_needed[]` when completeness exceeds caps but an in-cap
  plan is still returned.
- Represent Tier C/D opportunistic findings as follow-up metadata, not blocking
  step execution.
- If `plan.test_file_touches[]` is present, keep it directly relevant, bounded
  (default <=2 files), and dependency-neutral.
- `plan.test_file_touches[]` should be included only when at least one is true:
  - test updates are required by implementation-focused active steps, or
  - no meaningful implementation-focused improvements are available and
    test-only improvement is used as fallback value.
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.

### Forbidden

- Emitting prose outside the JSON payload when `output_mode=agent`.
- Displaying raw JSON to humans when `output_mode=human`.
- Selecting `output_mode=agent` by habit/default when a human explicitly asked
  to run this skill and no machine-readable output was requested.
- Emitting test-only active steps while meaningful implementation-focused
  improvements remain in scope.
- Returning partial `refactor_plan` output when required context is missing.
- Returning `clarification_request` without structured options.
- Emitting non-enum status strings.

### Notes

- All output examples must validate against the schema.

---

# Validation Gates

## Summary

Defines behavior-preservation and approval gate checks.

---

## Rule: Behavior Preservation Enforcement
**Rule ID:** rrp-validation-gates  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents accidental regressions during refactor planning.

### Requirement

- Validate behavior-preservation invariants for each active step.
- Backend contract invariants (hard):
  - no endpoint, method, param, header, or request/response shape changes
  - no transport-semantics changes
- UI/UX invariants (hard):
  - no major user-noticeable UI behavior changes
  - no new UX breakage
  - only tiny visual consistency adjustments are acceptable
- Behavioral invariants (hard):
  - no external component contract breakage unless strictly equivalent
  - no route path/navigation changes
  - no query-key or cache-semantics changes
  - no user-facing loading/error/empty behavior changes
- Record behavior-preservation checks in `plan.behavior_preservation[]` when
  produced.
- If project tests exist, planning should require preserving or extending
  relevant behavior coverage before high-risk refactor execution.
- Always require boundary-audit, lint/type correctness, and no new test/lint
  regressions in acceptance notes.
- If any step requires non-preserving behavior, mark it
  `behavior_change=requires_approval` and set final state to `blocked` unless
  explicit approval is already present.
- Ensure blocked plans include actionable notes describing required approvals or
  changes.

### Forbidden

- Treating non-preserving steps as accepted by default.
- Omitting preservation checks for steps with non-trivial scope.

### Notes

- `blocked` status is valid for refactor-plan outputs that require explicit
  approval before execution.

---

# Scope Governor

## Summary

Defines mode-specific scope limits and expansion handling.

---

## Rule: Bounded Scope Execution
**Rule ID:** rrp-scope-governor  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents uncontrolled refactor spread and hidden churn.

### Requirement

- Apply default scope caps unless explicitly overridden:
  - `max_files_touched=8`
  - `max_new_files=4`
  - `max_moved_or_renamed=0`
  - `max_new_dependencies=0`
  - `max_new_top_level_folders=0`
- Opportunistic mode must remain bounded to already touched implementation
  files, except mandatory folderization in the same concern home.
- Opportunistic mode may not expand the touched-file set for production code.
- Opportunistic mode must not include moves/renames, routing changes, or new
  dependencies.
- Opportunistic mode may include directly related test-file updates without
  counting them toward touched-file budget only when all hold:
  - implementation-focused active steps exist and require those test updates for
    safe landing/coverage alignment
  - no new dependencies are introduced
  - tests validate behavior directly related to touched code
  - no more than 2 test files are updated by default (or explicitly expanded
    via `scope_expansion_needed[]`)
- Test-only update proposals are allowed only when no meaningful
  implementation-focused improvements remain within active scope caps.
- Dedicated mode move/rename actions are capped at 3 unless migration mode is
  explicitly enabled.
- Dedicated mode may include broader changes only within explicit cap policy and
  migration constraints.
- Folderization policy:
  - mandatory when touched component size exceeds approximately 400 lines
  - allowed around 250-300 lines only when the split clearly reduces
    responsibilities
  - "clearly reduces responsibilities" means at least one is true:
    - file has 2+ distinct responsibilities
    - file contains 3+ meaningful internal subcomponents that can separate
      cleanly
    - file has non-trivial component-scoped helper pile suitable for
      local `*.utils`/`*.types` extraction
    - split reduces the main file toward a single responsibility and materially
      improves readability
- When materially better completeness exceeds caps, emit bounded
  `scope_expansion_needed[]` with `why` and `would_touch` while still returning
  an in-cap plan.

### Forbidden

- Silent scope expansion beyond active caps.
- Introducing unrelated refactor work outside requested scope.

### Notes

- Scope cap enforcement is mandatory even when step quality appears high.

---

# Anti-Pattern Detection

## Summary

Defines anti-pattern detection requirements and output mapping.

---

## Rule: Anti-Pattern Findings
**Rule ID:** rrp-detection  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Turns known architecture drift signals into actionable planning
metadata.

### Requirement

- Detect and classify high-value anti-patterns, including:
  - implicit visibility ownership in shared presentational components
  - fetch/transport usage outside canonical endpoint ownership
  - domain leakage into shared UI abstractions
  - unjustified server-state mirroring in global store
  - prop-drilling debt across pass-through component chains
  - umbrella-feature drift (single feature acting like a mini `features` root)
  - feature-local presentation/transport shadow homes (for example
    `features/*/views/**`, `*View` naming, `features/*/api/**`)
- Anti-pattern tier defaults:
  - implicit visibility in shared presentational UI -> Tier A
  - fetch outside canonical endpoint layer -> Tier B (Tier C when widespread)
  - domain leakage into shared UI -> Tier B
  - server-state mirrored to global store without justification -> Tier B
    (Tier C when systemic)
  - prop-drilling debt -> Tier B (Tier C when subtree breadth/churn is high)
  - umbrella-feature drift -> Tier B (Tier C when widespread and high-churn)
  - feature-local shadow homes for views/api -> Tier B
- Detection heuristics must include:
  - implicit visibility:
    - component in `ui/primitives/**` or `ui/composites/**`
    - conditionally returns `null` based on external props
    - component is not an explicit boundary/guard wrapper
  - fetch outside endpoint layer:
    - transport logic exists outside canonical endpoint ownership
  - domain leakage:
    - domain-specific naming/types/flags in shared UI
  - server-state mirror:
    - cache-backed server data redundantly stored in global store with no
      explicit performance/offline rationale
  - prop-drilling debt:
    - same prop/group forwarded through 3+ layers without intermediate use,
    - pass-through forwarding volume >=5 props in a layer,
    - repeated sibling-branch threading of same prop set,
    - drilled domain data/actions leaking into shared `ui/**`
  - umbrella-feature drift:
    - one feature contains multiple domain sub-areas plus parallel layer-style
      internal taxonomies (`components/`, `hooks/`, `utils/`, `rules/`, etc.),
    - recurring shared glue inside one feature indicates multiple hidden domain
      owners
  - feature-local shadow homes:
    - feature paths matching `features/*/views/**` or `features/**/*View.*`,
    - feature paths matching `features/*/api/**` while canonical API home
      exists
- Emit findings with:
  - stable `finding_id`
  - `type`
  - assigned `tier`
  - `affected_files[]`
  - `recommended_step_id`
- Ensure out-of-mode findings are surfaced as non-blocking follow-up guidance.
- Detection focus should align with standards enforced by:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`
- If model-only confidence is low, follow `rrp-detection-assist-scripts` for
  script-assisted candidate discovery and fallback behavior.

### Forbidden

- Emitting anti-pattern findings without traceable affected files.
- Promoting out-of-mode findings to blocking active-step status.
- Producing recommendations that are purely aesthetic or preference-driven.
- Treating script output as authoritative evidence without direct rule-based
  review.

### Notes

- Detection should prioritize standards alignment over style-only concerns.

---

# Detection Assist Scripts

## Summary

Defines script-assisted candidate discovery behavior for low-confidence
refactoring detection runs.

---

## Rule: Script-Assisted Detection Candidates
**Rule ID:** rrp-detection-assist-scripts  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps helper-script usage bounded, input-safe, and subordinate to
rule-based agent judgment.

### Requirement

- Use helper scripts only when model-only detection confidence is low.
- Home/placement candidate scan:
  - run
    `skills/react-refactoring-progression/scripts/scan_home_misplacements.mjs`
    with explicit `--frontend-root <frontend-source-root>` (repeatable and
    required),
  - `--frontend-root` must point to frontend source root (for example
    `apps/web/src`), not the package root,
  - scanner must review only supplied frontend roots.
- Duplicate-cluster candidate scan:
  - run
    `skills/react-refactoring-progression/scripts/scan_duplicate_ui_clusters.mjs`
    with explicit `--frontend-root <frontend-source-root>` (repeatable and
    required),
  - use returned `review_groups[]` and `file_paths[]` only as candidate queues
    for side-by-side review.
- Script output is heuristic and non-authoritative:
  - treat all script results as potential false positives,
  - dismiss unsupported candidates after direct evidence review,
  - never let scripts decide final placement/extraction/reuse outcomes.
- Fallback behavior when candidates are dismissed:
  - if all script candidates/groups are dismissed, continue with direct
    repository assessment using shared and local rules only.
- Candidate-only contract:
  - scanner outputs are input hints (`file_paths[]`, `review_groups[]`) and must
    not be interpreted as expected homes or required actions.

### Forbidden

- Running helper scripts without required `--frontend-root` input.
- Auto-scanning entire monorepo roots when only frontend source roots are
  required.
- Treating empty or dismissed script output as a blocker.
- Treating script suggestions as decisions without direct evidence review.

### Notes

- Use script assistance as fallback tooling; rely on rule-grounded judgment for
  final findings.

---

# Semantic Duplication

## Summary

Defines qualification and scoring for structural duplication candidates.

---

## Rule: Semantic Duplication Qualification
**Rule ID:** rrp-semantic-duplication  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents unsafe abstraction and focuses on high-leverage reuse.

### Requirement

- A duplication cluster qualifies only when all are true:
  - responsibility equivalence
  - variation expressibility with <=2 small props/slots or feature-local
    extraction
  - abstraction safety (no domain logic in shared UI and no UI transport logic)
  - acceptable divergence risk
- A duplication cluster also requires at least two independent similarity
  signals.
- Required discovery coverage includes:
  - layout skeletons
  - loading/error/empty boundary trees
  - interaction state-machine patterns
  - config schemas (table/form structures)
  - hook orchestration flows
  - domain-parallel component structures
  - DTO-to-domain mapping pipelines
- Normalize superficial differences (names, literals, import path details)
  before evaluating structural similarity.
- Compare normalized structures on:
  - JSX tree shape
  - conditional decision-tree shape
  - hook usage flow
  - state-machine transitions
- For each cluster, emit:
  - `why_now`
  - at least one of `unblocks`, `reduces_future_cost`, `standard_alignment`
  - `recommended_target`
  - `abstraction_cost`
  - `leakage_risk`
  - `divergence_risk`
  - `refactor_radius`
  - `recommended_next_step`
  - `variation_points[]`
- Use one extraction target only per cluster:
  - `keep_separate`
  - `extract_ui_primitive`
  - `extract_ui_composite`
  - `extract_feature_section`
  - `extract_feature_hook`
  - `extract_lib_utility`
- Recommend `extract_ui_composite` only when variation can be represented with
  slots/children and no domain mode flags are needed.
- Prefer "one level up":
  - within-feature duplication -> feature-local extraction first
  - cross-feature duplication -> shared UI extraction only when leakage risk is
    low
- Reject shared UI extraction when domain-mode flags are required or divergence
  risk is high.
- Default heuristics:
  - if required new props exceed 2, avoid shared UI extraction
  - if divergence risk is high, prefer `keep_separate` or feature-local
    extraction
  - large-radius recommendations should be follow-up scope by default

### Forbidden

- Declaring duplication candidates with only one weak similarity signal.
- Recommending cross-domain shared abstraction when leakage risk is high.

### Notes

- Prefer feature-local extraction before cross-feature abstraction when both are
  viable.

---

# Skill Interactions and Invocation

## Summary

Defines required interaction boundaries with upstream/downstream skills.

---

## Rule: Interaction Boundaries
**Rule ID:** rrp-interactions  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents overlap and contradiction across the fixed skill model.

### Requirement

- The skill must not recompute architecture gravity.
- The skill must respect placement decisions, including canonical endpoint-layer
  ownership.
- The skill must not override reuse/update/new decisions from
  `react-reuse-update-new`.
- The skill must remain plan-only and not emit implementation patches.
- Default invocation path:
  - consulted by `react-implementation-discipline` at end of micro/standard
    execution
  - opportunistic mode is used for this default consult
- Dedicated mode is used only when refactor work is explicitly requested.

### Forbidden

- Overriding authoritative placement or reuse decisions inside refactor output.
- Running as an implementation executor.
- Promoting optional extension behavior into mandatory production flow without
  governance change.

### Notes

- This skill augments implementation quality but does not replace any production
  execution skill.

---

# Refactor Progression Model

## Summary

Defines the finalized tier model and mode-specific tier allowances.

---

## Rule: Finalized Tier Model
**Rule ID:** rrp-progression-model  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps tier semantics stable for reviewers and downstream
automation.

### Requirement

- Canonical tier model:
  - Tier A: Reuse alignment
  - Tier B: Implementation hygiene
  - Tier C: Placement corrections
  - Tier D: Architecture convergence
- Opportunistic mode:
  - allows Tier A and Tier B active steps only
  - Tier C/D findings must be follow-up only
- Dedicated mode:
  - allows Tier A/B by default
  - may include Tier C under scope-governor constraints
  - Tier D requires explicit migration mode and approval
- Escalation order must remain:
  - Tier A -> Tier B -> Tier C -> Tier D

### Forbidden

- Producing Tier C or Tier D active steps in opportunistic mode.
- Producing Tier D active steps without migration mode and explicit approval.

### Notes

- Tier labels are semantic execution bands, not implementation patch
  instructions.

---

# Semantic Duplicate Classification

## Summary

Defines deterministic classification and evidence standards for semantic
duplication clusters.

---

## Rule: Pattern Type Classification
**Rule ID:** rrp-dup-pattern-types  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures each duplication candidate maps to one clear extraction
strategy.

### Requirement

- Every semantic duplication cluster must declare exactly one primary
  `pattern_type`:
  - `layout_skeleton`
  - `data_state_boundary`
  - `interaction_state_machine`
  - `config_schema`
  - `hook_orchestration`
  - `domain_parallel_component`
  - `mapping_pipeline`
  - `permission_gating`
  - `other`
- If `pattern_type=other`, include a concise `type_explanation`.

### Forbidden

- Returning unlabeled duplication clusters.
- Assigning multiple primary pattern types to one cluster.
- Using `other` without an explanation.

---

## Rule: Two-Signal Qualification Gate
**Rule ID:** rrp-dup-two-signals  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Reduces false positives from cosmetic similarity.

### Requirement

- A cluster may qualify as a semantic duplication candidate only when at least
  two independent signals are present.
- Signals must represent structural or responsibility-level similarity and must
  not be identifier-only similarity.

### Forbidden

- Declaring a duplication candidate from a single weak signal.
- Treating naming similarity as a standalone qualification signal.

---

## Rule: Structural Evidence Quality
**Rule ID:** rrp-dup-evidence  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps recommendations actionable and auditable.

### Requirement

- Each cluster must include concise structural evidence that covers:
  - shared responsibility
  - structural similarity basis
  - variation surface
  - target-layer rationale
- Evidence must explain why the recommendation is safe for the proposed layer.

### Forbidden

- Evidence that only references cosmetic similarity.
- Raw code dumps instead of structural explanation.

---

# Semantic Duplicate Guardrails

## Summary

Defines anti-over-abstraction constraints for duplication recommendations.

---

## Rule: Existing Home Alignment
**Rule ID:** rrp-dup-home-alignment  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents introducing a second architecture home by accident.

### Requirement

- Recommendations must align with existing concern homes in the repository.
- If UI concern homes are already established (for example `src/components`),
  prefer that existing home unless migration scope is explicitly declared.

### Forbidden

- Recommending a new parallel home for the same concern without migration scope.

---

## Rule: Slots Over Prop Matrix
**Rule ID:** rrp-dup-slots-over-props  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Avoids prop explosion and domain flags in shared UI composites.

### Requirement

- Shared UI composite recommendations should express variation with
  slots/children/render composition.
- If recommendation needs more than 2 behavioral toggles or domain mode flags,
  reject shared composite extraction.

### Forbidden

- Proposing shared composite extraction that needs domain mode flags.
- Proposing composite APIs with large boolean/variant prop matrices.

---

## Rule: One-Level-Up Preference
**Rule ID:** rrp-dup-one-level-up  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps abstraction scope proportional to the duplication source.

### Requirement

- Within-feature duplication should be extracted one level up first
  (feature section or feature hook).
- Cross-feature extraction into shared UI is recommended only when cross-domain
  reuse is demonstrated and leakage risk is low.

### Forbidden

- Jumping directly to global shared extraction for local duplication.

---

## Rule: Keep-Separate by Default Under High Risk
**Rule ID:** rrp-dup-keep-separate  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Treats intentional duplication as valid when abstraction is
unsafe.

### Requirement

- If abstraction cost is high, leakage risk is high, or divergence risk is high,
  default recommendation must be `keep_separate` (or feature-local extraction).
- Include explicit rationale when `keep_separate` is selected.

### Forbidden

- Forcing unification when risk profile indicates separation is safer.

---

## Rule: Locality Preference
**Rule ID:** rrp-dup-locality  
**Priority:** SHOULD  
**Applies to:** react-refactoring-progression  
**Rationale:** Respects established repository sharing culture.

### Requirement

- If repository conventions favor feature-local sections, prefer local
  extraction unless a strong cross-feature reuse case exists.

### Forbidden

- Introducing cross-feature sharing strategy without strong evidence.

---

## Rule: Cognitive Load Guard
**Rule ID:** rrp-dup-cognitive-load  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** DRY does not justify harder-to-understand APIs.

### Requirement

- Reject recommendations that increase indirection or hide meaningful domain
  differences.
- Reject recommendations that require config-DSL style APIs to represent basic
  variations.

### Forbidden

- Recommending mega-config abstractions as default duplicate handling.

---

## Rule: Refactor Radius Bound
**Rule ID:** rrp-dup-refactor-radius  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents high-churn suggestions in bounded planning modes.

### Requirement

- Every duplication cluster must classify refactor radius as `local`, `medium`,
  or `large`.
- `large` radius recommendations must be marked as follow-up scope unless
  explicit expansion is already approved.

### Forbidden

- Presenting large-radius extraction as immediate in-cap opportunistic work.

---

## Rule: Micro Extraction Before Mega Extraction
**Rule ID:** rrp-dup-micro-before-mega  
**Priority:** SHOULD  
**Applies to:** react-refactoring-progression  
**Rationale:** Improves safety by extracting high-leverage subparts first.

### Requirement

- For complex duplicated components, prefer extracting repeated subparts
  (boundary/layout/helper) before recommending full component unification.

### Forbidden

- Recommending full merge-first abstraction when a smaller extraction addresses
  most duplication safely.

---

# Semantic Duplicate Output Requirements

## Summary

Defines required duplication-cluster output fields for actionable planning.

---

## Rule: Cluster Output Completeness
**Rule ID:** rrp-dup-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Ensures clusters are actionable without implementation output.

### Requirement

- Every semantic duplication cluster must include:
  - `pattern_type`
  - `candidate_files[]`
  - `signals[]`
  - `evidence`
  - `recommended_target`
  - `abstraction_cost`
  - `leakage_risk`
  - `divergence_risk`
  - `refactor_radius`
  - `recommended_next_step`
  - `variation_points[]`
  - `candidate_api`
  - `non_goals[]`
- Cluster output must stay concise and structural; no patch text.

### Forbidden

- Returning semantic duplication clusters without extraction-target and risk
  metadata.
- Returning vague similarity claims without supporting evidence.

---

## Rule: Actionable Next Actions
**Rule ID:** rrp-dup-next-actions  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Keeps output useful for downstream task planning.

### Requirement

- `recommended_next_step` must be one sentence with clear immediate action.
- `candidate_api` must describe expected abstraction interface shape in words
  (not code).
- `non_goals[]` must define what must not be abstracted in the proposed step.

### Forbidden

- Omitting non-goals for duplication recommendations.
- Returning code snippets as the "next action" or candidate API definition.

---

## Rule: Keep-Separate Output Clarity
**Rule ID:** rrp-dup-keep-separate-output  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Makes non-extraction decisions explicit and reviewable.

### Requirement

- When `recommended_target=keep_separate`, cluster output must include a
  concise `keep_separate_reason`.

### Forbidden

- Recommending `keep_separate` without rationale.

---

# UI and Accessibility Hygiene

## Summary

Defines deterministic hygiene checks for `className` and `aria-label` in
refactor planning without expanding architecture scope.

---

## Rule: Refactor — `className` Hygiene and Correct Placement
**Rule ID:** rrp-ui-classname-hygiene  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Remove style-prop drift without creating new architecture or
prop soup.

### Requirement

- Detect `className` as incorrect/suspect when any is true:
  - non-DOM modules accept `className` but do not render a DOM root:
    - `hooks/**`, `features/*/hooks/**`
    - `features/*/domain/**`, `lib/**`
    - `api/**`
    - `config/**`
  - a component accepts `className` but does not pass it to a stable root
    element (unused prop or inconsistent inner-child application).
  - a feature section/page repeatedly uses `className` as a layout escape
    hatch.
  - a composite accumulates slot-style prop explosion (`headerClassName`,
    `rowClassName`, `cellClassName`, etc.) without multiple real call sites
    needing them.
  - `className` is used to encode domain state (for example `taskCompleted`,
    `projectArchived`) instead of being derived internally from domain
    props/state.
- Evaluate smallest compliant action in this order:
  1. remove unused `className` props (and update callers)
  2. forward `className` correctly to one stable DOM root (preferred for
     `ui/primitives/**` and most `ui/composites/**`)
  3. replace deep external styling needs with composition (wrapper in composing
     layer)
  4. extract reusable UI wrapper/composite when multiple call sites style the
     same structural pattern
  5. consolidate style extension by reusing canonical repo merge helper
     (for example `lib/cn.ts`) when present
  6. stop/block when fixing needs structural expansion (new top-level folders,
     cross-home moves, new dependencies, or second styling system) and return
     scoped expansion request.

### Forbidden

- Adding `className` for consistency to components that should not be style
  extensible.
- Introducing new styling prop patterns (`sx`, `styles`, etc.) in repos already
  using `className`.
- Adding many slot-level class props in composites without clear multi-call-site
  evidence.

### Notes

- Prefer remove/forward over introducing new APIs.
- Repeated external styling overrides on feature sections signal boundary smell;
  consider extracting a composite or composing wrappers at page level.

---

## Rule: Refactor — `aria-label` Hygiene and Correct Placement
**Rule ID:** rrp-a11y-aria-label-hygiene  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevent ARIA misuse while ensuring every control has a correct
accessible name.

### Requirement

- Detect `aria-label` as incorrect/suspect when any is true:
  - added to non-interactive wrappers (`div`, `section`, `span`) without real
    accessible-name requirement.
  - added to interactive element that already has a good visible label.
  - accepted by container components that do not own the interactive element.
  - added in shared UI with hardcoded domain semantics.
  - generic/wrong naming (`Button`, `Click`, `Icon`) or labels that do not
    reflect current state/action.
  - used where `<label>`/`aria-labelledby` should be used because visible text
    already exists.
  - added where native semantics already provide correct naming/role and ARIA
    makes it worse.
- Evaluate smallest compliant action in this order:
  1. remove redundant/incorrect `aria-label` when correct accessible name
     already exists
  2. move accessible-name ownership to correct layer:
     - feature sections/pages define domain labels
     - shared primitives/composites accept+forward ARIA props
  3. replace with better mechanism:
     - use `<label>`/`aria-labelledby` for labeled inputs
     - use `aria-label` for icon-only controls
  4. fix wording to specific, state-correct labels
  5. add missing accessible name for icon-only/custom controls via primitive
     pass-through or visible label
  6. stop/block when fixes need structural scope expansion and return scoped
     expansion request.

### Forbidden

- Blanket adding `aria-label` across UI.
- Hardcoding domain-specific accessible names in shared `ui/**`.
- Leaving interactive controls without any accessible name.
- Adding ARIA that conflicts with native semantics (wrong role/name
  combinations).

### Notes

- For icon-only controls, `aria-label` is usually correct.
- Prefer `aria-labelledby` when visible text exists and should name the
  control.
- When label meaning depends on state, ensure accessible name updates with
  current state.

---

# Feature-to-Composite Promotion

## Summary

Defines deterministic safeguards for promoting feature-owned components into
shared UI composites during refactor planning.

---

## Rule: Refactor — Promote Feature Components to Shared UI Composites Safely
**Rule ID:** rrp-promote-feature-to-composite  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Enables promote-to-shared-composite refactors without domain
leakage, parallel homes, or churn-heavy migration.

### Requirement

- Promotion from feature-owned component to `ui/composites/**` is allowed only
  when all eligibility checks pass:
  1. cross-domain reuse evidence exists (2+ domains/features or clearly
     imminent in current scoped plan),
  2. component is a UI pattern and can be described without domain terms,
  3. domain dependencies are removable with small changes,
  4. API remains clean without domain mode flags (use slots/children/render
     props for variability),
  5. promotion does not create a new concern home and uses existing
     authoritative UI composite home.
- Promotion action order must be:
  1. split responsibilities so feature remains owner of domain meaning
     (domain mapping/rules/copy/hooks),
  2. extract domain-agnostic composite in `ui/composites/**` with generic name,
     minimal UI-only state, and root `className` support,
  3. add thin feature adapter wrapper when domain wiring remains needed,
  4. replace call sites incrementally inside approved scope only.
- Naming and placement requirements:
  - shared composite names must be domain-agnostic and pattern-based,
  - composite must live in existing `ui/composites/**` home (or
    gravity-equivalent),
  - extracted helpers stay local unless reused by 2+ domains and pure; then
    promote to `lib/**`.
- Validation gates before accept:
  1. boundary audit:
     - `ui/**` imports only allowed shared layers (`ui/**`, generic `hooks/**`,
       `lib/**`),
     - no `features/**`/`api/**`/`store/**` import leakage into shared UI.
  2. behavior preservation:
     - visible UI behavior, interaction, keyboard/focus, and state/routing
       strategy remain unchanged.
  3. scope audit:
     - remain within caps unless approved expansion,
     - no new dependencies,
     - no new top-level folders.
  4. naming audit:
     - no domain terms in shared composite names/exports.
- Deterministic defaults:
  - if promotion certainty is low, default to feature-local duplication with
    primitive reuse.
  - if sharing requires more than 2 new props or any domain mode flags, default
    to no promotion.
  - if only shell/layout pattern is reusable, extract shell only and keep
    feature-owned content injection.
- If any gate fails, output must be `blocked` with explicit `required_fixes`.

### Forbidden

- Promoting when disqualifiers exist:
  - component imports from `features/**`, `api/**`, `store/**`, or `pages/**`,
  - component encodes domain meaning in naming/props/hardcoded copy,
  - generalization requires domain flags, large prop matrices, or
    config-object abstraction,
  - expected divergence remains high across domains,
  - move requires broad cross-concern migration or unapproved scope-cap
    expansion.
- Using promotion as a pretext for broad unrelated migrations.

### Notes

- Shared composite ownership is presentation concern only; feature layers retain
  domain semantics and domain behavior ownership.

---

# Naming Hygiene

## Summary

Defines deterministic naming-hygiene checks for refactor plans so component/file
naming remains searchable, layer-aligned, and domain-safe.

---

## Rule: Refactor — Naming Hygiene and Correct Placement
**Rule ID:** rrp-naming-hygiene  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents naming drift and misplaced ownership during refactors by
aligning with established naming contracts.

### Requirement

- Treat naming as incorrect/suspect when any is true:
  - component primary export name does not match defining file name (except
    framework-required defaults),
  - semantic file base name exceeds shared file-name limit (`>64` characters,
    excluding extension),
  - domain-named components are placed under `ui/**`,
  - suffix/name does not match responsibility:
    - route orchestrators missing `*Page` convention (or framework route
      equivalent),
    - domain-aware orchestration not using section/panel conventions,
    - reusable UI patterns using domain nouns instead of role/pattern names,
  - hooks not using `use*` naming,
  - DTO naming/contracts violating `*.dto.ts` or `*Dto` conventions in areas
    where they apply,
  - mixed naming dialect in one area (for example unstable mixing of
    `*Shell`/`*Layout`/`*Scaffold` without local convention),
  - junk-drawer naming that hides responsibility (`Common*`, `Shared*`,
    `Utils*`, `Helper*`, `Wrapper*`, `Thing*`, etc.).
- For suspect naming, refactor should evaluate smallest compliant action in this
  order:
  1. rename file/export to match one-file one-primary-export contract,
  2. shorten oversized file/symbol names while preserving local vocabulary and
     role clarity,
  3. rename component to responsibility-aligned, domain-agnostic pattern name
     when in `ui/**`,
  4. relocate ownership to correct layer when domain naming reveals domain
     behavior ownership,
  5. keep local convention where explicit gravity/local standard exists instead
     of introducing a second dialect,
  6. stop/block and return scoped expansion request when correction requires
     broad migration or scope-cap breach.
- Any accepted naming refactor must preserve behavior and remain within current
  scope-governor limits.
- Refactor naming decisions must be consistent with:
  - `rid-naming-discoverability` from
    `react-implementation-discipline/rules/150_naming_discoverability.md`
  - `sr-ownership-naming` from `shared/rules/40_ownership_naming.md`.
  - `sr-filename-length` from `shared/rules/380_filename_length_policy.md`.

### Forbidden

- Renaming for style preference only when no ownership/discoverability issue
  exists.
- Introducing new naming vocabularies in a local area with clear existing
  convention.
- Keeping domain semantics in shared UI names to avoid moving ownership.
- Performing churn-heavy rename waves outside approved scope.

### Notes

- Naming corrections should optimize ripgrep discoverability and ownership
  clarity first; cosmetic consistency is secondary.

---

# Test Suggestion Priority

## Summary

Keeps refactor planning focused on implementation improvements while treating
test-only work as secondary fallback scope.

---

## Rule: Implementation-First Test Suggestion Priority
**Rule ID:** rrp-test-suggestion-priority  
**Priority:** MUST  
**Applies to:** react-refactoring-progression  
**Rationale:** Prevents plans from drifting into test-only cleanup when higher
impact implementation improvements are still available.

### Requirement

- Refactor planning must prioritize implementation-focused improvements first.
- Test updates should be suggested when they are required by selected
  implementation-focused steps (for example preserving behavior coverage after
  rename/extraction/split).
- Test-only improvements may be proposed only when no meaningful
  implementation-focused improvements remain in active scope.
- When test-only fallback is used, include a concise rationale in plan notes
  indicating implementation-focused options were exhausted for current scope.

### Forbidden

- Prioritizing test-only improvements over available implementation-focused
  improvements.
- Expanding scope to test-only cleanup while unresolved implementation
  improvements still exist.
