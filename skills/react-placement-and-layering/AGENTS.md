<!--
DO NOT EDIT THIS FILE DIRECTLY.

This file is generated from shared/rules/*.md and ./rules/*.md
Edit the rule source files instead, then recompile.

Generated on: 2026-02-26
-->

# React Placement and Layering â€” Agent Rules

## Table of contents
- [Rule: Skill Scope Definition [sr-overview-scope]](#rule-skill-scope-definition)
- [Rule: Baseline Non-goals [sr-overview-nongoals]](#rule-baseline-non-goals)
- [Rule: Minimal Scope Enforcement [sr-constraints]](#rule-minimal-scope-enforcement)
- [Rule: Scope Governor Hard Defaults [sr-scope-governor]](#rule-scope-governor-hard-defaults)
- [Rule: Governance Compliance [sr-governance]](#rule-governance-compliance)
- [Rule: Architecture and Dependency Boundaries [sr-architecture-boundaries]](#rule-architecture-and-dependency-boundaries)
- [Rule: Ownership and Naming Contract [sr-ownership-naming]](#rule-ownership-and-naming-contract)
- [Rule: Deterministic Defaults and Pause Protocol [sr-decision-defaults]](#rule-deterministic-defaults-and-pause-protocol)
- [Rule: Output and Planning Discipline [sr-output-discipline]](#rule-output-and-planning-discipline)
- [Rule: Completion and Quality Baseline [sr-dod-baseline]](#rule-completion-and-quality-baseline)
- [Rule: Migration and Placement Strategy [sr-migration-placement]](#rule-migration-and-placement-strategy)
- [Rule: Fallback Technology Defaults [sr-fallback-defaults]](#rule-fallback-technology-defaults)
- [Rule: Implementation Defaults [sr-implementation-defaults]](#rule-implementation-defaults)
- [Rule: Layer Contracts and Error Ownership [sr-layer-contracts]](#rule-layer-contracts-and-error-ownership)
- [Rule: Access and Write Control [sr-access-write-control]](#rule-access-and-write-control)
- [Rule: File Size and Responsibility Guidance [sr-file-size-guidance]](#rule-file-size-and-responsibility-guidance)
- [Rule: Architecture Detection Output and Bootstrap Contract [sr-architecture-detection-contract]](#rule-architecture-detection-output-and-bootstrap-contract)
- [Rule: Enforcement Heuristics [sr-enforcement-heuristics]](#rule-enforcement-heuristics)
- [Rule: Micro-change Bypass and Skill 4 Micro Mode [sr-micro-change-bypass]](#rule-micro-change-bypass-and-skill-4-micro-mode)
- [Rule: Component and Client Module Folderization Threshold [sr-component-folderization]](#rule-component-and-client-module-folderization-threshold)
- [Rule: Folder Structure for a Folderized Component [sr-component-folder-structure]](#rule-folder-structure-for-a-folderized-component)
- [Rule: Naming and Exports Inside Folderized Components [sr-component-folder-exports]](#rule-naming-and-exports-inside-folderized-components)
- [Rule: Promotion and Demotion for Component Helpers [sr-component-helper-promotion]](#rule-promotion-and-demotion-for-component-helpers)
- [Rule: Folderization Must Not Create a New Home [sr-folderization-no-new-home]](#rule-folderization-must-not-create-a-new-home)
- [Rule: Layout and Shell Ownership Decision [sr-layout-shell-placement]](#rule-layout-and-shell-ownership-decision)
- [Rule: Layout and Shell Subfolder Policy [sr-layout-shell-subfolder-policy]](#rule-layout-and-shell-subfolder-policy)
- [Rule: `className` Support Policy [sr-ui-classname-support]](#rule-classname-support-policy)
- [Rule: `aria-label` and Accessible Name Policy [sr-a11y-aria-label]](#rule-aria-label-and-accessible-name-policy)
- [Rule: DOM Rendering Boundaries and Primitive Creation Discipline [sr-dom-rendering-and-primitives]](#rule-dom-rendering-boundaries-and-primitive-creation-discipline)
- [Rule: Prop Count Caps and Escalation Actions [sr-prop-count-caps]](#rule-prop-count-caps-and-escalation-actions)
- [Rule: Mega-File Triage and Extraction Plan [sr-mega-file-triage]](#rule-mega-file-triage-and-extraction-plan)
- [Rule: Prop Grouping Discipline [sr-prop-grouping-discipline]](#rule-prop-grouping-discipline)
- [Rule: i18n Extraction for User-Facing UI Text [sr-i18n-text-extraction]](#rule-i18n-extraction-for-user-facing-ui-text)
- [Rule: Skill Scope Definition [rpl-overview-scope]](#rule-skill-scope-definition-1)
- [Rule: Layer Mapping [rpl-process]](#rule-layer-mapping)
- [Rule: Structured Placement Output [rpl-output]](#rule-structured-placement-output)
- [Rule: Strategy and One-Home Discipline [rpl-migration-safety]](#rule-strategy-and-one-home-discipline)
- [Rule: Default Bias and Clean Pause Protocol [rpl-default-bias]](#rule-default-bias-and-clean-pause-protocol)
- [Rule: Discovery Coverage and Convention Alignment [rpl-discovery-conventions]](#rule-discovery-coverage-and-convention-alignment)
- [Rule: Constraint-Aware Placement Scope [rpl-scope-governor]](#rule-constraint-aware-placement-scope)
- [Rule: Repository Evidence Access [rpl-access-control]](#rule-repository-evidence-access)
- [Rule: Fixed Execution-Skill Scope [rpl-skill-model-alignment]](#rule-fixed-execution-skill-scope)
- [Rule: Implementation Output Format Defaults [rpl-implementation-handoff]](#rule-implementation-output-format-defaults)

## Overview
This document defines the authoritative rules for agents/LLMs using the `react-placement-and-layering` skill.

Key constraints:
- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.
- If a rule references a rule ID, the rule ID must be followed exactly.

## Rule index
- sr-overview-scope
- sr-overview-nongoals
- sr-constraints
- sr-scope-governor
- sr-governance
- sr-architecture-boundaries
- sr-ownership-naming
- sr-decision-defaults
- sr-output-discipline
- sr-dod-baseline
- sr-migration-placement
- sr-fallback-defaults
- sr-implementation-defaults
- sr-layer-contracts
- sr-access-write-control
- sr-file-size-guidance
- sr-architecture-detection-contract
- sr-enforcement-heuristics
- sr-micro-change-bypass
- sr-component-folderization
- sr-component-folder-structure
- sr-component-folder-exports
- sr-component-helper-promotion
- sr-folderization-no-new-home
- sr-layout-shell-placement
- sr-layout-shell-subfolder-policy
- sr-ui-classname-support
- sr-a11y-aria-label
- sr-dom-rendering-and-primitives
- sr-prop-count-caps
- sr-mega-file-triage
- sr-prop-grouping-discipline
- sr-i18n-text-extraction
- rpl-overview-scope
- rpl-process
- rpl-output
- rpl-migration-safety
- rpl-default-bias
- rpl-discovery-conventions
- rpl-scope-governor
- rpl-access-control
- rpl-skill-model-alignment
- rpl-implementation-handoff

---

# Overview

## Summary

This document defines the authoritative rules for the `react-placement-and-layering` skill.

This skill operates under:
- `react-placement-and-layering` (with mandatory shared baseline policy baked in at build time)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** sr-overview-scope  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared baseline governance and scope constraints explicit.

### Requirement

- The skill must operate only within its defined responsibility.
- The skill must not perform responsibilities assigned to other skills.
- The skill must not reinterpret or override policy without explicit approval.
- The shared baseline must apply uniformly to:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`
- The production execution skill set for this initiative is fixed to those four
  skills; the shared baseline policy is not a production execution skill.
- Shared policy/config updates must not be modeled as new execution skills.
- Document precedence must remain deterministic:
  - `specs/001-agent-policy-v1/master_spec.md` is authoritative.
  - Supporting policy docs may fill non-conflicting open details only.
- The shared baseline must explicitly govern:
  - Architecture/dependency boundaries.
  - Deterministic defaults and pause behavior.
  - Scope-governor limits and expansion protocol.
  - Output consistency for planning and implementation.
  - Ownership/naming conventions and completion checks.

### Forbidden

- Expanding scope beyond the Scope Governor without explicit override.
- Introducing implicit changes to repository structure.
- Creating competing policy sources that conflict with shared baseline precedence.
- Adding new production execution skills without explicit scope/constitution
  update.

---

## Rule: Baseline Non-goals
**Rule ID:** sr-overview-nongoals  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents policy drift into implementation-specific prescriptions.

### Requirement

- Shared policy must define constraints and governance, not implementation
  recipes.
- Shared policy must not implicitly change through examples, migration behavior,
  or downstream reinterpretation.
- Downstream skills may add local guidance only when it does not conflict with
  shared mandatory rules.

### Forbidden

- Treating examples as policy overrides.
- Introducing stack/framework mandates as shared-policy requirements without
  explicit spec approval.

### Notes

- If uncertainty affects governance decisions, pause and request clarification.

---

# Policy Constraints

## Summary
Defines non-negotiable scope and cap controls for downstream skill work.

---

## Rule: Minimal Scope Enforcement
**Rule ID:** sr-constraints  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents uncontrolled scope expansion and dependency creep.

### Requirement

- Changes must stay within the requested feature scope.
- New top-level folders must not be added without explicit approval.
- New dependencies must not be added without explicit approval.
- `pre_approved_collisions` must exist only in shared baseline header and be
  empty unless explicitly approved in a future version.
- When work appears to exceed scope caps, deliver the smallest viable in-cap
  result and provide a structured follow-up scope list.

### Forbidden

- Silent expansion of scope.
- Introducing unapproved dependencies or repositories.
- Defining downstream-local collision registries.
- Mixing structural migration moves with feature behavior work unless explicitly
  requested.

### Notes

- If a requirement cannot be met without expanding scope, pause and request
  approval.

---

## Rule: Scope Governor Hard Defaults
**Rule ID:** sr-scope-governor  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Controls churn and keeps delivery bounded.

### Requirement

- Hard defaults (unless explicitly overridden):
  - Max files touched: `8`
  - Max new files: `4`
  - Max moved/renamed files: `0` (unless migration mode explicitly enabled)
  - Max new dependencies: `0`
  - Max new top-level folders: `0`
- When caps are exceeded, provide a structured scope expansion request with
  concrete `why` and `would_touch` fields, while still delivering an in-cap
  result.

### Forbidden

- Exceeding hard defaults silently.
- Expanding dependency or top-level folder scope without explicit approval.

---

# Governance

## Summary
Sets expectations for compliance, documentation, and review.

---

## Rule: Governance Compliance
**Rule ID:** sr-governance  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures policies are enforced consistently across changes.

### Requirement

- All changes must be validated against the constitution and project specs.
- Documentation updates must keep guidance accurate and current.
- Generated artifacts must be produced by the official build process.
- Shared-policy rule changes must include an explicit policy version increment
  with documented rationale.
- Shared-policy exception approvals must be performed by repo maintainers only.
- Exception records must include rationale and conflicting rule reference.
- Exception records must not include expiry metadata; approved exceptions remain
  active until explicitly revoked or superseded by newer policy version.
- `pre_approved_collisions` must be managed only in the shared baseline header.
- Policy behavior must not be changed implicitly via examples, migration
  behavior, or downstream reinterpretation.

### Forbidden

- Bypassing validation requirements.
- Manual edits to generated artifacts.
- Approving shared-policy exceptions from non-maintainer roles.
- Adding expiry fields to shared-policy exception records.
- Defining downstream-local `pre_approved_collisions` sources.
- Changing shared-policy semantics without a version and rationale update.

### Notes

- If governance rules conflict, the constitution takes precedence.

---

# Architecture Boundaries

## Summary
Defines shared architecture and dependency-boundary rules all downstream skills
must enforce.

---

## Rule: Architecture and Dependency Boundaries
**Rule ID:** sr-architecture-boundaries  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills enforce one consistent
architecture and import-boundary model.

### Requirement

- The following non-negotiables must be enforced:
  - Do not create new folders unless explicitly allowed by policy or user
    instruction.
  - Never place domain business logic in `ui/**` or `api/**`.
  - Never fetch outside the canonical endpoint layer
    (`api/endpoints/**` or gravity-equivalent API home).
  - Prefer small, composable changes over large refactors.
  - Avoid `shared/` or `common/` dumping-ground patterns.
- Dependency direction must remain consistent with the baseline:
  - `ui/**` must not import `features/**`, `api/**`, `store/**`, or `pages/**`.
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`.
  - `features/**` must not import `pages/**`.
  - `pages/**` must not import canonical endpoint modules directly.
  - `hooks/**` must not import `features/**`, `pages/**`, or `store/**`; imports
    from `api/**` are allowed only when documented in exactly one canonical
    policy location.
- The canonical endpoint layer must be determined once per task by Architecture
  Detection and reused consistently in boundary checks for that task.
- If a path alias exists (for example `@/`), all boundary rules apply equally to
  alias imports and raw `src/**` imports.
- Generic fetch-hook exceptions are valid only when documented in exactly one
  canonical policy location; multiple policy locations invalidate the exception.
- No second home may be introduced for the same concern (UI/API/store/routing)
  unless explicit migration scope is approved.

### Forbidden

- Competing homes for the same concern in the same scope.
- Domain terms in reusable `ui/**` component file names.
- DTO-to-domain mapping in `api/**`.

### Notes

- Architecture Detection owns gravity decisions; downstream skills inherit those
  decisions unless a valid pause is triggered.

---

# Ownership and Naming

## Summary
Defines shared ownership boundaries and naming conventions for downstream skill
specifications.

---

## Rule: Ownership and Naming Contract
**Rule ID:** sr-ownership-naming  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps responsibility boundaries and naming deterministic across
all downstream specs.

### Requirement

- `pages/**` remain thin route orchestrators.
- `features/**` own domain behavior, feature hooks, and domain mapping.
- `ui/primitives/**` and `ui/composites/**` stay domain-agnostic.
- `api/**` stays transport-only and returns DTOs or normalized errors.
- `store/**` is global client-state only; do not mirror server-state without
  explicit justification.
- Naming conventions must remain deterministic:
  - `*Page.tsx` for pages.
  - `*Section.tsx` for feature sections.
  - `use*.ts` for hooks.
  - `*.dto.ts` and `*Dto` for DTOs.
- Naming and exports must remain searchable and consistent:
  - Prefer matching file/export names.
  - Prefer named exports unless framework conventions require default exports.
  - Avoid introducing barrel files unless the local area already uses them
    consistently.

### Forbidden

- Domain mode flags in shared composites.
- Introducing new naming schemes when local patterns are clear.
- API transport concerns in UI or generic hook layers.
- Mixed synonym vocabularies for the same role in the same scope (for example
  mixing `Page` and `Route` naming without existing convention).

---

# Decision Defaults and Pause Rules

## Summary
Defines deterministic default behavior and high-impact clarification triggers.

---

## Rule: Deterministic Defaults and Pause Protocol
**Rule ID:** sr-decision-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Reduces unnecessary clarification loops while protecting
high-impact structural decisions.

### Requirement

- Use deterministic defaults for non-structural ambiguity.
- Pause only when both are true:
  - `confidence < 0.7`
  - `impact = structural`
- Structural impact includes top-level structure changes, competing concern
  homes, dependency-direction changes, cross-layer moves, global state strategy
  changes, or scope-cap violations.
- When pausing, use clean pause protocol:
  - State ambiguity clearly.
  - Present 2-3 options.
  - Recommend a default.
  - Wait for confirmation.
- Use `balanced` pause mode by default unless explicitly configured otherwise.
- Do not pause for minor decisions when a safe default exists.

### Forbidden

- Proceeding on structural ambiguity without pause.
- Repeated low-value questions when a safe deterministic default exists.
- Vague, non-blocking, or style-only clarification questions that do not change
  structural outcomes.

---

# Output and Planning Discipline

## Summary
Defines required output structure for planning and implementation guidance.

---

## Rule: Output and Planning Discipline
**Rule ID:** sr-output-discipline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps downstream planning and implementation outputs consistent,
compact, and reviewable.

### Requirement

- Planning outputs must include:
  - File touch plan (`Create`/`Update`/`Reuse` with paths).
  - Layer justification.
  - Reuse decision notes (`reuse as-is`, `updated`, `new`).
  - A short decision explanation that states detected architecture signals and
    chosen direction.
- Planning outputs must use a machine-readable JSON object with:
  - `output_mode` (`human|agent`)
  - `presentation.user_markdown` (prettified summary of the payload)
  - `notes[]` limited to 5 items
- `output_mode` defaulting must be deterministic:
  - default to `human` when a human explicitly instructs a skill to run
  - otherwise default to `agent`
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.
- Implementation output must:
  - Use changed snippets for updated files by default.
  - Use unified diff when edits are scattered across non-adjacent regions.
  - Use full content for new files.

### Forbidden

- Full existing-file dumps unless explicitly requested or file is small and
  fully changed.
- Unstructured narrative-only planning outputs.
- Omitting `presentation.user_markdown` from output payloads.

---

# Completion and Quality Baseline

## Summary
Defines mandatory completion checks and runtime-safety expectations inherited by
all downstream skills.

---

## Rule: Completion and Quality Baseline
**Rule ID:** sr-dod-baseline  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures every downstream skill validates critical correctness and
safety gates before completion.

### Requirement

- Boundary audit must pass:
  - No forbidden imports by layer.
  - No fetching outside canonical endpoint layer.
  - `api/**` remains transport-only.
- Runtime safety baseline:
  - Loading state handling when server data is involved.
  - Error state handling.
  - Empty state handling for list/collection views.
  - No unhandled promise rejections.
- Minimal churn baseline:
  - Touch only planned files unless deviations are explained.
  - Avoid unrelated refactors.
- If tooling exists, applicable checks must pass (`tsc`, lint, and existing test
  suites relevant to changed behavior).
- If TanStack Query (or equivalent) is used, query correctness checks must
  ensure stable keys, intended invalidation, and justified server-state/store
  boundaries.
- Tests are required only when a suite already exists and changed behavior falls
  within that suite's scope.

### Forbidden

- Marking work done without boundary/safety checks.
- Treating optional quality checks as mandatory when repository tooling does not
  exist.
- Claiming compliance while skipping available type/lint checks in repositories
  that provide those checks.

---

# Migration and Placement Strategy

## Summary
Defines migration-aware placement rules and strategy selection constraints.

---

## Rule: Migration and Placement Strategy
**Rule ID:** sr-migration-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents mixed-architecture drift and keeps placement decisions
deterministic in legacy or evolving repositories.

### Requirement

- Do not introduce parallel architectures for the same concern.
- Choose a strategy per change:
  - Follow existing.
  - Introduce target structure at boundaries.
  - Migrate as you touch (explicit migration scope only).
- Default balanced behavior:
  - No moves/renames unless explicitly enabled.
  - Introduce new homes only when isolated and non-competing.
  - Keep feature behavior and structural migration separate unless explicitly
    requested.
- Gravity decisions from Architecture Detection are inherited by downstream
  skills and must not be recomputed unless pause/escalation resolves a conflict.
- If move mode is explicitly enabled, keep moves small and complete import
  updates in the same change.

### Forbidden

- Two active homes for the same concern in one scope.
- Mixing broad structural migration with unrelated behavior changes.
- Recomputing gravity independently in downstream skills without escalation.

---

# Fallback Technology Defaults

## Summary
Defines shared fallback defaults used only when repository conventions are
missing or ambiguous.

---

## Rule: Fallback Technology Defaults
**Rule ID:** sr-fallback-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures deterministic cross-skill defaults while honoring
existing repository gravity first.

### Requirement

- Existing repository stack/conventions take precedence over fallback defaults.
- If no clear convention exists, defaults are:
  - Server-state: TanStack Query; keep transport in `api/endpoints/**`.
  - Client-state: local-first; global store only when truly global.
  - Routing: React Router for plain React; framework-native routing when
    framework is detected.
  - Styling: follow existing; Tailwind default only for greenfield.
  - Forms: react-hook-form.
  - Validation: Zod at boundaries (DTO/form), with domain schema ownership in
    feature domain layers.
  - HTTP client: native `fetch` via shared wrapper; normalized `ApiError`;
    conservative retry posture.
  - Build tool: Vite for greenfield plain React unless existing conventions say
    otherwise.
  - Date/localization: native `Date` and `Intl` unless domain needs justify
    more.
  - Identifier strategy: string IDs by default.

### Forbidden

- Introducing competing stack choices mid-repository without explicit request.
- Mirroring server-state into global store without explicit justification.

---

# Implementation Defaults

## Summary
Defines shared implementation posture defaults inherited by downstream skills.

---

## Rule: Implementation Defaults
**Rule ID:** sr-implementation-defaults  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Aligns downstream implementation behavior on quality, environment
access, logging, and tooling posture.

### Requirement

- Feature flags must be centralized in `config/featureFlags.ts` and evaluated at
  composition boundaries.
- Reusable UI components should support class extension patterns consistently
  (for example `className` with shared merge helper where applicable).
- Accessibility baseline is required for reusable UI.
- Performance posture is readability-first; memoization optimizations require
  concrete justification.
- Repository topology must be detected (single-app vs monorepo) and rules
  applied per app root when monorepo signals exist.
- Module-boundary tooling posture is spec-first:
  - Start with import-boundary review checks.
  - Add lint/tool enforcement only when explicitly requested as dedicated
    hardening scope.
  - Mirror alias paths in boundary lint rules when aliases are present.
- Environment access must be centralized through `config/env.ts`.
- Logging should use shared logger abstractions; avoid committed debug logging.
- Codegen is opt-in only; default to handwritten endpoint/DTO ownership.
- Storybook/docs are optional and should follow existing setup when present.

### Forbidden

- Direct environment reads outside `config/env.ts`.
- Committing `console.log`/`console.debug` in production code paths.
- Introducing codegen or docs platforms as implicit scope expansion.
- Adding boundary/tooling stacks implicitly in routine feature scope.

---

# Layer Contracts

## Summary
Defines shared folder-layer contracts and cross-layer error handling ownership.

---

## Rule: Layer Contracts and Error Ownership
**Rule ID:** sr-layer-contracts  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps ownership deterministic across pages, features, UI, API,
store, core, hooks, lib, and config.

### Requirement

- `pages/**` are route orchestrators and must not fetch directly from canonical
  endpoint modules.
- `features/**` own domain logic, feature hooks, and DTO-to-domain mapping.
- `ui/**` remains domain-agnostic and transport-agnostic.
- `api/**` remains transport-only with DTO ownership and normalized error
  outputs.
- `store/**` is global client-state only; server-state source of truth remains
  query cache.
- `core/**` composes providers/setup rather than domain behavior.
- `hooks/**` are cross-domain generic hooks unless in feature-owned hook homes.
- `config/**` is canonical home for env and feature-flag access points.
- Cross-layer error handling follows three-stage ownership:
  - `api/endpoints/**`: normalized transport errors.
  - `features/*/hooks/**`: expose hook-level error shapes.
  - `pages/**` and `features/*/sections/**`: choose user-facing feedback.

### Forbidden

- Fetching or transport logic in page/UI layers.
- Domain logic in `ui/**` or transport mapping in `api/**`.
- UI feedback policy embedded in transport layers.

---

# Access and Write Control

## Summary
Defines shared access assumptions and write-control behavior for downstream
skills.

---

## Rule: Access and Write Control
**Rule ID:** sr-access-write-control  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps structural decisions grounded in repository signals and
maintains controlled, reviewable changes.

### Requirement

- Detection/reuse/planning stages require repository read/search access.
- Minimum capabilities include:
  - Listing relevant file trees.
  - Searching code patterns.
  - Reading source/config files on demand.
- If direct access is unavailable, require a fallback context bundle with file
  tree, package/tooling config, router entry, API home, and representative
  module examples.
- Default write posture must be controlled and reviewable.
- If direct writes are enabled, scope-governor and minimal-churn rules still
  apply.
- Architecture/specification document edits require explicit request and must be
  treated as dedicated documentation scope.

### Forbidden

- Structural placement decisions without repository signal checks.
- Silent broad writes that bypass scope and review controls.
- Auto-editing architecture/spec documents during regular implementation work.

---

# File Size Guidance

## Summary
Defines soft file-size and responsibility guidance to prevent oversized modules.

---

## Rule: File Size and Responsibility Guidance
**Rule ID:** sr-file-size-guidance  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Encourages maintainable module boundaries and limits
responsibility drift.

### Requirement

- Treat folder-specific line limits as soft caps, not hard compile gates.
- Prefer responsibility-based splitting when files become hard to reason about.
- Use practical warning signals:
  - Around 400 lines: architecture smell.
  - Around 600+ lines: refactor strongly recommended.
- Favor this practical rule: no file should require more than about three screen
  heights to understand its primary responsibility.

### Forbidden

- Ignoring clear multi-responsibility smells in oversized files.

---

# Architecture Detection Contract

## Summary
Defines the shared contract that downstream skills must inherit from
architecture-detection outputs, including bootstrap behavior.

---

## Rule: Architecture Detection Output and Bootstrap Contract
**Rule ID:** sr-architecture-detection-contract  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Ensures all downstream skills consume one consistent
architecture-detection result and bootstrap behavior.

### Requirement

- Architecture detection output must include the shared structural signals:
  - `routing.type`
  - `ui.home`
  - `api.home` (canonical endpoint layer for boundary checks)
  - `domain.organization`
  - `gravity_map`
  - `alignment_score`
  - `strategy`
  - `notes[]`
- Gravity decisions are owned by architecture detection and reused by all
  downstream skills within the same task.
- Downstream skills must not recompute/override gravity unless a structural
  pause is triggered and explicitly resolved.
- Bootstrap behavior applies only when no clear concern homes exist:
  - Allow folder creation only from the canonical set:
    `pages/`, `features/`, `ui/primitives/`, `ui/composites/`, `api/client/`,
    `api/dto/`, `api/endpoints/`, `core/`, `lib/`, `hooks/`, `config/`
  - `store/` may be created only when truly global client-state is required.
  - Prefer minimal bootstrap: create only folders needed for the current task.

### Forbidden

- Consuming inconsistent architecture-detection outputs across downstream skills
  for the same task.
- Creating speculative bootstrap folders not needed by the current task.

---

# Enforcement Heuristics

## Summary
Defines shared heuristics for identifying placement violations and validating
folder-fit decisions.

---

## Rule: Enforcement Heuristics
**Rule ID:** sr-enforcement-heuristics  
**Priority:** SHOULD  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Provides consistent review heuristics across downstream skills
without over-prescribing implementation details.

### Requirement

- Treat a file as likely misplaced when one or more signals appear:
  - It imports forbidden layer dependencies.
  - It contains domain terms while living in reusable `ui/**` homes.
  - It performs network fetches outside canonical endpoint modules.
  - It performs DTO-to-domain mapping inside `api/**`.
- Use a simple placement sanity map in reviews:
  - Endpoint call -> `api/endpoints/*`
  - React Query hook -> `features/<domain>/hooks/*`
  - DTO -> domain mapping -> `features/<domain>/domain|adapters/*`
  - Reusable primitives/composites -> `ui/primitives|composites/*`
  - Route orchestration -> `pages/*`
  - Shared config/env -> `config/*`

### Forbidden

- Ignoring clear layer-violation signals during conformance checks.

---

# Micro-change Bypass

## Summary
Defines deterministic conditions for bypassing Skills 1-3 and invoking
implementation discipline directly in micro mode.

---

## Rule: Micro-change Bypass and Skill 4 Micro Mode
**Rule ID:** sr-micro-change-bypass  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Allows low-risk behavior-preserving refactors to stay fast while
still enforcing implementation discipline and boundary checks.

### Requirement

- A request may be classified as `micro_change` only when all are true:
  - behavior-preserving refactor intent is explicit.
  - expected touched files are `<= 2`.
  - no new files are required.
  - no move/rename operations are required.
  - no new endpoint/hook/composite homes are introduced.
  - no routing changes are required.
- If `micro_change` is confirmed:
  - Skills 1-3 may be bypassed.
  - Skill 4 may be used directly in `micro mode`.
  - As an alternative, an external checklist-only path may be used when Skill 4
    is not selected.
- Skill 4 `micro mode` must still enforce:
  - boundary audits
  - minimal churn
  - validation/quality checks and explicit check results
  - structured output discipline
- If any `micro_change` condition cannot be confirmed, use the normal staged
  pipeline instead of bypass.

### Forbidden

- Using micro-change bypass for feature additions or structural migrations.
- Skipping boundary/quality validation because the change is small.
- Treating uncertain scope as micro-change without explicit evidence.

---

# Component Folderization

## Summary
Defines when components and transport client modules should remain single-file
versus decomposed/folderized, and how extracted modules must be structured and
named.

---

## Rule: Component and Client Module Folderization Threshold
**Rule ID:** sr-component-folderization  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps UI modules and transport clients maintainable without
creating mega files or mixed-responsibility endpoints.

### Requirement

- Keep a component as a single file when all are true:
  - file is about `<= 200` lines and has one clear responsibility
  - helpers are small and render-support only
  - there are at most two closely related internal subcomponents
- Keep a transport client module as a single file when all are true:
  - file stays focused on shared transport concerns (request wrapper,
    auth/header wiring, transport error normalization),
  - endpoint/domain-specific call orchestration is not embedded in the client
    file,
  - file is reasonably small (about `<= 250` lines).
- Folderize (move to a component module folder) when any is true:
  1. file is about `> 250-300` lines and splitting reduces responsibilities
  2. component contains three or more meaningful internal subcomponents
  3. non-trivial local logic should be isolated (mapping/formatting, keyboard
     handling, complex derived state)
  4. it has component-scoped assets (styles/icons/constants)
  5. it is reused broadly and needs a stable module boundary
- Decompose transport client logic when any is true:
  1. canonical client file grows to about `> 250-300` lines and mixes concerns,
  2. endpoint-specific URLs/methods/payload shaping accumulate in the client
     file,
  3. multiple domain endpoint calls are orchestrated from one client file.
- Hard rule:
  - if a single component file exceeds `400` lines, folderization is required
    unless explicitly justified in output notes and/or review metadata.
  - if a transport client file (for example `api/client/client.ts`) exceeds
    `400` lines, extraction is required unless explicitly justified in output
    notes and/or review metadata.
- Expected extraction target for oversized transport client files:
  - endpoint/domain call functions must be extracted to `api/endpoints/**` or
    the repository's gravity-equivalent canonical endpoint home,
  - `api/client/**` remains a thin transport foundation (request wrapper,
    auth/header wiring, retry policy, normalized transport errors).
- This rule applies across skills and is enforced most strongly in
  `react-implementation-discipline` during execution output validation.

### Forbidden

- Keeping oversized multi-responsibility component files as single files without
  explicit justification.
- Treating folderization as optional when the hard threshold is crossed.
- Keeping endpoint-specific call orchestration in a mega transport client file
  instead of extracting to `api/endpoints/**` (or gravity-equivalent endpoint
  home).

### Notes

- Quick folderization heuristic: folderize when any is true:
  - file has two or more responsibilities
  - splitting subcomponents would improve clarity
  - helper pile is component-local only
  - file is above about `300` lines and still growing
- Quick transport-client heuristic: when the shared client starts accumulating
  endpoint paths, payload shaping, and domain branching, extract those calls to
  `api/endpoints/**` (or gravity-equivalent endpoint home) and keep the client
  thin.

---

## Rule: Folder Structure for a Folderized Component
**Rule ID:** sr-component-folder-structure  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents random folder soup and keeps discovery/search
predictable.

### Requirement

- Default required structure for folderized component `ProjectSelector`:

```text
ProjectSelector/
  ProjectSelector.tsx
  index.ts            (optional; only when local area already uses barrels)
```

- Allowed colocated files must be component-scoped only:
  - `ProjectSelector.utils.ts` (component-local pure helpers)
  - `ProjectSelector.types.ts` (component-local types)
  - `ProjectSelector.constants.ts` (component-local constants)
  - `ProjectSelector.styles.module.css` (or local styling per repo convention)
  - `ProjectSelector.test.tsx` (component tests)
- `components/` subfolder is allowed only when module size/complexity justifies
  it and subcomponents remain component-local.

### Forbidden

- Adding transport/backend access layers (`api/`) inside a component folder.
- Adding cross-domain generic utility buckets (for example `utils/` junk drawer
  subfolders).
- Placing shared primitives inside component-owned folders (shared primitives
  belong in `ui/primitives/**`).

---

## Rule: Naming and Exports Inside Folderized Components
**Rule ID:** sr-component-folder-exports  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps imports stable and grep-friendly.

### Requirement

- Main component file must match folder name and primary export:
  - `ProjectSelector/ProjectSelector.tsx` exports `ProjectSelector`.
- Import style:
  - prefer explicit import path to main file, or
  - folder import only when `index.ts` exists and local area already uses
    barrels.
- Subcomponents should carry module prefix (for example
  `ProjectSelectorItem`, `ProjectSelectorDropdown`) for searchability.

### Forbidden

- Random unprefixed subcomponent names like `Item.tsx` and `Dropdown.tsx`.
- Introducing new barrel patterns in areas that do not already use them.

---

## Rule: Promotion and Demotion for Component Helpers
**Rule ID:** sr-component-helper-promotion  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents leaking component-specific helpers into global utility
layers.

### Requirement

- Move helper from component folder to `lib/**` only when both are true:
  - helper is reused by two or more domains/features
  - helper is pure (no React imports and no feature/domain knowledge)
- Move helper to `features/<domain>/domain/**` when helper encodes domain
  behavior, even if used across multiple files within that feature.
- Keep component-local helpers colocated when reuse and purity thresholds for
  promotion are not met.

### Forbidden

- Promoting helpers to `lib/**` solely because the source component file is
  large.
- Promoting domain-aware helpers to `lib/**`.

---

## Rule: Folderization Must Not Create a New Home
**Rule ID:** sr-folderization-no-new-home  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents second-architecture drift.

### Requirement

- Folderization must stay inside existing gravity home:
  - if component is under `src/components/**`, folderized module stays there
  - if component is feature-owned, folderized module stays in that feature path
- Folderization must preserve current concern ownership and import-boundary
  rules.
- Relocation across homes during folderization is allowed only in explicit
  migration mode with clear boundary scope.

### Forbidden

- Using folderization as justification to create a new top-level `ui/`,
  `shared/`, or other competing concern home.
- Silent home relocation under the guise of formatting/refactor-only work.

---

# Layout and Shell Placement

## Summary
Defines deterministic placement for layout/shell components and prevents
parallel layout homes.

---

## Rule: Layout and Shell Ownership Decision
**Rule ID:** sr-layout-shell-placement  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Removes ambiguity between `ui/primitives`, `ui/composites`, and
`features/<domain>/sections` for layout-like components.

### Requirement

- Place in `ui/primitives/**` only when the component is a low-level building
  block with minimal structure/behavior.
  - Typical primitives: `Stack`, `Box`, `Spacer`, `Grid`, thin `Container`.
- Place in `ui/composites/**` when the component composes multiple primitives
  into a reusable UI pattern.
  - Typical composites: `PageShell`, `ModalShell`, `PanelShell`,
    `MasterDetailLayout`, `AppShell`, `SidebarLayout`, `CardLayout`,
    `TableShell`, `EmptyStatePanel`.
- Place in `features/<domain>/sections/**` when the layout is domain-owned
  composition, even if it looks like a generic layout.
  - Example: project-specific layout section with domain navigation, filters,
    or domain-state behavior.
- Fast decision rule:
  - minimal low-level building block -> primitive
  - reusable composed pattern -> composite
  - domain-owned composition/behavior -> feature section
- This rule applies to all skills and must be enforced most strongly during
  execution in `react-implementation-discipline`.

### Forbidden

- Treating reusable shells/layout patterns as primitives.
- Treating domain-owned layout composition as shared composite by default.
- Using unclear "looks like layout" labeling to bypass domain ownership checks.

### Notes

- If ownership is ambiguous and impact is structural, use shared pause protocol
  thresholds.

---

## Rule: Layout and Shell Subfolder Policy
**Rule ID:** sr-layout-shell-subfolder-policy  
**Priority:** MUST  
**Applies to:** react-architecture-detection, react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents creation of competing layout homes while allowing
bounded categorization inside composites when needed.

### Requirement

- Default policy: do not create dedicated top-level layout homes for
  `layouts/` or `shells/`.
- If categorization is needed, keep it inside existing composite home:
  - `src/ui/composites/layouts/*`
  - `src/ui/composites/shells/*`
- Allow this subfolder split only when all are true:
  - composite catalog is large/noisy (for example around ten or more layout/shell
    components)
  - repository already uses category subfolders inside `ui/**`
  - split does not create a competing second home
- Folderization/categorization must preserve existing gravity home and
  one-home-per-concern discipline.

### Forbidden

- Creating a parallel top-level home like `src/ui/layouts/*` or
  `src/ui/shells/*` by default.
- Using category split to bypass migration-scope rules.
- Introducing both `ui/composites/*` and new top-level `ui/layouts/*` as active
  homes for the same concern.

---

# UI Extension and Accessibility Policies

## Summary
Defines shared UI `className` extensibility and accessible-name rules for
placement, reuse, and implementation stages.

---

## Rule: `className` Support Policy
**Rule ID:** sr-ui-classname-support  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Keeps shared UI extensible without forcing styling props
everywhere or creating style-override soup.

### Requirement

- UI primitives (`ui/primitives/**`) MUST accept `className?: string` when they
  render a DOM element.
- UI composites (`ui/composites/**`) SHOULD accept `className?: string` for the
  outer wrapper/root element when the composite renders a stable wrapper.
- If the repo uses class merging (Tailwind/CSS utility patterns), prefer one
  shared merge helper (for example `lib/cn.ts`) and reuse it consistently; do
  not invent per-component merge logic.
- Components that do not render DOM (pure logic, context providers, utility
  wrappers) MUST NOT accept `className` unless they explicitly forward it to a
  single DOM root.
- Feature sections (`features/*/sections/**`) MAY accept `className` only when:
  - the section is used in multiple page layouts requiring wrapper styling
    control, or
  - the section is explicitly designed to be composed as a layout block.
  Otherwise, styling should be handled inside the section or by composing
  wrappers in `pages/**`.
- Pages (`pages/**`) SHOULD NOT accept `className` props; pages are route
  orchestrators and styling is internal composition.

### Forbidden

- Adding many style props (`headerClassName`, `footerClassName`, `rowClassName`,
  etc.) by default.
  - Add slot-level class props only when there are multiple real call sites and
    the composite has stable, intentional slots.
- Forcing `className` on every component for consistency.
- Introducing a second styling extension pattern in the same repo (for example
  mixing `className`, `styles`, and `sx`) unless the repo already has an
  explicit multi-system policy.

### Notes

- If a feature section frequently needs external styling overrides, treat it as
  a signal to:
  - extract a reusable UI composite, or
  - introduce a dedicated wrapper/layout component in the composing layer.

---

## Rule: `aria-label` and Accessible Name Policy
**Rule ID:** sr-a11y-aria-label  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline  
**Inherited from:** shared-rules  
**Rationale:** Prevents noisy or incorrect ARIA usage while ensuring
interactive controls always have an accessible name.

### Requirement

- Any interactive control (button/link/input/custom widget) MUST have an
  accessible name, provided by one of:
  - visible text content, or
  - `<label>` + `for` association (or equivalent), or
  - `aria-labelledby`, or
  - `aria-label` as fallback when no visible label exists.
- Use `aria-label` only when there is no appropriate visible label (common
  case: icon-only buttons/links).
- Do not add `aria-label` redundantly when a clear visible label already
  exists.
- Decorative icons/elements MUST be marked appropriately (`aria-hidden="true"`
  or equivalent) when they do not convey meaning.
- UI primitives that render interactive elements SHOULD expose the minimal props
  needed to ensure accessible naming:
  - `aria-label`, `aria-labelledby`, and label/description wiring as
    pass-through attributes where relevant.
- UI composites SHOULD pass through accessibility props to the underlying
  interactive primitives and MUST NOT hardcode domain-specific labels.

### Forbidden

- Blanket-adding `aria-label` to every component or every element.
- Adding `aria-label` to non-interactive wrapper elements solely for
  accessibility.
- Overriding an existing correct accessible name with a worse `aria-label` (for
  example generic labels such as `Button`).
- Encoding domain semantics in shared UI via fixed ARIA labels; domain meaning
  belongs in feature-owned layers.

### Notes

- Prefer `aria-labelledby` when there is already visible on-screen text that
  should be used as the accessible name.
- If a control meaning depends on state (`Mute` vs `Unmute`), the accessible
  name should reflect the current action/state.

---

# DOM Rendering and Primitive Discipline

## Summary
Defines deterministic rendering ownership and primitive-creation thresholds to
prevent DOM leakage into logic/data layers and avoid abstraction drift.

---

## Rule: DOM Rendering Boundaries and Primitive Creation Discipline
**Rule ID:** sr-dom-rendering-and-primitives  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Enforces deterministic rendering ownership, prevents DOM leakage
into non-presentation layers, and defines when to introduce reusable UI
primitives versus allowing raw HTML.

### Requirement

- Rendering layer boundaries:
  - only these layers may render JSX/DOM:
    - `ui/primitives/**`
    - `ui/composites/**`
    - `features/*/sections/**`
    - `pages/**`
    - `core/**` (layout composition only, such as app shell/providers)
  - these layers must remain DOM-free (no JSX rendering):
    - `api/**`
    - `lib/**`
    - `store/**`
    - `hooks/**`
    - `config/**`
  - hooks must return state/functions only and never JSX.
- Primitive usage vs raw DOM:
  - when reusable primitives exist (for example `Button`, `Input`, `Card`),
    `features/**/sections/**` and `pages/**` should use them.
  - repeated direct implementations of `<button>`, `<input>`, or `<a>` should
    not bypass existing primitives.
  - raw HTML is allowed when:
    - the element is structural/layout-only (`div`, `section`, `span`, etc.),
    - no suitable primitive exists,
    - usage is truly one-off and not expected to repeat, or
    - usage is highly domain-specific and would leak domain semantics into
      `ui/**`.
- Missing primitive creation threshold:
  - raw DOM may be used temporarily if no suitable primitive exists.
  - create a new primitive in `ui/primitives/**` when any applies:
    - same semantic element pattern appears across two or more
      features/domains,
    - a shared composite needs that element as a building block,
    - two or more near-identical implementations exist with copy-pasted style
      or behavior,
    - multiple call sites independently reimplement accessibility/keyboard/focus
      or label wiring,
    - the element is a core building block (for example button/input/select/
      checkbox/radio/textarea/link/card base/modal base/tabs base/badge/
      tooltip base),
    - styling tokens/classes are repeated to enforce visual consistency.
- Shared UI layer discipline:
  - components in `ui/**` may render valid HTML but must remain domain-agnostic.
  - shared UI must not hardcode domain-specific ARIA labels or domain text.
  - shared UI must not import from `features/**`.
  - shared UI owns semantic correctness, accessibility wiring, and basic visual
    state presentation.
  - shared UI does not own business logic, domain rules, or feature semantics.
- Refactoring enforcement:
  - when DOM appears in invalid layers, refactoring should evaluate:
    1. move JSX to nearest valid presentation layer,
    2. extract reusable primitive when duplication threshold is met,
    3. split logic from markup (`domain/lib` for logic, `sections/ui` for
       markup),
    4. remove duplicated semantic implementations,
    5. replace duplicated raw DOM with shared primitive.
  - refactoring must remain behavior-preserving and within scope-governor
    limits.
- Scope and migration constraints:
  - primitive creation must respect scope caps (default max new files: 4 unless
    explicitly expanded), add no new dependencies, and create no parallel homes.
  - primitive extraction must stay inside existing gravity home
    (`ui/primitives/**`).
  - if extraction exceeds caps, emit `scope_expansion_needed[]` and deliver a
    minimal in-cap safe result first.
- Architectural principle:
  - this rule governs responsibility boundaries, not HTML availability.
  - vanilla HTML is allowed in presentation layers.
  - prefer shared primitives when reuse thresholds are met.
  - never render DOM in logic/data layers.
  - never use raw DOM as a shortcut around established abstractions.

### Forbidden

- Rendering JSX from `hooks/**`, `lib/**`, `store/**`, or `api/**`.
- Duplicating semantic elements already represented by primitives.
- Hardcoding domain semantics inside `ui/**`.
- Creating a new top-level UI home during primitive extraction.
- Introducing new styling systems or UI libraries during primitive creation
  without explicit approval.
- Using primitive extraction as justification for broad migration.

### Notes

- Any JSX detected in DOM-free layers is a structural violation and should be
  treated as high-priority boundary remediation.

---

# Prop Count Caps

## Summary
Defines soft prop-surface caps and mandatory escalation actions to prevent prop
soup and abstraction creep.

---

## Rule: Prop Count Caps and Escalation Actions
**Rule ID:** sr-prop-count-caps  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents prop soup and abstraction creep by enforcing
responsibility boundaries and preferring composition/wrappers over flag
matrices.

### Requirement

- Soft prop caps by layer/type (not hard compile failures):
  - `ui/primitives/**`: max 10 component-defined props
    - excludes native passthrough props from
      `ComponentPropsWithoutRef<...>`-style extension.
  - `ui/composites/**`: max 12 props.
  - `features/*/components/**`: max 12 props.
  - `features/*/sections/**`: max 15 props.
  - `core/**` shells/layout: max 8 props.
  - `pages/**`: max 8 props (prefer near-zero; pages should not be generic
    reusable components).
- When exceeding a cap, choose at least one escalation action and record it in
  planning/refactor metadata:
  1. split by responsibility (extract subcomponents),
  2. replace flags with composition (`children`, slots, render props),
  3. introduce feature-owned wrapper to keep shared UI generic,
  4. group props only when compliant with `sr-prop-grouping-discipline`,
  5. demote from shared UI when domain divergence is the driver.
- Layer-specific escalation constraints:
  - `ui/composites/**` must not exceed cap via domain mode flags
    (`variant="tasks|projects"`, `mode/context` matrices); prefer feature
    wrapper or feature-local duplication.
  - `ui/primitives/**` should remain thin via native passthrough plus minimal
    ergonomic props.
  - `pages/**` should not accumulate prop surfaces; extract section/composite
    instead.

### Forbidden

- Exceeding a cap silently without documenting chosen escalation action.
- Violating `sr-prop-grouping-discipline` (for example domain models hidden in
  grouped objects passed into `ui/**`).
- Growing shared composites through large flag matrices or domain switches.
- Designing one-component-to-rule-them-all APIs that hide unrelated
  responsibilities behind props.

### Notes

- Prop count is a complexity proxy; responsibility boundaries are the core
  signal.
- If temporary cap exceedance is unavoidable, record follow-up refactor scope
  instead of allowing continuing prop-surface growth.

---

# Mega-File Triage and Extraction Plan

## Summary
Defines mandatory triage and extraction sequencing when touched files exceed
safe size/responsibility thresholds.

---

## Rule: Mega-File Triage and Extraction Plan
**Rule ID:** sr-mega-file-triage  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents unsafe edits and chaotic refactors when a file is far
beyond size/responsibility thresholds.

### Requirement

- Trigger this rule when any touched file is:
  - over 600 LOC (hard stop threshold), or
  - over 400 LOC with clear multi-responsibility signals, or
  - explicitly flagged as an offender (for example, a 1500 LOC component), or
  - below threshold but showing clear prior extraction pattern with obvious
    same-pattern leftovers.
- Freeze behavior and shrink the risk surface:
  - treat work as refactor-only unless the user explicitly requests behavior
    changes,
  - default to no functional changes and preserve output, props, and side
    effects,
  - plan extraction as safe incremental steps, not a rewrite.
- Establish a bounded extraction target:
  - declare `anchor_component` (path plus export),
  - declare `extraction_budget` (how many files may change under scope caps),
  - declare `end_state_goal` as anchor file <= 250-400 LOC (or <= 600 LOC if
    explicitly timeboxed) plus stable module boundaries,
  - if scope caps prevent ideal end state, deliver in-cap reduction and include
    `scope_expansion_needed[]`.
- Continue extraction when prior-pattern signals exist, even below thresholds:
  - if an anchor file shows prior extraction signs (for example colocated
    `*.utils.ts`, `*.types.ts`, `components/*`, `*.hooks.ts`, or equivalent
    pattern files) and remaining code matches the same extraction pattern,
    continue extracting those leftovers,
  - dropping below 400/600 LOC is not a stop condition by itself,
  - stop when same-pattern leftovers are exhausted or when scope caps are hit;
    when caps block completion, emit `scope_expansion_needed[]`.
- Execute extraction ordering in this exact sequence:
  1. Step A, non-React pure logic first:
     - extract constants, pure helpers, and component-local types first,
     - keep component-only helpers/types/constants local to the component
       module folder,
     - promote to `lib/**` only when reused by 2+ domains and pure,
     - promote to `features/<domain>/domain/**` only when domain behavior is
       encoded.
  2. Step B, local subcomponents second:
     - extract clear presentational JSX chunks (especially repeated blocks),
     - keep subcomponents component-local unless cross-feature reuse is clear,
     - prefer folderization such as:
       - `ComponentName/ComponentName.tsx` (anchor),
       - `ComponentName/components/ComponentNameHeader.tsx`,
       - `ComponentName/components/ComponentNameRow.tsx`,
     - subcomponents must be prefixed for grepability (`ComponentNameRow`, not
       `Row`).
  3. Step C, hook extraction third:
     - extract complex derived state/effect/event wiring to
       `ComponentName/ComponentName.hooks.ts` or `useComponentNameState.ts`,
     - move hooks to `features/<domain>/hooks/**` only when feature-level and
       not component-scoped.
  4. Step D, split feature ownership last:
     - do not use mega-file triage as a shortcut for architecture migration,
     - keep folderization in the same gravity home unless migration mode is
       explicitly enabled,
     - propose cross-layer/home moves only after decomposition and only under
       explicit migration scope.
- Safety checks are required after each extraction step:
  - TypeScript still compiles (or would compile under existing TS config),
  - imports remain boundary-compliant (no forbidden-layer imports),
  - anchor component public API (props/exports) is unchanged unless explicitly
    requested,
  - no runtime behavior change unless explicitly requested,
  - tests are updated only when behavior changes and a suite already exists
    (extraction-only does not require new tests).
- Output contract when triggered must include:
  - phased A->D plan with file-touch list per phase,
  - explicit plan declaration: `in_cap_minimal_reduction` (default) or
    `scope_expansion_needed`,
  - implementation preference: unified diff for mega anchor-file edits and full
    content for newly extracted files.
- Practical default phased template:
  1. folderize anchor and extract constants/utils/types,
  2. extract obvious presentational subcomponents,
  3. extract state/effect logic into local hooks,
  4. optionally promote reused helpers to `lib/**` or `features/**` only when
     reuse criteria is satisfied.

### Forbidden

- Creating new `shared/common` dumping-ground directories.
- Adding new domain logic to `ui/**`.
- Introducing data fetching outside the canonical endpoint layer.
- Performing bulk formatting churn on the entire anchor file during extraction.
- Adding new flags/modes to force reuse, especially in shared composites.
- Introducing new barrels where the local area does not already use barrels.
- Stopping extraction only because line count dropped below thresholds while
  clear same-pattern leftovers remain and scope budget still allows extraction.

---

# Prop Grouping Discipline

## Summary
Defines when grouping component props is valid versus when it becomes boundary
bypass or prop-surface concealment.

---

## Rule: Prop Grouping Discipline
**Rule ID:** sr-prop-grouping-discipline  
**Priority:** SHOULD  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Keeps prop grouping intentional and cohesive while preventing
config-bag anti-patterns that hide responsibility drift.

### Requirement

- Group props only when the grouped shape represents one cohesive concern (for
  example `pagination`, `sorting`, `filters`).
- Group names must be concern-specific and explicit; avoid generic umbrella
  names.
- Grouped props in `ui/**` must remain domain-agnostic and must not carry domain
  entities, domain IDs, or domain behavior flags.
- Prefer composition (`children`, slots, render props) or feature-owned wrappers
  when grouping would otherwise mix unrelated concerns.
- If grouping is used as an escalation action for cap exceedance, reference this
  rule from `sr-prop-count-caps` plan/refactor notes.

### Forbidden

- Generic junk-drawer groups such as `config`, `options`, or `settings` that
  mix unrelated concerns.
- Grouping unrelated data, callbacks, and mode switches solely to reduce visible
  top-level prop count.
- Using grouped objects to pass domain-specific models into shared `ui/**`
  components.
- Using prop grouping to bypass layer boundaries or hide shared-composite domain
  switches.

### Notes

- This rule defines grouping correctness; prop-surface thresholds and escalation
  triggers are defined in `sr-prop-count-caps`.

---

# i18n Text Extraction

## Summary
Defines required extraction behavior for user-facing UI text when a canonical
i18n folder already exists in the repository.

---

## Rule: i18n Extraction for User-Facing UI Text
**Rule ID:** sr-i18n-text-extraction  
**Priority:** MUST  
**Applies to:** react-placement-and-layering, react-reuse-update-new, react-implementation-discipline, react-refactoring-progression  
**Inherited from:** shared-rules  
**Rationale:** Prevents hardcoded copy drift and keeps user-facing text
maintainable, localizable, and consistent.

### Requirement

- Trigger this rule when both are true:
  - a canonical i18n home exists (for example `i18n/**`, `src/i18n/**`, or
    gravity-equivalent localization home),
  - user-facing UI text literals are found in touched presentation files (for
    example `pages/**`, `features/*/sections/**`, `ui/**`).
- Extract user-facing UI text from touched files into the existing i18n home
  and reference it by translation key.
- Apply extraction to modified/new UI copy in scope; do not perform unrelated
  repository-wide localization sweeps unless explicitly requested.
- Preserve behavior and message meaning during extraction:
  - keep interpolation/variables equivalent,
  - keep state-conditional copy equivalent,
  - keep accessibility text (labels for user-facing controls) in i18n when
    localization is supported by existing repo patterns.
- Keep canonical ownership singular:
  - reuse existing i18n structure and conventions,
  - do not create a second localization home.
- Allow inline literals only when non-user-facing (for example internal debug
  logs, test-only labels/selectors, class names, protocol constants, or other
  machine-facing strings).

### Forbidden

- Leaving new or modified user-facing UI text literals inline in touched
  components when an i18n home exists.
- Introducing a second localization folder/pattern when a canonical one already
  exists.
- Mixing key-based and hardcoded user-facing variants of the same message in
  the same flow without explicit product requirement.

### Notes

- This rule governs extraction when localization infrastructure already exists;
  it does not mandate introducing i18n infrastructure into repositories that do
  not already have it.

---

# Overview

## Summary

This document defines the authoritative rules for the `react-placement-and-layering` skill.

This skill operates under:
- `shared-rules` (mandatory baseline policy)

All rules defined here are binding for agents and LLMs using this skill.

---

## Rule: Skill Scope Definition
**Rule ID:** rpl-overview-scope  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Ensures placement decisions stay within boundaries.

### Requirement

- The skill must map work to the correct layer and folder.
- The skill must use architecture detection outputs as inputs.
- The skill must justify placement with boundary rules.
- The skill must inherit and enforce shared baseline constraints from
  `shared-rules`.
- The skill must validate required inputs before planning.
- The skill must return strict machine-consumable JSON output only.
- The skill must keep output structural and exclude raw source snippets and
  secret-like values.

### Forbidden

- Creating new layers without explicit approval.
- Ignoring existing architectural conventions.
- Defining local mandatory rules that conflict with `shared-rules`.
- Producing best-effort plans from missing or invalid required inputs.
- Returning unstructured prose output outside the output contract.

### Notes

- If placement is ambiguous, list options and preferred choice in contract
  fields only.

---

# Placement Process

## Summary
Defines the placement workflow for new or updated files.

---

## Rule: Layer Mapping
**Rule ID:** rpl-process  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Keeps placement decisions consistent and testable.

### Requirement

- Validate required inputs before planning:
  - implementation request
  - target architecture rules
  - architecture-detection result
- Resolve effective output mode before planning:
  - accept optional `output_mode` (`human|agent`)
  - default to `human` when a human explicitly instructs this skill to run
  - default to `agent` otherwise
- Translate the request into explicit planning requirements before choosing
  files.
- Classify the request using one or more task categories before placement:
  - new page/route
  - new feature capability
  - new UI element
  - new API endpoint/backend integration
  - refactor/reuse improvement
  - bug fix
- Apply this skill whenever a new frontend file is introduced (for example
  React component, hook, route, API client, store module, or shared utility),
  including when that need is discovered mid-implementation.
- Just-in-time trigger: if implementation is already in progress and a new file
  is discovered as necessary, pause implementation, run this placement skill,
  then continue implementation using the placement result.
- Select one primary feature owner for the run.
- Select one strategy for the run (`follow-existing`,
  `introduce-boundaries`, or `migrate-as-you-touch`).
- Enforce import guardrails before finalizing:
  - `ui/**` must not import from `features/**`, `api/**`, `store/**`, or
    `pages/**`
  - `api/**` must not import React, `ui/**`, `features/**`, `pages/**`, or
    `store/**`
  - `lib/**` must not import React
  - `features/**` must not import from `pages/**`
  - `pages/**` must not import from the canonical endpoint layer directly; use
    feature hooks
  - `hooks/**` must not import from `features/**`, `pages/**`, or `store/**`;
    imports from `api/**` are allowed only when documented in exactly one
    canonical policy location
  - fetching/transport must remain in the canonical endpoint layer for the task
  - when a path alias exists (for example `@/`), apply guardrails to alias and
    raw `src/**` paths equally
- Enforce cross-layer error ownership in placement decisions:
  - `api/endpoints/**` owns normalized typed transport errors (`ApiError`) with
    `message` and optional `status`, `code`, `details`, and `cause`
  - `features/*/hooks/**` expose consistent error result shape and do not emit
    toasts/snackbars for query/page-load failures
  - `pages/**` and `features/*/sections/**` own user-facing error behavior;
    default query/page-load failures to inline retry UI
  - mutation toast/snackbar feedback is allowed only when that app pattern
    already exists; otherwise keep mutation feedback inline near the action
- Enforce state persistence policy when store/global-state artifacts are planned:
  - persist only user preferences and lightweight durable UI state
  - prefer URL query parameters for shareable/bookmarkable state
  - do not persist ephemeral UI state (for example modal open flags)
  - do not persist server-state snapshots in global store unless explicitly
    justified by performance-critical caching, offline-first requirements, or a
    documented architectural decision
- Map requested changes to a single owning layer per artifact.
- Apply explicit layout/shell placement ownership before finalizing each
  layout-like artifact:
  - choose `ui/primitives/**` only for low-level minimal-structure building
    blocks (for example `Stack`, `Box`, `Spacer`, `Grid`, thin `Container`)
  - choose `ui/composites/**` for reusable shell/layout patterns that compose
    multiple primitives (for example `PageShell`, `ModalShell`, `AppShell`,
    `MasterDetailLayout`, `TableShell`, `EmptyStatePanel`)
  - choose `features/<domain>/sections/**` when the layout is domain-owned
    composition (for example domain navigation, filters, or domain states)
- Default to no dedicated top-level `ui/layouts/**` or `ui/shells/**` homes.
- Allow composite categorization folders only under existing composite home:
  - `ui/composites/layouts/**`
  - `ui/composites/shells/**`
  and only when local `ui/**` already uses category subfolders and the split
  does not create a competing second home.
- Perform required repository lookup before proposing new artifacts:
  - existing route files
  - existing feature sections
  - existing UI composites/primitives
  - existing endpoint/DTO files
  - existing store slices
  - naming/export conventions
- Prefer reuse of existing folders over creating new ones.
- Apply action decision ladder per artifact:
  - `reuse` when a suitable artifact already exists as-is
  - `update` when small extension of an existing artifact is enough
  - `create` only when reuse/update is not suitable
- Produce explicit artifact records with purpose, action, layer, and path.
- For architecture/repository concern conflicts:
  - use architecture detection as default source and do not recompute gravity
  - set `override_threshold` to the shared structural pause-confidence
    threshold (`0.7` under current shared defaults)
  - if architecture confidence is below `0.7` and impact is structural, trigger
    clean pause protocol and, after explicit resolution, select repository
    evidence with `resolution_mode=pause_resolved`
  - for all other conflict cases, keep architecture detection as the effective
    source
  - after explicit resolution, record each concern in
    `source_of_truth_resolutions`
- Preserve unresolved high-impact structural ambiguity from architecture
  detection or placement analysis and block plan finalization until
  clarification is resolved.
- Keep a concise authoritative-home map for the run and use it consistently for
  placement decisions (`authoritative_home_map`).
- If no path alias is already configured, keep relative imports and do not
  introduce alias configuration unless explicitly requested.
- Include decision explanation metadata with detected architecture signals and
  chosen direction.
- Document why adjacent layers were not chosen.
- If move/rename operations are explicitly enabled, include `old_path ->
  new_path` and import-update targets before finalizing.
- In move-enabled runs, keep moves small (default: three files or fewer) and
  keep moves scoped to one concern in the run.
- If edits are confined to existing files and no new placement decision is
  required, emit a no-op placement outcome with `artifacts: []`,
  `file_actions: []`, and a short stay-in-place justification.

### Forbidden

- Splitting a single responsibility across multiple layers.
- Introducing inconsistent naming conventions.
- Emitting placement artifacts without a selected strategy and owner.
- Finalizing a plan when guardrail violations remain unresolved.
- Creating new artifacts when a clearly suitable reusable artifact already
  exists.
- Recomputing gravity independently from architecture-detection output.
- Applying repository-evidence override without explicit pause resolution when
  structural impact is present.
- Creating a parallel top-level `ui/layouts/**` or `ui/shells/**` home by
  default.
- Classifying reusable shell/layout patterns as primitives.
- Classifying domain-owned layout composition as shared composite by default.
- Finalizing `result_type=placement_plan` while unresolved high-impact structural
  ambiguity remains.
- Emitting move/rename plans without explicit import-update targets.
- Continuing implementation after discovering a new-file requirement without
  first running placement.

### Notes

- Use deterministic defaults when choices are otherwise equivalent.
- If non-structural ambiguity remains after lookup, choose the safest minimal
  artifact and record the ambiguity in notes.
- If structural ambiguity remains unresolved, pause and request confirmation.

---

# Output Contract

## Summary
Defines the expected output structure for placement decisions.

---

## Rule: Structured Placement Output
**Rule ID:** rpl-output  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Ensures decisions are traceable and actionable.

### Requirement

- Output must be one JSON object that follows a strict versioned contract.
- Output root must include:
  - `output_mode` (`human|agent`)
  - `presentation.user_markdown` (prettified markdown summary of the payload)
- Successful placement results must use `result_type=placement_plan`.
- Invalid or missing required inputs must use `result_type=validation_error`.
- Missing repository evidence must use `result_type=dependency_error`.
- `result_type=placement_plan` output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `strategy_used`
  - `feature_owner`
  - `canonical_endpoint_layer`
  - `authoritative_home_map`
  - `artifacts`
  - `layer_justifications`
  - `decision_explanation`
  - `import_guardrails`
  - `source_of_truth_resolutions`
  - `validation_status`
  - `notes`
- `result_type=placement_plan` may include `file_actions` as a concise
  placement action summary.
- `result_type=placement_plan` may include `scope_expansion_needed` when
  out-of-cap
  follow-up work would materially improve completeness.
- Each artifact must include:
  - `purpose`
  - `action` (`reuse | update | create`)
  - `action_rationale`
  - `layer`
  - `path`
  - `depends_on` (when relevant)
- `source_of_truth_resolutions` entries must include:
  - `concern`
  - `default_source`
  - `architecture_confidence`
  - `override_threshold`
  - `effective_source`
  - `resolution_mode` (`inherited | pause_resolved`)
  - `resolution_reason`
- `layer_justifications` must provide at least one concise rationale per touched
  layer.
- `decision_explanation` must summarize detected architecture signals and the
  chosen direction.
- No-op placement outcome is valid when edits are confined to existing files
  and no new placement decision is needed:
  - keep `result_type=placement_plan`
  - set `artifacts` to `[]`
  - set `file_actions` to `[]`
  - include a short stay-in-place justification in
    `decision_explanation.chosen_direction`
- `canonical_endpoint_layer` must match `detection_result.api.home` unless a
  structural conflict was explicitly pause-resolved and recorded in
  `source_of_truth_resolutions`.
- `authoritative_home_map` must provide a concise map of current authoritative
  homes for relevant concerns (for example `ui`, `api`, `domain`, `routing`).
- If move/rename operations are present, output must include
  `move_operations[]` with `old_path`, `new_path`, and `import_update_targets`,
  plus `move_concern`.
- `move_operations[]` must contain three items or fewer.
- `notes` must remain concise with maximum 5 items.
- `notes` and artifact rationales must be structural (planning metadata only).
- If `scope_expansion_needed` is present, each item must include:
  - `why`
  - `would_touch` (integer count of additional files)
- `result_type=validation_error` output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `result_type`
  - `validation_status` (`is_valid=false`, `stage=input_validation`, and at
    least one error)
  - `notes`
- `result_type=validation_error` must not include plan fields (`strategy_used`,
  `feature_owner`, `canonical_endpoint_layer`, `authoritative_home_map`,
  `artifacts`, `file_actions`,
  `layer_justifications`, `decision_explanation`, `import_guardrails`,
  `source_of_truth_resolutions`, `move_operations`, `move_concern`,
  `scope_expansion_needed`).
- `result_type=dependency_error` output must include:
  - `schema_version`
  - `skill`
  - `version`
  - `result_type`
  - `validation_status` (`is_valid=false`, `stage=planning`, and at least one
    error)
  - `dependency_issue`
  - `fallback_context_bundle_requirements` (minimum 5 entries)
  - `notes`
- `result_type=dependency_error` must not include plan fields (`strategy_used`,
  `feature_owner`, `canonical_endpoint_layer`, `authoritative_home_map`,
  `artifacts`, `file_actions`, `layer_justifications`, `decision_explanation`,
  `import_guardrails`, `source_of_truth_resolutions`, `move_operations`,
  `move_concern`, `scope_expansion_needed`).
- The full JSON payload is always produced for both `output_mode` values.
- If `output_mode=human`, print/display only `presentation.user_markdown` to the human.
- If `output_mode=human`, do not print/display raw JSON, envelope fields, or any payload field other than `presentation.user_markdown`.
- If `output_mode=agent`, print/display the full JSON payload.

### Forbidden

- Vague placement guidance without concrete paths.
- Omitting justification for layer selection.
- Returning free-form prose outside JSON output when `output_mode=agent`.
- Displaying raw JSON to humans when `output_mode=human`.
- Returning placement-plan output that omits mandatory contract fields.
- Returning validation-error output without explicit input_validation errors.
- Returning dependency-error output without fallback context requirements.
- Returning output fields with raw source snippets or secret-like values.
- Using `effective_source=repository_evidence` for structural conflicts without
  `resolution_mode=pause_resolved`.
- Returning a no-op placement output without explicit stay-in-place
  justification.

### Notes

- Keep notes concise and tied to the request.

---

# Migration Strategy and Placement Safety

## Summary
Defines migration-aware placement behavior and duplicate-home prevention.

---

## Rule: Strategy and One-Home Discipline
**Rule ID:** rpl-migration-safety  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Prevents parallel architectures and unsafe structural churn.

### Requirement

- Choose exactly one strategy per run:
  - `follow-existing`
  - `introduce-boundaries`
  - `migrate-as-you-touch`
- Follow gravity for each concern by extending the active home unless an
  explicit migration boundary is selected.
- Avoid duplicate homes by keeping one authoritative home per concern in the
  run (`authoritative_home_map`).
- Introduce new target structure only when the new scope is isolated,
  self-consistent, and does not create competing homes.
- Classify placement work as either:
  - feature task (default: updates/creates only, no moves), or
  - migration task (moves allowed only in explicit migration scope).
- Default move posture is no moves/renames; move operations require explicit
  enablement and complete import-update targets.
- In move-enabled runs, keep move scope bounded to one concern and three files
  or fewer.
- In bootstrap-triggered repositories (flat/ad-hoc with no clear homes), folder
  creation is limited to canonical homes and only the minimal folders needed for
  the task.
- In bootstrap mode, create `store/` only when truly global client state is
  required.

### Forbidden

- Treating two locations as simultaneously correct for the same concern.
- Introducing broad relocation/migration during routine feature-scope planning.
- Creating bootstrap folders outside canonical homes.
- Mixing feature-behavior changes with structural migration by default.

### Notes

- Prefer stable import boundaries and incremental convergence over early broad
  file moves.

---

# Deterministic Defaults and Pause Discipline

## Summary
Defines deterministic default actions and strict pause criteria for placement
decisions.

---

## Rule: Default Bias and Clean Pause Protocol
**Rule ID:** rpl-default-bias  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Keeps planning flow predictable while pausing only for
high-impact ambiguity.

### Requirement

- Apply deterministic defaults unless structural risk requires a pause:
  - ambiguous feature owner -> choose the most specific domain
  - UI pattern unclear -> keep logic in the feature section
  - reuse vs generalize unclear -> prefer section-level duplication
  - multiple state options -> prefer local state first
  - unsure store usage -> avoid introducing global store state
  - unsure abstraction -> keep implementation concrete
  - API placement unclear -> use the existing API home
  - folder placement unclear -> follow gravity and nearest established home
  - naming unclear -> match nearest-neighbor naming
- Pause only when both are true:
  - `confidence < 0.7`
  - impact is structural
- For low-confidence non-structural decisions, proceed with deterministic
  defaults.
- When pausing, use a clean protocol:
  1. state the structural ambiguity
  2. provide two or three bounded options
  3. provide one recommended default
  4. wait for confirmation
- Default pause mode is `balanced`; respect explicit policy overrides for
  `strict` or `autonomous` modes.

### Forbidden

- Pausing for minor naming choices, harmless small prop additions, or other
  low-impact local decisions with safe defaults.
- Asking vague or philosophical architecture questions during execution.
- Continuing with conflicting structural assumptions after deciding a pause is
  required.

### Notes

- Question quality must remain high-leverage, structural, and blocking.

---

# Discovery and Convention Fit

## Summary
Defines mandatory repository discovery and naming/export convention checks before
final placement output.

---

## Rule: Discovery Coverage and Convention Alignment
**Rule ID:** rpl-discovery-conventions  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Prevents duplicate artifacts and naming drift in placement plans.

### Requirement

- Discovery must check existing homes before proposing new artifacts:
  - route files/entry points
  - feature sections, hooks, and domain modules
  - UI composites and primitives
  - endpoint and DTO modules
  - store slices and state ownership patterns
  - naming/export conventions in the active area
- Naming and export checks must enforce local consistency:
  - pages: `*Page` unless framework or local conventions require otherwise
  - feature sections: `*Section`
  - hooks: `use*`
  - DTOs: `*Dto` and DTO placement in `api/dto` or the gravity-equivalent home
  - component files/exports in `PascalCase`
  - hook files/exports in `useXxx` camelCase
  - named exports by default; allow default exports only for framework-required
    modules or established local-area conventions
  - avoid introducing new barrels unless the local area already uses them
- Keep names searchable by aligning file names and primary exports.
- Use one role term per area (for example `Page` vs `Route` vs `Screen`) and do
  not mix synonyms unpredictably in one area.
- If tests exist in the target area, follow colocated naming compatibility
  (`*.test.tsx` or `*.test.ts`) for touched artifacts.
- Record concrete discovery evidence (paths) or explicit `not_found` outcomes
  before selecting `create`.

### Forbidden

- Proposing new artifact homes before discovery checks complete.
- Inventing a new naming/export style in an established area.
- Treating naming ambiguity as justification for structural churn.

### Notes

- Convention fit is part of placement correctness, not optional polish.

---

# Constraint and Scope Governor Alignment

## Summary
Defines required scope and constraint handling for placement planning.

---

## Rule: Constraint-Aware Placement Scope
**Rule ID:** rpl-scope-governor  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Keeps plans reviewable and prevents implicit scope expansion.

### Requirement

- Respect explicit task constraints when provided, including:
  - `avoid_new_folders`
  - `max_files_touched`
  - move/rename enablement and limits
- If explicit constraints are absent, apply shared-policy hard defaults:
  - max files touched: `8`
  - max new files: `4`
  - max moved/renamed files: `0` unless migration mode is explicit
  - max new dependencies: `0` unless explicitly requested
  - max new top-level folders: `0` unless explicitly requested
- If scope pressure exceeds caps, produce the smallest in-cap plan and record
  concise follow-up scope in `notes`.
- If extra out-of-cap scope would materially improve completeness, include a
  structured `scope_expansion_needed` array with items:
  - `why` (short reason)
  - `would_touch` (number of additional files)
- When `scope_expansion_needed` is included, still return the in-cap placement
  plan in the same output.
- If `avoid_new_folders=true`, do not propose new folder homes unless explicit
  override is provided.
- If constraints block all safe placement outcomes, return
  `result_type=validation_error` with blocking errors.

### Forbidden

- Silently exceeding explicit or default scope caps.
- Proposing new dependencies as part of normal placement planning.
- Enabling moves/renames in feature-task mode without explicit migration scope.

### Notes

- Keep scope expansion explicit and bounded; do not hide it in placement output.

---

# Access Control and Fallback Context

## Summary
Defines read/search access expectations and fallback context requirements for
placement planning.

---

## Rule: Repository Evidence Access
**Rule ID:** rpl-access-control  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Placement decisions require repository evidence to avoid
speculative structure changes.

### Requirement

- Placement planning should run with repository read/search access.
- Minimum capabilities expected:
  - list tree shape under `src/`
  - search architecture and data-access patterns
  - read files on demand
  - read key config/tooling files relevant to routing, API homes, and naming
- If direct repository access is unavailable, require a fallback context bundle
  before finalizing a plan:
  - file tree (top-level and `src/` depth about 3-4)
  - `package.json`
  - router entry/setup files
  - API client/home location currently in use
  - representative primitive/composite/section/hook/endpoint examples
- Without repository evidence or fallback bundle, return
  `result_type=dependency_error` and do not emit a placement plan.
- This skill remains planning-only and does not perform implementation edits.
- Default write posture is controlled/review-oriented output; avoid silent churn
  and unreviewed direct edits as routine behavior.
- Do not auto-edit architecture/specification documents during routine tasks
  (`ARCHITECTURE.md`, `specs/**/master_spec.md`, `spec/**`).
- Treat architecture/specification document edits as dedicated documentation
  scope and perform them only when explicitly requested.

### Forbidden

- Finalizing structural placement without repository evidence.
- Assuming gravity/convention outcomes when both direct access and fallback
  context are missing.
- Treating direct source edits as normal output for this skill.

### Notes

- When evidence is constrained, surface uncertainty in concise structural notes.

---

# Skill Model Alignment

## Summary
Defines alignment with the fixed execution-skill model and shared policy layer.

---

## Rule: Fixed Execution-Skill Scope
**Rule ID:** rpl-skill-model-alignment  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Prevents skill-scope drift and preserves cross-skill ownership
boundaries.

### Requirement

- Treat `react-placement-and-layering` as one of the fixed production execution
  skills.
- Keep primary output focused on placement plans and layer assignments.
- Coordinate with upstream architecture detection outputs and downstream reuse
  and implementation skills without absorbing their responsibilities.
- Keep shared policy/config as a separate baseline layer; do not re-model
  policy concerns as new execution-skill behavior.
- Preserve four-skill production scope:
  - `react-architecture-detection`
  - `react-placement-and-layering`
  - `react-reuse-update-new`
  - `react-implementation-discipline`

### Forbidden

- Expanding this skill to perform full implementation, broad refactors, or
  architecture detection recomputation.
- Reframing shared policy-layer behavior as a new execution-skill concern.
- Expanding production scope beyond the fixed four execution skills.

### Notes

- Cross-skill handoffs must remain explicit and machine-consumable.

---

# Implementation Handoff Formatting

## Summary
Defines downstream implementation-output formatting defaults referenced by this
planning skill.

---

## Rule: Implementation Output Format Defaults
**Rule ID:** rpl-implementation-handoff  
**Priority:** MUST  
**Applies to:** react-placement-and-layering  
**Rationale:** Keeps handoff output reviewable and consistent across placement
and implementation stages.

### Requirement

- This skill remains planning-first and JSON-contract driven.
- When a downstream implementation handoff is requested, use these formatting
  defaults:
  - updated files: provide changed snippets by default
  - switch to unified diff when:
    - edits span non-adjacent regions in one file
    - changes touch imports, exports, and logic together
    - snippet-only output is likely to be misapplied
  - new files: provide full file content
  - existing files: avoid full-file dumps unless explicitly requested, or the
    file is small (about under 60 lines) and entirely changed
  - if a newly proposed file would exceed about 250 lines, split
    responsibilities instead of producing one oversized file
- Keep implementation-handoff guidance scoped to the approved placement plan and
  scope-governor limits.

### Forbidden

- Returning implementation output in free-form or low-context formats that
  increase patch-application risk.
- Combining structural migration and feature behavior changes in one handoff
  unless migration scope is explicitly requested.
- Expanding handoff scope beyond the selected placement plan without explicit
  structured scope expansion.

### Notes

- These defaults govern implementation handoff shape; they do not replace the
  mandatory placement JSON contract.
