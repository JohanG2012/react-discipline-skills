import path from "path";
import fs from "fs/promises";
import {
  formatDate,
  listDirs,
  listFiles,
  parseFrontmatter,
  pathExists,
  readFile,
  writeFile,
} from "../lib/utils.mjs";

const args = new Set(process.argv.slice(2));
const checkOnly = args.has("--check");

const repoRoot = process.cwd();
const skillsRoot = path.join(repoRoot, "skills");
const sharedRoot = path.join(repoRoot, "shared");
const sharedRulesPath = path.join(sharedRoot, "rules");
const materializedSharedRulesDirName = ".shared-rules";
const sharedTargetSkillToken = "__TARGET_SKILL__";
const allowedIndexModes = new Set(["inline", "reference"]);

function extractSkillTitle(skillContent, fallback) {
  const lines = skillContent.split("\n");
  for (const line of lines) {
    if (line.startsWith("# ")) {
      return line.slice(2).trim();
    }
  }
  return fallback;
}

function buildHeader({ skillName, skillTitle, generatedOn, inlineCount }) {
  return [
    "<!--",
    "DO NOT EDIT THIS FILE DIRECTLY.",
    "",
    "This file is generated from ./.shared-rules/*.md and ./rules/*.md",
    "Edit the rule source files instead, then recompile.",
    "",
    `Generated on: ${generatedOn}`,
    "-->",
    "",
    `# ${skillTitle} â€” Agent Rule Index`,
    "",
    "## Overview",
    `This document defines the authoritative lookup index for agents/LLMs using the \`${skillName}\` skill.`,
    "",
    "Shared baseline policy is materialized per skill in `./.shared-rules/` to keep this skill portable when installed standalone.",
    "",
    "Read behavior:",
    "- `inline` rules are embedded below and must be treated as always-on guidance.",
    "- `reference` rules are listed in the index; load them from their source file when relevant.",
    "",
    `Inline rules in this document: ${inlineCount}.`,
    "",
    "## Rule Lookup Index",
    "<!-- GENERATED_RULE_INDEX -->",
    "",
    "## Inline Rules",
    "<!-- GENERATED_INLINE_RULES -->",
  ].join("\n");
}

function escapeInlinePipes(text) {
  return text.replace(/\|/g, "\\|");
}

function collapseWhitespace(text) {
  return text.replace(/\s+/g, " ").trim();
}

function buildRuleIndex(entries) {
  if (!entries.length) return "- (none)";

  const rows = [
    "| Rule ID | Rule | Priority | Mode | Covers | Rationale | Source |",
    "| --- | --- | --- | --- | --- | --- | --- |",
  ];

  for (const entry of entries) {
    const row = [
      `\`${entry.ruleId}\``,
      escapeInlinePipes(entry.title),
      entry.priority,
      `\`${entry.indexMode}\``,
      escapeInlinePipes(entry.covers),
      escapeInlinePipes(entry.rationale),
      `\`${entry.sourcePath}\``,
    ];
    rows.push(`| ${row.join(" | ")} |`);
  }

  return rows.join("\n");
}

function reheadingRuleBlock(blockText) {
  return blockText.replace(/^##\s+Rule:/, "### Rule:");
}

function buildInlineRules(entries) {
  if (!entries.length) return "- (none)";
  return entries
    .map((entry) => {
      const heading = `#### Source: \`${entry.sourcePath}\``;
      return [heading, "", reheadingRuleBlock(entry.blockText)].join("\n");
    })
    .join("\n\n---\n\n");
}

function findRuleBlocks(content) {
  const lines = content.split("\n");
  const starts = [];
  for (let i = 0; i < lines.length; i += 1) {
    if (/^##\s+Rule:/.test(lines[i])) {
      starts.push(i);
    }
  }

  if (starts.length === 0) {
    return {
      preamble: content.trim(),
      blocks: [],
    };
  }

  const preamble = lines.slice(0, starts[0]).join("\n");
  const blocks = [];
  for (let i = 0; i < starts.length; i += 1) {
    const start = starts[i];
    const end = starts[i + 1] ?? lines.length;
    const blockText = lines.slice(start, end).join("\n");
    const title = lines[start].replace(/^##\s+Rule:\s*/, "").trim();
    blocks.push({
      title,
      text: blockText,
    });
  }

  return { preamble, blocks };
}

function extractFieldValue(blockText, fieldName) {
  const lines = blockText.split("\n");
  const regex = new RegExp(`^\\*\\*${fieldName}:\\*\\*\\s*(.*?)\\s*$`);

  for (let i = 0; i < lines.length; i += 1) {
    const match = lines[i].match(regex);
    if (!match) {
      continue;
    }

    const valueParts = [];
    if (match[1]) {
      valueParts.push(match[1].trim());
    }

    for (let j = i + 1; j < lines.length; j += 1) {
      const next = lines[j];
      if (!next.trim()) {
        break;
      }
      if (/^\*\*[^:]+:\*\*/.test(next) || /^###\s+/.test(next) || /^##\s+/.test(next)) {
        break;
      }
      valueParts.push(next.trim());
    }

    return valueParts.join(" ").trim();
  }

  return null;
}

function parseSkillList(rawValue) {
  if (!rawValue) return [];

  return rawValue
    .split(",")
    .map((value) => value.trim().replace(/^`/, "").replace(/`$/, ""))
    .filter(Boolean);
}

function normalizeSectionText(text) {
  return text
    .trim()
    .replace(/\n---\s*$/m, "")
    .trim();
}

function ruleFileSort(a, b) {
  const aMatch = a.match(/^(\d+)/);
  const bMatch = b.match(/^(\d+)/);
  const aNum = aMatch ? Number.parseInt(aMatch[1], 10) : Number.POSITIVE_INFINITY;
  const bNum = bMatch ? Number.parseInt(bMatch[1], 10) : Number.POSITIVE_INFINITY;
  if (aNum !== bNum) return aNum - bNum;
  return a.localeCompare(b);
}

async function loadRuleContents(rulesPath) {
  const rulesExists = await pathExists(rulesPath);
  if (!rulesExists) return [];

  const ruleFiles = (await listFiles(rulesPath))
    .filter((f) => f.endsWith(".md"))
    .sort(ruleFileSort);
  if (!ruleFiles.length) return [];

  const sources = [];
  for (const file of ruleFiles) {
    const filePath = path.join(rulesPath, file);
    const content = await readFile(filePath);
    const { preamble, blocks } = findRuleBlocks(content);
    if (!blocks.length) {
      continue;
    }
    sources.push({
      file,
      relativePath: `rules/${file}`,
      preamble: normalizeSectionText(preamble),
      blocks: blocks.map((block) => ({
        ...block,
        text: normalizeSectionText(block.text),
      })),
    });
  }
  return sources;
}

function materializeForSkill(text, skillName) {
  return text.replaceAll(sharedTargetSkillToken, skillName);
}

async function loadSharedRuleSources() {
  const rulesExists = await pathExists(sharedRulesPath);
  if (!rulesExists) return null;

  const ruleFiles = (await listFiles(sharedRulesPath))
    .filter((f) => f.endsWith(".md"))
    .sort(ruleFileSort);

  if (ruleFiles.length === 0) return null;

  const sources = [];
  for (const file of ruleFiles) {
    const filePath = path.join(sharedRulesPath, file);
    const content = await readFile(filePath);
    const { preamble, blocks } = findRuleBlocks(content);
    if (!blocks.length) {
      continue;
    }

    const parsedBlocks = blocks.map((block) => ({
      ...block,
      appliesTo: parseSkillList(extractFieldValue(block.text, "Applies to")),
    }));

    sources.push({
      file,
      preamble: normalizeSectionText(preamble),
      blocks: parsedBlocks,
    });
  }

  return sources;
}

function sanitizeIndexMode(raw) {
  if (!raw) return "reference";
  const normalized = raw.trim().toLowerCase();
  if (allowedIndexModes.has(normalized)) {
    return normalized;
  }
  return "reference";
}

function resolveSharedRulesForSkill(sharedSources, skillName) {
  const materializedFiles = [];

  for (const source of sharedSources) {
    const selectedBlocks = [];
    for (const block of source.blocks) {
      if (block.appliesTo.includes(skillName)) {
        selectedBlocks.push({
          ...block,
          text: materializeForSkill(
            normalizeSectionText(block.text),
            skillName,
          ),
        });
      }
    }

    if (!selectedBlocks.length) {
      continue;
    }

    const sectionParts = [];
    if (source.preamble) {
      sectionParts.push(materializeForSkill(source.preamble, skillName));
    }
    sectionParts.push(...selectedBlocks.map((block) => block.text));
    materializedFiles.push({
      file: source.file,
      relativePath: `${materializedSharedRulesDirName}/${source.file}`,
      content: sectionParts.join("\n\n---\n\n"),
      blocks: selectedBlocks,
    });
  }

  return materializedFiles;
}

function extractRuleEntryFromBlock({ block, sourcePath, skillName, order }) {
  const ruleId = extractFieldValue(block.text, "Rule ID") || `unknown-${order}`;
  const priority = extractFieldValue(block.text, "Priority") || "MUST";
  const rationale = collapseWhitespace(extractFieldValue(block.text, "Rationale") || block.title);
  const covers = collapseWhitespace(extractFieldValue(block.text, "Covers") || block.title);
  const indexMode = sanitizeIndexMode(extractFieldValue(block.text, "Index mode"));

  return {
    order,
    skillName,
    ruleId,
    title: block.title,
    priority,
    rationale,
    covers,
    indexMode,
    sourcePath,
    blockText: block.text,
  };
}

function collectRuleEntries({ skillName, localSources, sharedMaterializedSources }) {
  const entries = [];
  let order = 0;

  for (const source of sharedMaterializedSources) {
    for (const block of source.blocks) {
      order += 1;
      entries.push(extractRuleEntryFromBlock({
        block,
        sourcePath: source.relativePath,
        skillName,
        order,
      }));
    }
  }

  for (const source of localSources) {
    for (const block of source.blocks) {
      order += 1;
      entries.push(extractRuleEntryFromBlock({
        block,
        sourcePath: source.relativePath,
        skillName,
        order,
      }));
    }
  }

  return entries;
}

async function syncMaterializedSharedRules({
  skillPath,
  sharedMaterializedSources,
  checkOnly,
}) {
  const targetDir = path.join(skillPath, materializedSharedRulesDirName);
  const expected = new Map(
    sharedMaterializedSources.map((source) => [source.file, `${source.content}\n`]),
  );
  const dirExists = await pathExists(targetDir);

  if (!checkOnly) {
    await fs.mkdir(targetDir, { recursive: true });
  }

  const existingFiles = dirExists ? (await listFiles(targetDir)) : [];
  let hasDiff = false;

  for (const [file, expectedContent] of expected.entries()) {
    const filePath = path.join(targetDir, file);
    const exists = dirExists && existingFiles.includes(file);
    const currentContent = exists ? await readFile(filePath) : "";
    if (currentContent !== expectedContent) {
      hasDiff = true;
      if (checkOnly) {
        process.stderr.write(`Shared rules out of date: ${filePath}\n`);
      } else {
        await writeFile(filePath, expectedContent);
      }
    }
  }

  for (const file of existingFiles) {
    if (!file.endsWith(".md")) {
      continue;
    }
    if (expected.has(file)) {
      continue;
    }
    hasDiff = true;
    const filePath = path.join(targetDir, file);
    if (checkOnly) {
      process.stderr.write(`Stale generated shared rule file: ${filePath}\n`);
    } else {
      await fs.unlink(filePath);
    }
  }

  return hasDiff;
}

function buildAgentsOutput({ skillName, skillTitle, ruleEntries }) {
  const inlineRules = ruleEntries.filter((entry) => entry.indexMode === "inline");
  const header = buildHeader({
    skillName,
    skillTitle,
    generatedOn: formatDate(),
    inlineCount: inlineRules.length,
  });

  return header
    .replace("<!-- GENERATED_RULE_INDEX -->", buildRuleIndex(ruleEntries))
    .replace("<!-- GENERATED_INLINE_RULES -->", buildInlineRules(inlineRules));
}

async function buildSkillArtifacts(skillDir, sharedSources) {
  const skillPath = path.join(skillsRoot, skillDir);
  const localSources = await loadRuleContents(path.join(skillPath, "rules"));
  if (!localSources.length) return null;

  const skillFile = path.join(skillPath, "SKILL.md");
  const skillContent = await readFile(skillFile);
  const frontmatter = parseFrontmatter(skillContent) || {};
  const skillName = frontmatter.name || skillDir;
  const skillTitle = extractSkillTitle(skillContent, skillName);
  const sharedMaterializedSources = resolveSharedRulesForSkill(
    sharedSources,
    skillName,
  );
  const ruleEntries = collectRuleEntries({
    skillName,
    localSources,
    sharedMaterializedSources,
  });

  return {
    skillPath,
    agentsContent: buildAgentsOutput({
      skillName,
      skillTitle,
      ruleEntries,
    }),
    sharedMaterializedSources,
  };
}

async function listSkillTargets() {
  return (await listDirs(skillsRoot))
    .filter((d) => !d.startsWith("."))
    .sort();
}

async function run() {
  const sharedSources = await loadSharedRuleSources();
  if (!sharedSources) {
    process.stderr.write(
      `Missing shared baseline rules at ${sharedRulesPath}\n`,
    );
    process.exit(1);
  }

  const skillDirs = await listSkillTargets();
  let hasDiff = false;

  for (const skillDir of skillDirs) {
    const artifacts = await buildSkillArtifacts(skillDir, sharedSources);
    if (!artifacts) continue;

    const sharedDiff = await syncMaterializedSharedRules({
      skillPath: artifacts.skillPath,
      sharedMaterializedSources: artifacts.sharedMaterializedSources,
      checkOnly,
    });
    if (sharedDiff) {
      hasDiff = true;
    }

    const agentsPath = path.join(skillsRoot, skillDir, "AGENTS.md");
    const expected = `${artifacts.agentsContent}\n`;
    if (checkOnly) {
      const exists = await pathExists(agentsPath);
      const current = exists ? await readFile(agentsPath) : "";
      if (current !== expected) {
        hasDiff = true;
        process.stderr.write(`AGENTS.md out of date: ${agentsPath}\n`);
      }
      continue;
    }
    await writeFile(agentsPath, expected);
  }

  if (checkOnly && hasDiff) {
    process.exit(1);
  }
}

run().catch((err) => {
  process.stderr.write(`${err.message}\n`);
  process.exit(1);
});
