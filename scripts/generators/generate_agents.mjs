import path from "path";
import {
  formatDate,
  listDirs,
  listFiles,
  parseFrontmatter,
  pathExists,
  readFile,
  slugify,
  writeFile,
} from "../lib/utils.mjs";

const args = new Set(process.argv.slice(2));
const checkOnly = args.has("--check");

const repoRoot = process.cwd();
const skillsRoot = path.join(repoRoot, "skills");
const sharedRoot = path.join(repoRoot, "shared");
const sharedRulesPath = path.join(sharedRoot, "rules");

function extractSkillTitle(skillContent, fallback) {
  const lines = skillContent.split("\n");
  for (const line of lines) {
    if (line.startsWith("# ")) {
      return line.slice(2).trim();
    }
  }
  return fallback;
}

function buildHeader({ skillName, skillTitle, generatedOn }) {
  return [
    "<!--",
    "DO NOT EDIT THIS FILE DIRECTLY.",
    "",
    "This file is generated from shared/rules/*.md and ./rules/*.md",
    "Edit the rule source files instead, then recompile.",
    "",
    `Generated on: ${generatedOn}`,
    "-->",
    "",
    `# ${skillTitle} â€” Agent Rules`,
    "",
    "## Table of contents",
    "<!-- GENERATED_TOC -->",
    "",
    "## Overview",
    `This document defines the authoritative rules for agents/LLMs using the \`${skillName}\` skill.`,
    "",
    "Key constraints:",
    "- Follow `agent-policy-v1` unless explicitly overridden by an allowed migration strategy.",
    "- If a rule references a rule ID, the rule ID must be followed exactly.",
    "",
    "## Rule index",
    "<!-- OPTIONAL: GENERATED_RULE_INDEX -->",
    "",
    "---",
    "",
    "<!-- GENERATED_RULES -->",
  ].join("\n");
}

function buildToc(headings) {
  if (!headings.length) return "- (none)";
  return headings.map((h) => `- [${h}](#${slugify(h)})`).join("\n");
}

function buildRuleIndex(ruleIds) {
  if (!ruleIds.length) return "- (none)";
  return ruleIds.map((id) => `- ${id}`).join("\n");
}

function extractHeadings(content) {
  return content
    .split("\n")
    .filter((line) => line.startsWith("## "))
    .map((line) => line.replace(/^##\s+/, "").trim());
}

function extractRuleIds(content) {
  const ids = [];
  const regex = /^\*\*Rule ID:\*\*\s*(.+)$/gm;
  let match;
  while ((match = regex.exec(content)) !== null) {
    ids.push(match[1].trim());
  }
  return ids;
}

function ruleFileSort(a, b) {
  const aMatch = a.match(/^(\d+)/);
  const bMatch = b.match(/^(\d+)/);
  const aNum = aMatch ? Number.parseInt(aMatch[1], 10) : Number.POSITIVE_INFINITY;
  const bNum = bMatch ? Number.parseInt(bMatch[1], 10) : Number.POSITIVE_INFINITY;
  if (aNum !== bNum) return aNum - bNum;
  return a.localeCompare(b);
}

async function loadRuleContents(rulesPath) {
  const rulesExists = await pathExists(rulesPath);
  if (!rulesExists) return null;

  const ruleFiles = (await listFiles(rulesPath))
    .filter((f) => f.endsWith(".md"))
    .sort(ruleFileSort);
  if (ruleFiles.length === 0) return null;

  const ruleContents = [];
  for (const file of ruleFiles) {
    const content = await readFile(path.join(rulesPath, file));
    ruleContents.push(content.trim());
  }
  return ruleContents.join("\n\n---\n\n");
}

async function buildSkillAgents(skillDir, sharedRules) {
  const skillPath = path.join(skillsRoot, skillDir);
  const localRules = await loadRuleContents(path.join(skillPath, "rules"));
  if (!localRules) return null;

  const skillFile = path.join(skillPath, "SKILL.md");
  const skillContent = await readFile(skillFile);
  const frontmatter = parseFrontmatter(skillContent) || {};
  const skillName = frontmatter.name || skillDir;
  const skillTitle = extractSkillTitle(skillContent, skillName);

  const combinedRules = [sharedRules, localRules]
    .filter(Boolean)
    .join("\n\n---\n\n");
  const headings = extractHeadings(combinedRules);
  const ruleIds = extractRuleIds(combinedRules);

  const header = buildHeader({
    skillName,
    skillTitle,
    generatedOn: formatDate(),
  });

  const output = header
    .replace("<!-- GENERATED_TOC -->", buildToc(headings))
    .replace("<!-- OPTIONAL: GENERATED_RULE_INDEX -->", buildRuleIndex(ruleIds))
    .replace("<!-- GENERATED_RULES -->", combinedRules || "(no rules found)");

  return output;
}

async function listSkillTargets() {
  return (await listDirs(skillsRoot))
    .filter((d) => !d.startsWith("."))
    .sort();
}

async function run() {
  const sharedRules = await loadRuleContents(sharedRulesPath);
  if (!sharedRules) {
    process.stderr.write(
      `Missing shared baseline rules at ${sharedRulesPath}\n`,
    );
    process.exit(1);
  }

  const skillDirs = await listSkillTargets();
  let hasDiff = false;

  for (const skillDir of skillDirs) {
    const content = await buildSkillAgents(skillDir, sharedRules);
    if (!content) continue;
    const agentsPath = path.join(skillsRoot, skillDir, "AGENTS.md");
    if (checkOnly) {
      const exists = await pathExists(agentsPath);
      const current = exists ? await readFile(agentsPath) : "";
      const expected = `${content}\n`;
      if (current !== expected) {
        hasDiff = true;
        process.stderr.write(`AGENTS.md out of date: ${agentsPath}\n`);
      }
      continue;
    }
    await writeFile(agentsPath, `${content}\n`);
  }

  if (checkOnly && hasDiff) {
    process.exit(1);
  }
}

run().catch((err) => {
  process.stderr.write(`${err.message}\n`);
  process.exit(1);
});
