import path from "path";
import {
  formatDate,
  listDirs,
  listFiles,
  parseFrontmatter,
  pathExists,
  readFile,
  slugify,
  writeFile,
} from "../lib/utils.mjs";

const args = new Set(process.argv.slice(2));
const checkOnly = args.has("--check");

const repoRoot = process.cwd();
const skillsRoot = path.join(repoRoot, "skills");
const sharedRoot = path.join(repoRoot, "shared");
const sharedRulesPath = path.join(sharedRoot, "rules");
const sharedTargetSkillToken = "__TARGET_SKILL__";

function extractSkillTitle(skillContent, fallback) {
  const lines = skillContent.split("\n");
  for (const line of lines) {
    if (line.startsWith("# ")) {
      return line.slice(2).trim();
    }
  }
  return fallback;
}

function buildHeader({ skillName, skillTitle, generatedOn }) {
  return [
    "<!--",
    "DO NOT EDIT THIS FILE DIRECTLY.",
    "",
    "This file is generated from shared/rules/*.md and ./rules/*.md",
    "Edit the rule source files instead, then recompile.",
    "",
    `Generated on: ${generatedOn}`,
    "-->",
    "",
    `# ${skillTitle} â€” Agent Rules`,
    "",
    "## Table of contents",
    "<!-- GENERATED_TOC -->",
    "",
    "## Overview",
    `This document defines the authoritative rules for agents/LLMs using the \`${skillName}\` skill.`,
    "",
    "Key constraints:",
    "- Follow shared baseline rules baked into this document (`shared-rules`) unless explicitly overridden by an allowed migration strategy.",
    "- If a rule references a rule ID, the rule ID must be followed exactly.",
    "",
    "## Rule index",
    "<!-- OPTIONAL: GENERATED_RULE_INDEX -->",
    "",
    "---",
    "",
    "<!-- GENERATED_RULES -->",
  ].join("\n");
}

function buildToc(entries) {
  if (!entries.length) return "- (none)";
  return entries
    .map((entry) => `- [${entry.label}](#${entry.slug})`)
    .join("\n");
}

function buildRuleIndex(ruleIds) {
  if (!ruleIds.length) return "- (none)";
  return ruleIds.map((id) => `- ${id}`).join("\n");
}

function extractTocEntries(content) {
  const lines = content.split("\n");
  const slugCounts = new Map();
  const entries = [];

  for (let i = 0; i < lines.length; i += 1) {
    const headingMatch = lines[i].match(/^##\s+Rule:\s+(.+)\s*$/);
    if (!headingMatch) {
      continue;
    }

    const heading = `Rule: ${headingMatch[1].trim()}`;
    let ruleId = null;
    for (let j = i + 1; j < lines.length; j += 1) {
      if (/^##\s+/.test(lines[j])) {
        break;
      }
      const ruleIdMatch = lines[j].match(/^\*\*Rule ID:\*\*\s*(.+?)\s*$/);
      if (ruleIdMatch) {
        ruleId = ruleIdMatch[1].trim();
        break;
      }
    }

    const slugBase = slugify(heading);
    const slugCount = slugCounts.get(slugBase) || 0;
    slugCounts.set(slugBase, slugCount + 1);
    const slug = slugCount === 0 ? slugBase : `${slugBase}-${slugCount}`;

    entries.push({
      label: ruleId ? `${heading} [${ruleId}]` : heading,
      slug,
    });
  }

  return entries;
}

function extractRuleIds(content) {
  const ids = [];
  const regex = /^\*\*Rule ID:\*\*\s*(.+)$/gm;
  let match;
  while ((match = regex.exec(content)) !== null) {
    ids.push(match[1].trim());
  }
  return ids;
}

function findRuleBlocks(content) {
  const lines = content.split("\n");
  const starts = [];
  for (let i = 0; i < lines.length; i += 1) {
    if (/^##\s+Rule:/.test(lines[i])) {
      starts.push(i);
    }
  }

  if (starts.length === 0) {
    return {
      preamble: content.trim(),
      blocks: [],
    };
  }

  const preamble = lines.slice(0, starts[0]).join("\n");
  const blocks = [];
  for (let i = 0; i < starts.length; i += 1) {
    const start = starts[i];
    const end = starts[i + 1] ?? lines.length;
    const blockText = lines.slice(start, end).join("\n");
    const title = lines[start].replace(/^##\s+Rule:\s*/, "").trim();
    blocks.push({
      title,
      text: blockText,
    });
  }

  return { preamble, blocks };
}

function extractFieldValue(blockText, fieldName) {
  const regex = new RegExp(`^\\*\\*${fieldName}:\\*\\*\\s*(.+?)\\s*$`, "m");
  const match = blockText.match(regex);
  return match ? match[1].trim() : null;
}

function parseSkillList(rawValue) {
  if (!rawValue) return [];

  return rawValue
    .split(",")
    .map((value) => value.trim().replace(/^`/, "").replace(/`$/, ""))
    .filter(Boolean);
}

function normalizeSectionText(text) {
  return text
    .trim()
    .replace(/\n---\s*$/m, "")
    .trim();
}

function ruleFileSort(a, b) {
  const aMatch = a.match(/^(\d+)/);
  const bMatch = b.match(/^(\d+)/);
  const aNum = aMatch ? Number.parseInt(aMatch[1], 10) : Number.POSITIVE_INFINITY;
  const bNum = bMatch ? Number.parseInt(bMatch[1], 10) : Number.POSITIVE_INFINITY;
  if (aNum !== bNum) return aNum - bNum;
  return a.localeCompare(b);
}

async function loadRuleContents(rulesPath) {
  const rulesExists = await pathExists(rulesPath);
  if (!rulesExists) return null;

  const ruleFiles = (await listFiles(rulesPath))
    .filter((f) => f.endsWith(".md"))
    .sort(ruleFileSort);
  if (ruleFiles.length === 0) return null;

  const ruleContents = [];
  for (const file of ruleFiles) {
    const content = await readFile(path.join(rulesPath, file));
    ruleContents.push(content.trim());
  }
  return ruleContents.join("\n\n---\n\n");
}

function materializeForSkill(text, skillName) {
  return text.replaceAll(sharedTargetSkillToken, skillName);
}

async function loadSharedRuleSources() {
  const rulesExists = await pathExists(sharedRulesPath);
  if (!rulesExists) return null;

  const ruleFiles = (await listFiles(sharedRulesPath))
    .filter((f) => f.endsWith(".md"))
    .sort(ruleFileSort);

  if (ruleFiles.length === 0) return null;

  const sources = [];
  for (const file of ruleFiles) {
    const filePath = path.join(sharedRulesPath, file);
    const content = await readFile(filePath);
    const { preamble, blocks } = findRuleBlocks(content);
    if (!blocks.length) {
      continue;
    }

    const parsedBlocks = blocks.map((block) => ({
      ...block,
      appliesTo: parseSkillList(extractFieldValue(block.text, "Applies to")),
    }));

    sources.push({
      file,
      preamble: normalizeSectionText(preamble),
      blocks: parsedBlocks,
    });
  }

  return sources;
}

function resolveSharedRulesForSkill(sharedSources, skillName) {
  const inlineSections = [];

  for (const source of sharedSources) {
    const inlineBlocks = [];
    for (const block of source.blocks) {
      if (block.appliesTo.includes(skillName)) {
        inlineBlocks.push(materializeForSkill(
          normalizeSectionText(block.text),
          skillName,
        ));
      }
    }

    if (!inlineBlocks.length) {
      continue;
    }

    const sectionParts = [];
    if (source.preamble) {
      sectionParts.push(materializeForSkill(source.preamble, skillName));
    }
    sectionParts.push(...inlineBlocks);
    inlineSections.push(sectionParts.join("\n\n---\n\n"));
  }

  return inlineSections.join("\n\n---\n\n");
}

async function buildSkillAgents(skillDir, sharedSources) {
  const skillPath = path.join(skillsRoot, skillDir);
  const localRules = await loadRuleContents(path.join(skillPath, "rules"));
  if (!localRules) return null;

  const skillFile = path.join(skillPath, "SKILL.md");
  const skillContent = await readFile(skillFile);
  const frontmatter = parseFrontmatter(skillContent) || {};
  const skillName = frontmatter.name || skillDir;
  const skillTitle = extractSkillTitle(skillContent, skillName);
  const resolvedSharedRules = resolveSharedRulesForSkill(
    sharedSources,
    skillName,
  );

  const combinedRules = [resolvedSharedRules, localRules]
    .filter(Boolean)
    .join("\n\n---\n\n");
  const tocEntries = extractTocEntries(combinedRules);
  const ruleIds = extractRuleIds(combinedRules);

  const header = buildHeader({
    skillName,
    skillTitle,
    generatedOn: formatDate(),
  });

  const output = header
    .replace("<!-- GENERATED_TOC -->", buildToc(tocEntries))
    .replace("<!-- OPTIONAL: GENERATED_RULE_INDEX -->", buildRuleIndex(ruleIds))
    .replace("<!-- GENERATED_RULES -->", combinedRules || "(no rules found)");

  return output;
}

async function listSkillTargets() {
  return (await listDirs(skillsRoot))
    .filter((d) => !d.startsWith("."))
    .sort();
}

async function run() {
  const sharedSources = await loadSharedRuleSources();
  if (!sharedSources) {
    process.stderr.write(
      `Missing shared baseline rules at ${sharedRulesPath}\n`,
    );
    process.exit(1);
  }

  const skillDirs = await listSkillTargets();
  let hasDiff = false;

  for (const skillDir of skillDirs) {
    const content = await buildSkillAgents(skillDir, sharedSources);
    if (!content) continue;
    const agentsPath = path.join(skillsRoot, skillDir, "AGENTS.md");
    if (checkOnly) {
      const exists = await pathExists(agentsPath);
      const current = exists ? await readFile(agentsPath) : "";
      const expected = `${content}\n`;
      if (current !== expected) {
        hasDiff = true;
        process.stderr.write(`AGENTS.md out of date: ${agentsPath}\n`);
      }
      continue;
    }
    await writeFile(agentsPath, `${content}\n`);
  }

  if (checkOnly && hasDiff) {
    process.exit(1);
  }
}

run().catch((err) => {
  process.stderr.write(`${err.message}\n`);
  process.exit(1);
});
